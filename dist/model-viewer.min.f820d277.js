// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"scripts/model-viewer.min.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelViewerElement = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e304) { throw _e304; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e305) { didErr = true; err = _e305; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
String(Math.random()).slice(2),
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
window.trustedTypes && trustedTypes.createPolicy("lit-html", {
  createHTML: function createHTML(t) {
    return t;
  }
});
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

var t = !1;
(function () {
  try {
    var _e2 = {
      get capture() {
        return t = !0, !1;
      }

    };
    window.addEventListener("test", _e2, _e2), window.removeEventListener("test", _e2, _e2);
  } catch (t) {}
})(),
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"undefined" != typeof window && (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.3.0")
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
, void 0 === window.ShadyCSS || void 0 === window.ShadyCSS.prepareTemplateDom && console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.")
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
, window.JSCompiler_renameProperty = function (t, e) {
  return t;
};

var e = {
  toAttribute: function toAttribute(t, e) {
    switch (e) {
      case Boolean:
        return t ? "" : null;

      case Object:
      case Array:
        return null == t ? t : JSON.stringify(t);
    }

    return t;
  },
  fromAttribute: function fromAttribute(t, e) {
    switch (e) {
      case Boolean:
        return null !== t;

      case Number:
        return null === t ? null : Number(t);

      case Object:
      case Array:
        return JSON.parse(t);
    }

    return t;
  }
},
    n = function n(t, e) {
  return e !== t && (e == e || t == t);
},
    i = {
  attribute: !0,
  type: String,
  converter: e,
  reflect: !1,
  hasChanged: n
};

var r = /*#__PURE__*/function (_HTMLElement) {
  _inherits(r, _HTMLElement);

  var _super = _createSuper(r);

  function r() {
    var _this;

    _classCallCheck(this, r);

    _this = _super.call(this), _this.initialize();
    return _this;
  }

  _createClass(r, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      this._updateState = 0, this._updatePromise = new Promise(function (t) {
        return _this2._enableUpdatingResolver = t;
      }), this._changedProperties = new Map(), this._saveInstanceProperties(), this.requestUpdateInternal();
    }
  }, {
    key: "_saveInstanceProperties",
    value: function _saveInstanceProperties() {
      var _this3 = this;

      this.constructor._classProperties.forEach(function (t, e) {
        if (_this3.hasOwnProperty(e)) {
          var _t2 = _this3[e];
          delete _this3[e], _this3._instanceProperties || (_this3._instanceProperties = new Map()), _this3._instanceProperties.set(e, _t2);
        }
      });
    }
  }, {
    key: "_applyInstanceProperties",
    value: function _applyInstanceProperties() {
      var _this4 = this;

      this._instanceProperties.forEach(function (t, e) {
        return _this4[e] = t;
      }), this._instanceProperties = void 0;
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      this.enableUpdating();
    }
  }, {
    key: "enableUpdating",
    value: function enableUpdating() {
      void 0 !== this._enableUpdatingResolver && (this._enableUpdatingResolver(), this._enableUpdatingResolver = void 0);
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {}
  }, {
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(t, e, n) {
      e !== n && this._attributeToProperty(t, n);
    }
  }, {
    key: "_propertyToAttribute",
    value: function _propertyToAttribute(t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : i;

      var _r5 = this.constructor,
          s = _r5._attributeNameForProperty(t, n);

      if (void 0 !== s) {
        var _t3 = _r5._propertyValueToAttribute(e, n);

        if (void 0 === _t3) return;
        this._updateState = 8 | this._updateState, null == _t3 ? this.removeAttribute(s) : this.setAttribute(s, _t3), this._updateState = -9 & this._updateState;
      }
    }
  }, {
    key: "_attributeToProperty",
    value: function _attributeToProperty(t, e) {
      if (8 & this._updateState) return;

      var n = this.constructor,
          i = n._attributeToPropertyMap.get(t);

      if (void 0 !== i) {
        var _t4 = n.getPropertyOptions(i);

        this._updateState = 16 | this._updateState, this[i] = n._propertyValueFromAttribute(e, _t4), this._updateState = -17 & this._updateState;
      }
    }
  }, {
    key: "requestUpdateInternal",
    value: function requestUpdateInternal(t, e, n) {
      var i = !0;

      if (void 0 !== t) {
        var _r7 = this.constructor;
        n = n || _r7.getPropertyOptions(t), _r7._valueHasChanged(this[t], e, n.hasChanged) ? (this._changedProperties.has(t) || this._changedProperties.set(t, e), !0 !== n.reflect || 16 & this._updateState || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map()), this._reflectingProperties.set(t, n))) : i = !1;
      }

      !this._hasRequestedUpdate && i && (this._updatePromise = this._enqueueUpdate());
    }
  }, {
    key: "requestUpdate",
    value: function requestUpdate(t, e) {
      return this.requestUpdateInternal(t, e), this.updateComplete;
    }
  }, {
    key: "_enqueueUpdate",
    value: function () {
      var _enqueueUpdate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var t;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._updateState = 4 | this._updateState;
                _context.prev = 1;
                _context.next = 4;
                return this._updatePromise;

              case 4:
                _context.next = 8;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](1);

              case 8:
                t = this.performUpdate();
                _context.t1 = null != t;

                if (!_context.t1) {
                  _context.next = 13;
                  break;
                }

                _context.next = 13;
                return t;

              case 13:
                return _context.abrupt("return", !this._hasRequestedUpdate);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 6]]);
      }));

      function _enqueueUpdate() {
        return _enqueueUpdate2.apply(this, arguments);
      }

      return _enqueueUpdate;
    }()
  }, {
    key: "_hasRequestedUpdate",
    get: function get() {
      return 4 & this._updateState;
    }
  }, {
    key: "hasUpdated",
    get: function get() {
      return 1 & this._updateState;
    }
  }, {
    key: "performUpdate",
    value: function performUpdate() {
      if (!this._hasRequestedUpdate) return;
      this._instanceProperties && this._applyInstanceProperties();
      var t = !1;
      var e = this._changedProperties;

      try {
        t = this.shouldUpdate(e), t ? this.update(e) : this._markUpdated();
      } catch (e) {
        throw t = !1, this._markUpdated(), e;
      }

      t && (1 & this._updateState || (this._updateState = 1 | this._updateState, this.firstUpdated(e)), this.updated(e));
    }
  }, {
    key: "_markUpdated",
    value: function _markUpdated() {
      this._changedProperties = new Map(), this._updateState = -5 & this._updateState;
    }
  }, {
    key: "updateComplete",
    get: function get() {
      return this._getUpdateComplete();
    }
  }, {
    key: "_getUpdateComplete",
    value: function _getUpdateComplete() {
      return this._updatePromise;
    }
  }, {
    key: "shouldUpdate",
    value: function shouldUpdate(t) {
      return !0;
    }
  }, {
    key: "update",
    value: function update(t) {
      var _this5 = this;

      void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach(function (t, e) {
        return _this5._propertyToAttribute(e, _this5[e], t);
      }), this._reflectingProperties = void 0), this._markUpdated();
    }
  }, {
    key: "updated",
    value: function updated(t) {}
  }, {
    key: "firstUpdated",
    value: function firstUpdated(t) {}
  }], [{
    key: "observedAttributes",
    get: function get() {
      var _this6 = this;

      this.finalize();
      var t = [];
      return this._classProperties.forEach(function (e, n) {
        var i = _this6._attributeNameForProperty(n, e);

        void 0 !== i && (_this6._attributeToPropertyMap.set(i, n), t.push(i));
      }), t;
    }
  }, {
    key: "_ensureClassProperties",
    value: function _ensureClassProperties() {
      var _this7 = this;

      if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
        this._classProperties = new Map();

        var _t5 = Object.getPrototypeOf(this)._classProperties;

        void 0 !== _t5 && _t5.forEach(function (t, e) {
          return _this7._classProperties.set(e, t);
        });
      }
    }
  }, {
    key: "createProperty",
    value: function createProperty(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : i;
      if (this._ensureClassProperties(), this._classProperties.set(t, e), e.noAccessor || this.prototype.hasOwnProperty(t)) return;

      var n = "symbol" == _typeof(t) ? Symbol() : "__".concat(t),
          _r2 = this.getPropertyDescriptor(t, n, e);

      void 0 !== _r2 && Object.defineProperty(this.prototype, t, _r2);
    }
  }, {
    key: "getPropertyDescriptor",
    value: function getPropertyDescriptor(t, e, n) {
      return {
        get: function get() {
          return this[e];
        },
        set: function set(i) {
          var r = this[t];
          this[e] = i, this.requestUpdateInternal(t, r, n);
        },
        configurable: !0,
        enumerable: !0
      };
    }
  }, {
    key: "getPropertyOptions",
    value: function getPropertyOptions(t) {
      return this._classProperties && this._classProperties.get(t) || i;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      var t = Object.getPrototypeOf(this);

      if (t.hasOwnProperty("finalized") || t.finalize(), this.finalized = !0, this._ensureClassProperties(), this._attributeToPropertyMap = new Map(), this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
        var _t6 = this.properties,
            _e3 = [].concat(_toConsumableArray(Object.getOwnPropertyNames(_t6)), _toConsumableArray("function" == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(_t6) : []));

        var _iterator = _createForOfIteratorHelper(_e3),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _n2 = _step.value;
            this.createProperty(_n2, _t6[_n2]);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
  }, {
    key: "_attributeNameForProperty",
    value: function _attributeNameForProperty(t, e) {
      var n = e.attribute;
      return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof t ? t.toLowerCase() : void 0;
    }
  }, {
    key: "_valueHasChanged",
    value: function _valueHasChanged(t, e) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : n;
      return i(t, e);
    }
  }, {
    key: "_propertyValueFromAttribute",
    value: function _propertyValueFromAttribute(t, n) {
      var i = n.type,
          _r3 = n.converter || e,
          s = "function" == typeof _r3 ? _r3 : _r3.fromAttribute;

      return s ? s(t, i) : t;
    }
  }, {
    key: "_propertyValueToAttribute",
    value: function _propertyValueToAttribute(t, n) {
      if (void 0 === n.reflect) return;
      var i = n.type,
          _r4 = n.converter;
      return (_r4 && _r4.toAttribute || e.toAttribute)(t, i);
    }
  }]);

  return r;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));

r.finalized = !0;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

var s = function s(t, e) {
  return "method" === e.kind && e.descriptor && !("value" in e.descriptor) ? Object.assign(Object.assign({}, e), {
    finisher: function finisher(n) {
      n.createProperty(e.key, t);
    }
  }) : {
    kind: "field",
    key: Symbol(),
    placement: "own",
    descriptor: {},
    initializer: function initializer() {
      "function" == typeof e.initializer && (this[e.key] = e.initializer.call(this));
    },
    finisher: function finisher(n) {
      n.createProperty(e.key, t);
    }
  };
};

function a(t) {
  return function (e, n) {
    return void 0 !== n ? function (t, e, n) {
      e.constructor.createProperty(n, t);
    }(t, e, n) : s(t, e);
  };
}
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/


window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && CSSStyleSheet.prototype,
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
(window.litElementVersions || (window.litElementVersions = [])).push("2.4.0");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var o = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported,
    l = o && self.XRSession.prototype.requestHitTestSource,
    c = null != self.ResizeObserver,
    h = null != self.IntersectionObserver,
    u = l;
(function () {
  var t = navigator.userAgent || navigator.vendor || self.opera;
  var e = !1;
  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0);
})(), /\bCrOS\b/.test(navigator.userAgent);

var d = /android/i.test(navigator.userAgent),
    A = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1,
    p = function () {
  var t = document.createElement("a");
  return Boolean(t.relList && t.relList.supports && t.relList.supports("ar"));
}();

/Safari\//.test(navigator.userAgent);
var g = /firefox/i.test(navigator.userAgent),
    m = /OculusBrowser/.test(navigator.userAgent);
A && /CriOS\//.test(navigator.userAgent);
var f = d && !g && !m;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var v = document.createElement("template");
v.innerHTML = '\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar.hide {\n  transition: opacity 0.3s 1s;\n  opacity: 0;\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class="container">\n  <div class="userInput" tabindex="0" role="img"\n      aria-label="A depiction of a 3D model"\n      aria-live="polite">\n      <div class="slot canvas">\n        <slot name="canvas">\n          <canvas></canvas>\n        </slot>\n      </div>\n  </div>\n\n  \x3c!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS --\x3e\n  <div class="slot poster">\n    <slot name="poster">\n      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>\n    </slot>\n  </div>\n\n  <div class="slot ar-button">\n    <slot name="ar-button">\n      <a id="default-ar-button" part="default-ar-button" class="fab"\n          tabindex="2"\n          aria-label="View this 3D model up close">\n        \n<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"\n\t xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"\n\t viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">\n<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>\n<g id="Art_layer">\n\t<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>\n\t<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>\n\t<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>\n\t<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>\n\t<g>\n\t\t<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>\n\t</g>\n</g>\n</svg>\n      </a>\n    </slot>\n  </div>\n\n  <div class="slot interaction-prompt">\n    <div class="animated-container">\n      <slot name="interaction-prompt" aria-hidden="true">\n        \n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z" />\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A" />\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />\n            </g>\n        </g>\n    </g>\n</svg>\n      </slot>\n    </div>\n  </div>\n\n  <div class="slot default">\n    <slot></slot>\n\n    <div class="slot progress-bar">\n      <slot name="progress-bar">\n        <div id="default-progress-bar" aria-hidden="true">\n          <div class="mask" part="default-progress-mask"></div>\n          <div class="bar" part="default-progress-bar"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class="slot exit-webxr-ar-button">\n      <slot name="exit-webxr-ar-button">\n        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"\n            tabindex="3"\n            aria-label="Exit AR"\n            aria-hidden="true">\n          \n<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">\n    \x3c!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components --\x3e\n    <defs>\n      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>\n        <feOffset dx="0" dy="0" result="offsetblur"/>\n        <feFlood flood-color="#000000"/>\n        <feComposite in2="offsetblur" operator="in"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>';

var y = /*#__PURE__*/function () {
  function y() {
    _classCallCheck(this, y);
  }

  _createClass(y, [{
    key: "addEventListener",
    value: function addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      var n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      var n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      var n = this._listeners[t];

      if (void 0 !== n) {
        var _t7 = n.indexOf(e);

        -1 !== _t7 && n.splice(_t7, 1);
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      var e = this._listeners[t.type];

      if (void 0 !== e) {
        t.target = this;

        var _n3 = e.slice(0);

        for (var _e4 = 0, _i2 = _n3.length; _e4 < _i2; _e4++) {
          _n3[_e4].call(this, t);
        }

        t.target = null;
      }
    }
  }]);

  return y;
}();

var E = [];

for (var _t8 = 0; _t8 < 256; _t8++) {
  E[_t8] = (_t8 < 16 ? "0" : "") + _t8.toString(16);
}

var x = 1234567;
var w = Math.PI / 180,
    b = 180 / Math.PI;

function _() {
  var t = 4294967295 * Math.random() | 0,
      e = 4294967295 * Math.random() | 0,
      n = 4294967295 * Math.random() | 0,
      i = 4294967295 * Math.random() | 0;
  return (E[255 & t] + E[t >> 8 & 255] + E[t >> 16 & 255] + E[t >> 24 & 255] + "-" + E[255 & e] + E[e >> 8 & 255] + "-" + E[e >> 16 & 15 | 64] + E[e >> 24 & 255] + "-" + E[63 & n | 128] + E[n >> 8 & 255] + "-" + E[n >> 16 & 255] + E[n >> 24 & 255] + E[255 & i] + E[i >> 8 & 255] + E[i >> 16 & 255] + E[i >> 24 & 255]).toUpperCase();
}

function I(t, e, n) {
  return Math.max(e, Math.min(n, t));
}

function C(t, e) {
  return (t % e + e) % e;
}

function M(t, e, n) {
  return (1 - n) * t + n * e;
}

function S(t) {
  return 0 == (t & t - 1) && 0 !== t;
}

function B(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
}

function T(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}

var L = Object.freeze({
  __proto__: null,
  DEG2RAD: w,
  RAD2DEG: b,
  generateUUID: _,
  clamp: I,
  euclideanModulo: C,
  mapLinear: function mapLinear(t, e, n, i, r) {
    return i + (t - e) * (r - i) / (n - e);
  },
  inverseLerp: function inverseLerp(t, e, n) {
    return t !== e ? (n - t) / (e - t) : 0;
  },
  lerp: M,
  damp: function damp(t, e, n, i) {
    return M(t, e, 1 - Math.exp(-n * i));
  },
  pingpong: function pingpong(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return e - Math.abs(C(t, 2 * e) - e);
  },
  smoothstep: function smoothstep(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
  },
  smootherstep: function smootherstep(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
  },
  randInt: function randInt(t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  randFloat: function randFloat(t, e) {
    return t + Math.random() * (e - t);
  },
  randFloatSpread: function randFloatSpread(t) {
    return t * (.5 - Math.random());
  },
  seededRandom: function seededRandom(t) {
    return void 0 !== t && (x = t % 2147483647), x = 16807 * x % 2147483647, (x - 1) / 2147483646;
  },
  degToRad: function degToRad(t) {
    return t * w;
  },
  radToDeg: function radToDeg(t) {
    return t * b;
  },
  isPowerOfTwo: S,
  ceilPowerOfTwo: B,
  floorPowerOfTwo: T,
  setQuaternionFromProperEuler: function setQuaternionFromProperEuler(t, e, n, i, r) {
    var s = Math.cos,
        a = Math.sin,
        o = s(n / 2),
        l = a(n / 2),
        c = s((e + i) / 2),
        h = a((e + i) / 2),
        u = s((e - i) / 2),
        d = a((e - i) / 2),
        A = s((i - e) / 2),
        p = a((i - e) / 2);

    switch (r) {
      case "XYX":
        t.set(o * h, l * u, l * d, o * c);
        break;

      case "YZY":
        t.set(l * d, o * h, l * u, o * c);
        break;

      case "ZXZ":
        t.set(l * u, l * d, o * h, o * c);
        break;

      case "XZX":
        t.set(o * h, l * p, l * A, o * c);
        break;

      case "YXY":
        t.set(l * A, o * h, l * p, o * c);
        break;

      case "ZYZ":
        t.set(l * p, l * A, o * h, o * c);
        break;

      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
    }
  }
});

var R = /*#__PURE__*/function () {
  function R() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, R);

    this.x = t, this.y = e;
  }

  _createClass(R, [{
    key: "width",
    get: function get() {
      return this.x;
    },
    set: function set(t) {
      this.x = t;
    }
  }, {
    key: "height",
    get: function get() {
      return this.y;
    },
    set: function set(t) {
      this.y = t;
    }
  }, {
    key: "set",
    value: function set(t, e) {
      return this.x = t, this.y = e, this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.x = t, this.y = t, this;
    }
  }, {
    key: "setX",
    value: function setX(t) {
      return this.x = t, this;
    }
  }, {
    key: "setY",
    value: function setY(t) {
      return this.y = t, this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;

        case 1:
          this.y = e;
          break;

        default:
          throw new Error("index is out of range: " + t);
      }

      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t) {
      switch (t) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        default:
          throw new Error("index is out of range: " + t);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.x = t.x, this.y = t.y, this;
    }
  }, {
    key: "add",
    value: function add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.x += t, this.y += t, this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    }
  }, {
    key: "sub",
    value: function sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
    }
  }, {
    key: "subScalar",
    value: function subScalar(t) {
      return this.x -= t, this.y -= t, this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.x *= t.x, this.y *= t.y, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.x *= t, this.y *= t, this;
    }
  }, {
    key: "divide",
    value: function divide(t) {
      return this.x /= t.x, this.y /= t.y, this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(t) {
      var e = this.x,
          n = this.y,
          i = t.elements;
      return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this;
    }
  }, {
    key: "min",
    value: function min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    }
  }, {
    key: "max",
    value: function max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    }
  }, {
    key: "clamp",
    value: function clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(t, e) {
      var n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
  }, {
    key: "floor",
    value: function floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
  }, {
    key: "round",
    value: function round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this.x * t.x + this.y * t.y;
    }
  }, {
    key: "cross",
    value: function cross(t) {
      return this.x * t.y - this.y * t.x;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "angle",
    value: function angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(t) {
      var e = this.x - t.x,
          n = this.y - t.y;
      return e * e + n * n;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
  }, {
    key: "setLength",
    value: function setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.x === this.x && t.y === this.y;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.x = t[e], this.y = t[e + 1], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.x, t[e + 1] = this.y, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this;
    }
  }, {
    key: "rotateAround",
    value: function rotateAround(t, e) {
      var n = Math.cos(e),
          i = Math.sin(e),
          r = this.x - t.x,
          s = this.y - t.y;
      return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this;
    }
  }, {
    key: "random",
    value: function random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
  }]);

  return R;
}();

R.prototype.isVector2 = !0;

var D = /*#__PURE__*/function () {
  function D() {
    _classCallCheck(this, D);

    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }

  _createClass(D, [{
    key: "set",
    value: function set(t, e, n, i, r, s, a, o, l) {
      var c = this.elements;
      return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = this.elements,
          n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(t, e, n) {
      return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }
  }, {
    key: "setFromMatrix4",
    value: function setFromMatrix4(t) {
      var e = t.elements;
      return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.multiplyMatrices(this, t);
    }
  }, {
    key: "premultiply",
    value: function premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(t, e) {
      var n = t.elements,
          i = e.elements,
          r = this.elements,
          s = n[0],
          a = n[3],
          o = n[6],
          l = n[1],
          c = n[4],
          h = n[7],
          u = n[2],
          d = n[5],
          A = n[8],
          p = i[0],
          g = i[3],
          m = i[6],
          f = i[1],
          v = i[4],
          y = i[7],
          E = i[2],
          x = i[5],
          w = i[8];
      return r[0] = s * p + a * f + o * E, r[3] = s * g + a * v + o * x, r[6] = s * m + a * y + o * w, r[1] = l * p + c * f + h * E, r[4] = l * g + c * v + h * x, r[7] = l * m + c * y + h * w, r[2] = u * p + d * f + A * E, r[5] = u * g + d * v + A * x, r[8] = u * m + d * y + A * w, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      var e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          a = t[5],
          o = t[6],
          l = t[7],
          c = t[8];
      return e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o;
    }
  }, {
    key: "invert",
    value: function invert() {
      var t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          a = t[5],
          o = t[6],
          l = t[7],
          c = t[8],
          h = c * s - a * l,
          u = a * o - c * r,
          d = l * r - s * o,
          A = e * h + n * u + i * d;
      if (0 === A) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      var p = 1 / A;
      return t[0] = h * p, t[1] = (i * l - c * n) * p, t[2] = (a * n - i * s) * p, t[3] = u * p, t[4] = (c * e - i * o) * p, t[5] = (i * r - a * e) * p, t[6] = d * p, t[7] = (n * o - l * e) * p, t[8] = (s * e - n * r) * p, this;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var t;
      var e = this.elements;
      return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
    }
  }, {
    key: "getNormalMatrix",
    value: function getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
  }, {
    key: "transposeIntoArray",
    value: function transposeIntoArray(t) {
      var e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    }
  }, {
    key: "setUvTransform",
    value: function setUvTransform(t, e, n, i, r, s, a) {
      var o = Math.cos(r),
          l = Math.sin(r);
      return this.set(n * o, n * l, -n * (o * s + l * a) + s + t, -i * l, i * o, -i * (-l * s + o * a) + a + e, 0, 0, 1), this;
    }
  }, {
    key: "scale",
    value: function scale(t, e) {
      var n = this.elements;
      return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this;
    }
  }, {
    key: "rotate",
    value: function rotate(t) {
      var e = Math.cos(t),
          n = Math.sin(t),
          i = this.elements,
          r = i[0],
          s = i[3],
          a = i[6],
          o = i[1],
          l = i[4],
          c = i[7];
      return i[0] = e * r + n * o, i[3] = e * s + n * l, i[6] = e * a + n * c, i[1] = -n * r + e * o, i[4] = -n * s + e * l, i[7] = -n * a + e * c, this;
    }
  }, {
    key: "translate",
    value: function translate(t, e) {
      var n = this.elements;
      return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      var e = this.elements,
          n = t.elements;

      for (var _t9 = 0; _t9 < 9; _t9++) {
        if (e[_t9] !== n[_t9]) return !1;
      }

      return !0;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var _n4 = 0; _n4 < 9; _n4++) {
        this.elements[_n4] = t[_n4 + e];
      }

      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }]);

  return D;
}();

var Q;
D.prototype.isMatrix3 = !0;

var P = /*#__PURE__*/function () {
  function P() {
    _classCallCheck(this, P);
  }

  _createClass(P, null, [{
    key: "getDataURL",
    value: function getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      var e;
      if (t instanceof HTMLCanvasElement) e = t;else {
        void 0 === Q && (Q = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Q.width = t.width, Q.height = t.height;

        var _n5 = Q.getContext("2d");

        t instanceof ImageData ? _n5.putImageData(t, 0, 0) : _n5.drawImage(t, 0, 0, t.width, t.height), e = Q;
      }
      return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png");
    }
  }]);

  return P;
}();

var F = 0;

var N = /*#__PURE__*/function (_y) {
  _inherits(N, _y);

  var _super2 = _createSuper(N);

  function N() {
    var _this8;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : N.DEFAULT_IMAGE;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : N.DEFAULT_MAPPING;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1001;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1001;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1006;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1008;
    var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1023;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1009;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
    var c = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 3e3;

    _classCallCheck(this, N);

    _this8 = _super2.call(this), Object.defineProperty(_assertThisInitialized(_this8), "id", {
      value: F++
    }), _this8.uuid = _(), _this8.name = "", _this8.image = t, _this8.mipmaps = [], _this8.mapping = e, _this8.wrapS = n, _this8.wrapT = i, _this8.magFilter = r, _this8.minFilter = s, _this8.anisotropy = l, _this8.format = a, _this8.internalFormat = null, _this8.type = o, _this8.offset = new R(0, 0), _this8.repeat = new R(1, 1), _this8.center = new R(0, 0), _this8.rotation = 0, _this8.matrixAutoUpdate = !0, _this8.matrix = new D(), _this8.generateMipmaps = !0, _this8.premultiplyAlpha = !1, _this8.flipY = !0, _this8.unpackAlignment = 4, _this8.encoding = c, _this8.version = 0, _this8.onUpdate = null;
    return _this8;
  }

  _createClass(N, [{
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      var n = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };

      if (void 0 !== this.image) {
        var _i3 = this.image;

        if (void 0 === _i3.uuid && (_i3.uuid = _()), !e && void 0 === t.images[_i3.uuid]) {
          var _e5;

          if (Array.isArray(_i3)) {
            _e5 = [];

            for (var _t10 = 0, _n6 = _i3.length; _t10 < _n6; _t10++) {
              _i3[_t10].isDataTexture ? _e5.push(U(_i3[_t10].image)) : _e5.push(U(_i3[_t10]));
            }
          } else _e5 = U(_i3);

          t.images[_i3.uuid] = {
            uuid: _i3.uuid,
            url: _e5
          };
        }

        n.image = _i3.uuid;
      }

      return e || (t.textures[this.uuid] = n), n;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }, {
    key: "transformUv",
    value: function transformUv(t) {
      if (300 !== this.mapping) return t;
      if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
        case 1e3:
          t.x = t.x - Math.floor(t.x);
          break;

        case 1001:
          t.x = t.x < 0 ? 0 : 1;
          break;

        case 1002:
          1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
      }
      if (t.y < 0 || t.y > 1) switch (this.wrapT) {
        case 1e3:
          t.y = t.y - Math.floor(t.y);
          break;

        case 1001:
          t.y = t.y < 0 ? 0 : 1;
          break;

        case 1002:
          1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
      }
      return this.flipY && (t.y = 1 - t.y), t;
    }
  }, {
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }]);

  return N;
}(y);

function U(t) {
  return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? P.getDataURL(t) : t.data ? {
    data: Array.prototype.slice.call(t.data),
    width: t.width,
    height: t.height,
    type: t.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}

N.DEFAULT_IMAGE = void 0, N.DEFAULT_MAPPING = 300, N.prototype.isTexture = !0;

var G = /*#__PURE__*/function () {
  function G() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, G);

    this.x = t, this.y = e, this.z = n, this.w = i;
  }

  _createClass(G, [{
    key: "width",
    get: function get() {
      return this.z;
    },
    set: function set(t) {
      this.z = t;
    }
  }, {
    key: "height",
    get: function get() {
      return this.w;
    },
    set: function set(t) {
      this.w = t;
    }
  }, {
    key: "set",
    value: function set(t, e, n, i) {
      return this.x = t, this.y = e, this.z = n, this.w = i, this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this.w = t, this;
    }
  }, {
    key: "setX",
    value: function setX(t) {
      return this.x = t, this;
    }
  }, {
    key: "setY",
    value: function setY(t) {
      return this.y = t, this;
    }
  }, {
    key: "setZ",
    value: function setZ(t) {
      return this.z = t, this;
    }
  }, {
    key: "setW",
    value: function setW(t) {
      return this.w = t, this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;

        case 1:
          this.y = e;
          break;

        case 2:
          this.z = e;
          break;

        case 3:
          this.w = e;
          break;

        default:
          throw new Error("index is out of range: " + t);
      }

      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t) {
      switch (t) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        case 2:
          return this.z;

        case 3:
          return this.w;

        default:
          throw new Error("index is out of range: " + t);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this;
    }
  }, {
    key: "add",
    value: function add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    }
  }, {
    key: "sub",
    value: function sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    }
  }, {
    key: "subScalar",
    value: function subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      var e = this.x,
          n = this.y,
          i = this.z,
          r = this.w,
          s = t.elements;
      return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
  }, {
    key: "setAxisAngleFromQuaternion",
    value: function setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      var e = Math.sqrt(1 - t.w * t.w);
      return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    }
  }, {
    key: "setAxisAngleFromRotationMatrix",
    value: function setAxisAngleFromRotationMatrix(t) {
      var e, n, i, r;
      var s = .01,
          a = .1,
          o = t.elements,
          l = o[0],
          c = o[4],
          h = o[8],
          u = o[1],
          d = o[5],
          A = o[9],
          p = o[2],
          g = o[6],
          m = o[10];

      if (Math.abs(c - u) < s && Math.abs(h - p) < s && Math.abs(A - g) < s) {
        if (Math.abs(c + u) < a && Math.abs(h + p) < a && Math.abs(A + g) < a && Math.abs(l + d + m - 3) < a) return this.set(1, 0, 0, 0), this;
        e = Math.PI;

        var _t11 = (l + 1) / 2,
            _o2 = (d + 1) / 2,
            _f = (m + 1) / 2,
            _v = (c + u) / 4,
            _y2 = (h + p) / 4,
            _E = (A + g) / 4;

        return _t11 > _o2 && _t11 > _f ? _t11 < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(_t11), i = _v / n, r = _y2 / n) : _o2 > _f ? _o2 < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(_o2), n = _v / i, r = _E / i) : _f < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(_f), n = _y2 / r, i = _E / r), this.set(n, i, r, e), this;
      }

      var f = Math.sqrt((g - A) * (g - A) + (h - p) * (h - p) + (u - c) * (u - c));
      return Math.abs(f) < .001 && (f = 1), this.x = (g - A) / f, this.y = (h - p) / f, this.z = (u - c) / f, this.w = Math.acos((l + d + m - 1) / 2), this;
    }
  }, {
    key: "min",
    value: function min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    }
  }, {
    key: "max",
    value: function max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    }
  }, {
    key: "clamp",
    value: function clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(t, e) {
      var n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
  }, {
    key: "floor",
    value: function floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
  }, {
    key: "round",
    value: function round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
  }, {
    key: "random",
    value: function random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
  }]);

  return G;
}();

G.prototype.isVector4 = !0;

var k = /*#__PURE__*/function (_y3) {
  _inherits(k, _y3);

  var _super3 = _createSuper(k);

  function k(t, e, n) {
    var _this9;

    _classCallCheck(this, k);

    _this9 = _super3.call(this), _this9.width = t, _this9.height = e, _this9.depth = 1, _this9.scissor = new G(0, 0, t, e), _this9.scissorTest = !1, _this9.viewport = new G(0, 0, t, e), n = n || {}, _this9.texture = new N(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), _this9.texture.image = {}, _this9.texture.image.width = t, _this9.texture.image.height = e, _this9.texture.image.depth = 1, _this9.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, _this9.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, _this9.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, _this9.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, _this9.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null;
    return _this9;
  }

  _createClass(k, [{
    key: "setTexture",
    value: function setTexture(t) {
      t.image = {
        width: this.width,
        height: this.height,
        depth: this.depth
      }, this.texture = t;
    }
  }, {
    key: "setSize",
    value: function setSize(t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }]);

  return k;
}(y);

k.prototype.isWebGLRenderTarget = !0;

var O = /*#__PURE__*/function () {
  function O() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, O);

    this._x = t, this._y = e, this._z = n, this._w = i;
  }

  _createClass(O, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(t) {
      this._x = t, this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(t) {
      this._y = t, this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(t) {
      this._z = t, this._onChangeCallback();
    }
  }, {
    key: "w",
    get: function get() {
      return this._w;
    },
    set: function set(t) {
      this._w = t, this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(t, e, n, i) {
      return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(t, e) {
      if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      var n = t._x,
          i = t._y,
          r = t._z,
          s = t._order,
          a = Math.cos,
          o = Math.sin,
          l = a(n / 2),
          c = a(i / 2),
          h = a(r / 2),
          u = o(n / 2),
          d = o(i / 2),
          A = o(r / 2);

      switch (s) {
        case "XYZ":
          this._x = u * c * h + l * d * A, this._y = l * d * h - u * c * A, this._z = l * c * A + u * d * h, this._w = l * c * h - u * d * A;
          break;

        case "YXZ":
          this._x = u * c * h + l * d * A, this._y = l * d * h - u * c * A, this._z = l * c * A - u * d * h, this._w = l * c * h + u * d * A;
          break;

        case "ZXY":
          this._x = u * c * h - l * d * A, this._y = l * d * h + u * c * A, this._z = l * c * A + u * d * h, this._w = l * c * h - u * d * A;
          break;

        case "ZYX":
          this._x = u * c * h - l * d * A, this._y = l * d * h + u * c * A, this._z = l * c * A - u * d * h, this._w = l * c * h + u * d * A;
          break;

        case "YZX":
          this._x = u * c * h + l * d * A, this._y = l * d * h + u * c * A, this._z = l * c * A - u * d * h, this._w = l * c * h - u * d * A;
          break;

        case "XZY":
          this._x = u * c * h - l * d * A, this._y = l * d * h - u * c * A, this._z = l * c * A + u * d * h, this._w = l * c * h + u * d * A;
          break;

        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s);
      }

      return !1 !== e && this._onChangeCallback(), this;
    }
  }, {
    key: "setFromAxisAngle",
    value: function setFromAxisAngle(t, e) {
      var n = e / 2,
          i = Math.sin(n);
      return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(t) {
      var e = t.elements,
          n = e[0],
          i = e[4],
          r = e[8],
          s = e[1],
          a = e[5],
          o = e[9],
          l = e[2],
          c = e[6],
          h = e[10],
          u = n + a + h;

      if (u > 0) {
        var _t12 = .5 / Math.sqrt(u + 1);

        this._w = .25 / _t12, this._x = (c - o) * _t12, this._y = (r - l) * _t12, this._z = (s - i) * _t12;
      } else if (n > a && n > h) {
        var _t13 = 2 * Math.sqrt(1 + n - a - h);

        this._w = (c - o) / _t13, this._x = .25 * _t13, this._y = (i + s) / _t13, this._z = (r + l) / _t13;
      } else if (a > h) {
        var _t14 = 2 * Math.sqrt(1 + a - n - h);

        this._w = (r - l) / _t14, this._x = (i + s) / _t14, this._y = .25 * _t14, this._z = (o + c) / _t14;
      } else {
        var _t15 = 2 * Math.sqrt(1 + h - n - a);

        this._w = (s - i) / _t15, this._x = (r + l) / _t15, this._y = (o + c) / _t15, this._z = .25 * _t15;
      }

      return this._onChangeCallback(), this;
    }
  }, {
    key: "setFromUnitVectors",
    value: function setFromUnitVectors(t, e) {
      var n = t.dot(e) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
    }
  }, {
    key: "angleTo",
    value: function angleTo(t) {
      return 2 * Math.acos(Math.abs(I(this.dot(t), -1, 1)));
    }
  }, {
    key: "rotateTowards",
    value: function rotateTowards(t, e) {
      var n = this.angleTo(t);
      if (0 === n) return this;
      var i = Math.min(1, e / n);
      return this.slerp(t, i), this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(0, 0, 0, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      return this.conjugate();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var t = this.length();
      return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
    }
  }, {
    key: "multiply",
    value: function multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
    }
  }, {
    key: "premultiply",
    value: function premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
  }, {
    key: "multiplyQuaternions",
    value: function multiplyQuaternions(t, e) {
      var n = t._x,
          i = t._y,
          r = t._z,
          s = t._w,
          a = e._x,
          o = e._y,
          l = e._z,
          c = e._w;
      return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this;
    }
  }, {
    key: "slerp",
    value: function slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      var n = this._x,
          i = this._y,
          r = this._z,
          s = this._w;
      var a = s * t._w + n * t._x + i * t._y + r * t._z;
      if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
      var o = 1 - a * a;

      if (o <= Number.EPSILON) {
        var _t16 = 1 - e;

        return this._w = _t16 * s + e * this._w, this._x = _t16 * n + e * this._x, this._y = _t16 * i + e * this._y, this._z = _t16 * r + e * this._z, this.normalize(), this._onChangeCallback(), this;
      }

      var l = Math.sqrt(o),
          c = Math.atan2(l, a),
          h = Math.sin((1 - e) * c) / l,
          u = Math.sin(e * c) / l;
      return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this;
    }
  }, {
    key: "slerpQuaternions",
    value: function slerpQuaternions(t, e, n) {
      this.copy(t).slerp(e, n);
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e) {
      return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
    }
  }, {
    key: "_onChange",
    value: function _onChange(t) {
      return this._onChangeCallback = t, this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }], [{
    key: "slerp",
    value: function slerp(t, e, n, i) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i);
    }
  }, {
    key: "slerpFlat",
    value: function slerpFlat(t, e, n, i, r, s, a) {
      var o = n[i + 0],
          l = n[i + 1],
          c = n[i + 2],
          h = n[i + 3];
      var u = r[s + 0],
          d = r[s + 1],
          A = r[s + 2],
          p = r[s + 3];
      if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = h);
      if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = A, void (t[e + 3] = p);

      if (h !== p || o !== u || l !== d || c !== A) {
        var _t17 = 1 - a;

        var _e6 = o * u + l * d + c * A + h * p,
            _n7 = _e6 >= 0 ? 1 : -1,
            _i4 = 1 - _e6 * _e6;

        if (_i4 > Number.EPSILON) {
          var _r9 = Math.sqrt(_i4),
              _s2 = Math.atan2(_r9, _e6 * _n7);

          _t17 = Math.sin(_t17 * _s2) / _r9, a = Math.sin(a * _s2) / _r9;
        }

        var _r8 = a * _n7;

        if (o = o * _t17 + u * _r8, l = l * _t17 + d * _r8, c = c * _t17 + A * _r8, h = h * _t17 + p * _r8, _t17 === 1 - a) {
          var _t18 = 1 / Math.sqrt(o * o + l * l + c * c + h * h);

          o *= _t18, l *= _t18, c *= _t18, h *= _t18;
        }
      }

      t[e] = o, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h;
    }
  }, {
    key: "multiplyQuaternionsFlat",
    value: function multiplyQuaternionsFlat(t, e, n, i, r, s) {
      var a = n[i],
          o = n[i + 1],
          l = n[i + 2],
          c = n[i + 3],
          h = r[s],
          u = r[s + 1],
          d = r[s + 2],
          A = r[s + 3];
      return t[e] = a * A + c * h + o * d - l * u, t[e + 1] = o * A + c * u + l * h - a * d, t[e + 2] = l * A + c * d + a * u - o * h, t[e + 3] = c * A - a * h - o * u - l * d, t;
    }
  }]);

  return O;
}();

O.prototype.isQuaternion = !0;

var H = /*#__PURE__*/function () {
  function H() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, H);

    this.x = t, this.y = e, this.z = n;
  }

  _createClass(H, [{
    key: "set",
    value: function set(t, e, n) {
      return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this;
    }
  }, {
    key: "setX",
    value: function setX(t) {
      return this.x = t, this;
    }
  }, {
    key: "setY",
    value: function setY(t) {
      return this.y = t, this;
    }
  }, {
    key: "setZ",
    value: function setZ(t) {
      return this.z = t, this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;

        case 1:
          this.y = e;
          break;

        case 2:
          this.z = e;
          break;

        default:
          throw new Error("index is out of range: " + t);
      }

      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t) {
      switch (t) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        case 2:
          return this.z;

        default:
          throw new Error("index is out of range: " + t);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    }
  }, {
    key: "add",
    value: function add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    }
  }, {
    key: "sub",
    value: function sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    }
  }, {
    key: "subScalar",
    value: function subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    }
  }, {
    key: "applyEuler",
    value: function applyEuler(t) {
      return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(V.setFromEuler(t));
    }
  }, {
    key: "applyAxisAngle",
    value: function applyAxisAngle(t, e) {
      return this.applyQuaternion(V.setFromAxisAngle(t, e));
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(t) {
      var e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
      return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      var e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements,
          s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
      return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(t) {
      var e = this.x,
          n = this.y,
          i = this.z,
          r = t.x,
          s = t.y,
          a = t.z,
          o = t.w,
          l = o * e + s * i - a * n,
          c = o * n + a * e - r * i,
          h = o * i + r * n - s * e,
          u = -r * e - s * n - a * i;
      return this.x = l * o + u * -r + c * -a - h * -s, this.y = c * o + u * -s + h * -r - l * -a, this.z = h * o + u * -a + l * -s - c * -r, this;
    }
  }, {
    key: "project",
    value: function project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
    }
  }, {
    key: "unproject",
    value: function unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(t) {
      var e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
      return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize();
    }
  }, {
    key: "divide",
    value: function divide(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
  }, {
    key: "min",
    value: function min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    }
  }, {
    key: "max",
    value: function max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    }
  }, {
    key: "clamp",
    value: function clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(t, e) {
      var n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
  }, {
    key: "floor",
    value: function floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
  }, {
    key: "round",
    value: function round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
    }
  }, {
    key: "cross",
    value: function cross(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
    }
  }, {
    key: "crossVectors",
    value: function crossVectors(t, e) {
      var n = t.x,
          i = t.y,
          r = t.z,
          s = e.x,
          a = e.y,
          o = e.z;
      return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this;
    }
  }, {
    key: "projectOnVector",
    value: function projectOnVector(t) {
      var e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      var n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
  }, {
    key: "projectOnPlane",
    value: function projectOnPlane(t) {
      return z.copy(this).projectOnVector(t), this.sub(z);
    }
  }, {
    key: "reflect",
    value: function reflect(t) {
      return this.sub(z.copy(t).multiplyScalar(2 * this.dot(t)));
    }
  }, {
    key: "angleTo",
    value: function angleTo(t) {
      var e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      var n = this.dot(t) / e;
      return Math.acos(I(n, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(t) {
      var e = this.x - t.x,
          n = this.y - t.y,
          i = this.z - t.z;
      return e * e + n * n + i * i;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    }
  }, {
    key: "setFromSpherical",
    value: function setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
  }, {
    key: "setFromSphericalCoords",
    value: function setFromSphericalCoords(t, e, n) {
      var i = Math.sin(e) * t;
      return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this;
    }
  }, {
    key: "setFromCylindrical",
    value: function setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
  }, {
    key: "setFromCylindricalCoords",
    value: function setFromCylindricalCoords(t, e, n) {
      return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
    }
  }, {
    key: "setFromMatrixPosition",
    value: function setFromMatrixPosition(t) {
      var e = t.elements;
      return this.x = e[12], this.y = e[13], this.z = e[14], this;
    }
  }, {
    key: "setFromMatrixScale",
    value: function setFromMatrixScale(t) {
      var e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          i = this.setFromMatrixColumn(t, 2).length();
      return this.x = e, this.y = n, this.z = i, this;
    }
  }, {
    key: "setFromMatrixColumn",
    value: function setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e);
    }
  }, {
    key: "setFromMatrix3Column",
    value: function setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e);
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
  }, {
    key: "random",
    value: function random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
  }]);

  return H;
}();

H.prototype.isVector3 = !0;
var z = new H(),
    V = new O();

var W = /*#__PURE__*/function () {
  function W() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new H(1 / 0, 1 / 0, 1 / 0);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new H(-1 / 0, -1 / 0, -1 / 0);

    _classCallCheck(this, W);

    this.min = t, this.max = e;
  }

  _createClass(W, [{
    key: "set",
    value: function set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
  }, {
    key: "setFromArray",
    value: function setFromArray(t) {
      var e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          a = -1 / 0;

      for (var _o3 = 0, _l2 = t.length; _o3 < _l2; _o3 += 3) {
        var _l3 = t[_o3],
            _c2 = t[_o3 + 1],
            _h2 = t[_o3 + 2];
        _l3 < e && (e = _l3), _c2 < n && (n = _c2), _h2 < i && (i = _h2), _l3 > r && (r = _l3), _c2 > s && (s = _c2), _h2 > a && (a = _h2);
      }

      return this.min.set(e, n, i), this.max.set(r, s, a), this;
    }
  }, {
    key: "setFromBufferAttribute",
    value: function setFromBufferAttribute(t) {
      var e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          a = -1 / 0;

      for (var _o4 = 0, _l4 = t.count; _o4 < _l4; _o4++) {
        var _l5 = t.getX(_o4),
            _c3 = t.getY(_o4),
            _h3 = t.getZ(_o4);

        _l5 < e && (e = _l5), _c3 < n && (n = _c3), _h3 < i && (i = _h3), _l5 > r && (r = _l5), _c3 > s && (s = _c3), _h3 > a && (a = _h3);
      }

      return this.min.set(e, n, i), this.max.set(r, s, a), this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(t) {
      this.makeEmpty();

      for (var _e7 = 0, _n8 = t.length; _e7 < _n8; _e7++) {
        this.expandByPoint(t[_e7]);
      }

      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(t, e) {
      var n = j.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(t) {
      return this.makeEmpty(), this.expandByObject(t);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
  }, {
    key: "getCenter",
    value: function getCenter(t) {
      return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new H()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
    }
  }, {
    key: "getSize",
    value: function getSize(t) {
      return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new H()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
  }, {
    key: "expandByObject",
    value: function expandByObject(t) {
      t.updateWorldMatrix(!1, !1);
      var e = t.geometry;
      void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Y.copy(e.boundingBox), Y.applyMatrix4(t.matrixWorld), this.union(Y));
      var n = t.children;

      for (var _t19 = 0, _e8 = n.length; _t19 < _e8; _t19++) {
        this.expandByObject(n[_t19]);
      }

      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    }
  }, {
    key: "containsBox",
    value: function containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    }
  }, {
    key: "getParameter",
    value: function getParameter(t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new H()), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      return this.clampPoint(t.center, j), j.distanceToSquared(t.center) <= t.radius * t.radius;
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(t) {
      var e, n;
      return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
    }
  }, {
    key: "intersectsTriangle",
    value: function intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(et), nt.subVectors(this.max, et), J.subVectors(t.a, et), X.subVectors(t.b, et), K.subVectors(t.c, et), Z.subVectors(X, J), $.subVectors(K, X), tt.subVectors(J, K);
      var e = [0, -Z.z, Z.y, 0, -$.z, $.y, 0, -tt.z, tt.y, Z.z, 0, -Z.x, $.z, 0, -$.x, tt.z, 0, -tt.x, -Z.y, Z.x, 0, -$.y, $.x, 0, -tt.y, tt.x, 0];
      return !!st(e, J, X, K, nt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!st(e, J, X, K, nt) && (it.crossVectors(Z, $), e = [it.x, it.y, it.z], st(e, J, X, K, nt)));
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new H()), e.copy(t).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return j.copy(t).clamp(this.min, this.max).sub(t).length();
    }
  }, {
    key: "getBoundingSphere",
    value: function getBoundingSphere(t) {
      return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(j).length(), t;
    }
  }, {
    key: "intersect",
    value: function intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    }
  }, {
    key: "union",
    value: function union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      return this.isEmpty() || (q[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), q[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), q[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), q[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), q[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), q[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), q[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), q[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(q)), this;
    }
  }, {
    key: "translate",
    value: function translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }]);

  return W;
}();

W.prototype.isBox3 = !0;
var q = [new H(), new H(), new H(), new H(), new H(), new H(), new H(), new H()],
    j = new H(),
    Y = new W(),
    J = new H(),
    X = new H(),
    K = new H(),
    Z = new H(),
    $ = new H(),
    tt = new H(),
    et = new H(),
    nt = new H(),
    it = new H(),
    rt = new H();

function st(t, e, n, i, r) {
  for (var _s3 = 0, _a2 = t.length - 3; _s3 <= _a2; _s3 += 3) {
    rt.fromArray(t, _s3);

    var _a3 = r.x * Math.abs(rt.x) + r.y * Math.abs(rt.y) + r.z * Math.abs(rt.z),
        _o5 = e.dot(rt),
        _l6 = n.dot(rt),
        _c4 = i.dot(rt);

    if (Math.max(-Math.max(_o5, _l6, _c4), Math.min(_o5, _l6, _c4)) > _a3) return !1;
  }

  return !0;
}

var at = new W(),
    ot = new H(),
    lt = new H(),
    ct = new H();

var ht = /*#__PURE__*/function () {
  function ht() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new H();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

    _classCallCheck(this, ht);

    this.center = t, this.radius = e;
  }

  _createClass(ht, [{
    key: "set",
    value: function set(t, e) {
      return this.center.copy(t), this.radius = e, this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(t, e) {
      var n = this.center;
      void 0 !== e ? n.copy(e) : at.setFromPoints(t).getCenter(n);
      var i = 0;

      for (var _e9 = 0, _r10 = t.length; _e9 < _r10; _e9++) {
        i = Math.max(i, n.distanceToSquared(t[_e9]));
      }

      return this.radius = Math.sqrt(i), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.radius < 0;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return t.intersectsSphere(this);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(t, e) {
      var n = this.center.distanceToSquared(t);
      return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new H()), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(t) {
      return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new W()), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
    }
  }, {
    key: "translate",
    value: function translate(t) {
      return this.center.add(t), this;
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(t) {
      ct.subVectors(t, this.center);
      var e = ct.lengthSq();

      if (e > this.radius * this.radius) {
        var _t20 = Math.sqrt(e),
            _n9 = .5 * (_t20 - this.radius);

        this.center.add(ct.multiplyScalar(_n9 / _t20)), this.radius += _n9;
      }

      return this;
    }
  }, {
    key: "union",
    value: function union(t) {
      return lt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(ot.copy(t.center).add(lt)), this.expandByPoint(ot.copy(t.center).sub(lt)), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return ht;
}();

var ut = new H(),
    dt = new H(),
    At = new H(),
    pt = new H(),
    gt = new H(),
    mt = new H(),
    ft = new H();

var vt = /*#__PURE__*/function () {
  function vt() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new H();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new H(0, 0, -1);

    _classCallCheck(this, vt);

    this.origin = t, this.direction = e;
  }

  _createClass(vt, [{
    key: "set",
    value: function set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
  }, {
    key: "at",
    value: function at(t, e) {
      return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new H()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
  }, {
    key: "lookAt",
    value: function lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
  }, {
    key: "recast",
    value: function recast(t) {
      return this.origin.copy(this.at(t, ut)), this;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(t, e) {
      void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new H()), e.subVectors(t, this.origin);
      var n = e.dot(this.direction);
      return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
  }, {
    key: "distanceSqToPoint",
    value: function distanceSqToPoint(t) {
      var e = ut.subVectors(t, this.origin).dot(this.direction);
      return e < 0 ? this.origin.distanceToSquared(t) : (ut.copy(this.direction).multiplyScalar(e).add(this.origin), ut.distanceToSquared(t));
    }
  }, {
    key: "distanceSqToSegment",
    value: function distanceSqToSegment(t, e, n, i) {
      dt.copy(t).add(e).multiplyScalar(.5), At.copy(e).sub(t).normalize(), pt.copy(this.origin).sub(dt);
      var r = .5 * t.distanceTo(e),
          s = -this.direction.dot(At),
          a = pt.dot(this.direction),
          o = -pt.dot(At),
          l = pt.lengthSq(),
          c = Math.abs(1 - s * s);
      var h, u, d, A;
      if (c > 0) {
        if (h = s * o - a, u = s * a - o, A = r * c, h >= 0) {
          if (u >= -A) {
            if (u <= A) {
              var _t21 = 1 / c;

              h *= _t21, u *= _t21, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l;
            } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
          } else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
        } else u <= -A ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= A ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
      } else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
      return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(At).multiplyScalar(u).add(dt), d;
    }
  }, {
    key: "intersectSphere",
    value: function intersectSphere(t, e) {
      ut.subVectors(t.center, this.origin);
      var n = ut.dot(this.direction),
          i = ut.dot(ut) - n * n,
          r = t.radius * t.radius;
      if (i > r) return null;
      var s = Math.sqrt(r - i),
          a = n - s,
          o = n + s;
      return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
  }, {
    key: "distanceToPlane",
    value: function distanceToPlane(t) {
      var e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      var n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(t, e) {
      var n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(t) {
      var e = t.distanceToPoint(this.origin);
      if (0 === e) return !0;
      return t.normal.dot(this.direction) * e < 0;
    }
  }, {
    key: "intersectBox",
    value: function intersectBox(t, e) {
      var n, i, r, s, a, o;
      var l = 1 / this.direction.x,
          c = 1 / this.direction.y,
          h = 1 / this.direction.z,
          u = this.origin;
      return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (a = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return null !== this.intersectBox(t, ut);
    }
  }, {
    key: "intersectTriangle",
    value: function intersectTriangle(t, e, n, i, r) {
      gt.subVectors(e, t), mt.subVectors(n, t), ft.crossVectors(gt, mt);
      var s,
          a = this.direction.dot(ft);

      if (a > 0) {
        if (i) return null;
        s = 1;
      } else {
        if (!(a < 0)) return null;
        s = -1, a = -a;
      }

      pt.subVectors(this.origin, t);
      var o = s * this.direction.dot(mt.crossVectors(pt, mt));
      if (o < 0) return null;
      var l = s * this.direction.dot(gt.cross(pt));
      if (l < 0) return null;
      if (o + l > a) return null;
      var c = -s * pt.dot(ft);
      return c < 0 ? null : this.at(c / a, r);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return vt;
}();

var yt = /*#__PURE__*/function () {
  function yt() {
    _classCallCheck(this, yt);

    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }

  _createClass(yt, [{
    key: "set",
    value: function set(t, e, n, i, r, s, a, o, l, c, h, u, d, A, p, g) {
      var m = this.elements;
      return m[0] = t, m[4] = e, m[8] = n, m[12] = i, m[1] = r, m[5] = s, m[9] = a, m[13] = o, m[2] = l, m[6] = c, m[10] = h, m[14] = u, m[3] = d, m[7] = A, m[11] = p, m[15] = g, this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new yt().fromArray(this.elements);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = this.elements,
          n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
    }
  }, {
    key: "copyPosition",
    value: function copyPosition(t) {
      var e = this.elements,
          n = t.elements;
      return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
    }
  }, {
    key: "setFromMatrix3",
    value: function setFromMatrix3(t) {
      var e = t.elements;
      return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(t, e, n) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }
  }, {
    key: "makeBasis",
    value: function makeBasis(t, e, n) {
      return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "extractRotation",
    value: function extractRotation(t) {
      var e = this.elements,
          n = t.elements,
          i = 1 / Et.setFromMatrixColumn(t, 0).length(),
          r = 1 / Et.setFromMatrixColumn(t, 1).length(),
          s = 1 / Et.setFromMatrixColumn(t, 2).length();
      return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
  }, {
    key: "makeRotationFromEuler",
    value: function makeRotationFromEuler(t) {
      t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      var e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z,
          s = Math.cos(n),
          a = Math.sin(n),
          o = Math.cos(i),
          l = Math.sin(i),
          c = Math.cos(r),
          h = Math.sin(r);

      if ("XYZ" === t.order) {
        var _t22 = s * c,
            _n10 = s * h,
            _i5 = a * c,
            _r11 = a * h;

        e[0] = o * c, e[4] = -o * h, e[8] = l, e[1] = _n10 + _i5 * l, e[5] = _t22 - _r11 * l, e[9] = -a * o, e[2] = _r11 - _t22 * l, e[6] = _i5 + _n10 * l, e[10] = s * o;
      } else if ("YXZ" === t.order) {
        var _t23 = o * c,
            _n11 = o * h,
            _i6 = l * c,
            _r12 = l * h;

        e[0] = _t23 + _r12 * a, e[4] = _i6 * a - _n11, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -a, e[2] = _n11 * a - _i6, e[6] = _r12 + _t23 * a, e[10] = s * o;
      } else if ("ZXY" === t.order) {
        var _t24 = o * c,
            _n12 = o * h,
            _i7 = l * c,
            _r13 = l * h;

        e[0] = _t24 - _r13 * a, e[4] = -s * h, e[8] = _i7 + _n12 * a, e[1] = _n12 + _i7 * a, e[5] = s * c, e[9] = _r13 - _t24 * a, e[2] = -s * l, e[6] = a, e[10] = s * o;
      } else if ("ZYX" === t.order) {
        var _t25 = s * c,
            _n13 = s * h,
            _i8 = a * c,
            _r14 = a * h;

        e[0] = o * c, e[4] = _i8 * l - _n13, e[8] = _t25 * l + _r14, e[1] = o * h, e[5] = _r14 * l + _t25, e[9] = _n13 * l - _i8, e[2] = -l, e[6] = a * o, e[10] = s * o;
      } else if ("YZX" === t.order) {
        var _t26 = s * o,
            _n14 = s * l,
            _i9 = a * o,
            _r15 = a * l;

        e[0] = o * c, e[4] = _r15 - _t26 * h, e[8] = _i9 * h + _n14, e[1] = h, e[5] = s * c, e[9] = -a * c, e[2] = -l * c, e[6] = _n14 * h + _i9, e[10] = _t26 - _r15 * h;
      } else if ("XZY" === t.order) {
        var _t27 = s * o,
            _n15 = s * l,
            _i10 = a * o,
            _r16 = a * l;

        e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = _t27 * h + _r16, e[5] = s * c, e[9] = _n15 * h - _i10, e[2] = _i10 * h - _n15, e[6] = a * c, e[10] = _r16 * h + _t27;
      }

      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
  }, {
    key: "makeRotationFromQuaternion",
    value: function makeRotationFromQuaternion(t) {
      return this.compose(wt, t, bt);
    }
  }, {
    key: "lookAt",
    value: function lookAt(t, e, n) {
      var i = this.elements;
      return Ct.subVectors(t, e), 0 === Ct.lengthSq() && (Ct.z = 1), Ct.normalize(), _t.crossVectors(n, Ct), 0 === _t.lengthSq() && (1 === Math.abs(n.z) ? Ct.x += 1e-4 : Ct.z += 1e-4, Ct.normalize(), _t.crossVectors(n, Ct)), _t.normalize(), It.crossVectors(Ct, _t), i[0] = _t.x, i[4] = It.x, i[8] = Ct.x, i[1] = _t.y, i[5] = It.y, i[9] = Ct.y, i[2] = _t.z, i[6] = It.z, i[10] = Ct.z, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
    }
  }, {
    key: "premultiply",
    value: function premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(t, e) {
      var n = t.elements,
          i = e.elements,
          r = this.elements,
          s = n[0],
          a = n[4],
          o = n[8],
          l = n[12],
          c = n[1],
          h = n[5],
          u = n[9],
          d = n[13],
          A = n[2],
          p = n[6],
          g = n[10],
          m = n[14],
          f = n[3],
          v = n[7],
          y = n[11],
          E = n[15],
          x = i[0],
          w = i[4],
          b = i[8],
          _ = i[12],
          I = i[1],
          C = i[5],
          M = i[9],
          S = i[13],
          B = i[2],
          T = i[6],
          L = i[10],
          R = i[14],
          D = i[3],
          Q = i[7],
          P = i[11],
          F = i[15];
      return r[0] = s * x + a * I + o * B + l * D, r[4] = s * w + a * C + o * T + l * Q, r[8] = s * b + a * M + o * L + l * P, r[12] = s * _ + a * S + o * R + l * F, r[1] = c * x + h * I + u * B + d * D, r[5] = c * w + h * C + u * T + d * Q, r[9] = c * b + h * M + u * L + d * P, r[13] = c * _ + h * S + u * R + d * F, r[2] = A * x + p * I + g * B + m * D, r[6] = A * w + p * C + g * T + m * Q, r[10] = A * b + p * M + g * L + m * P, r[14] = A * _ + p * S + g * R + m * F, r[3] = f * x + v * I + y * B + E * D, r[7] = f * w + v * C + y * T + E * Q, r[11] = f * b + v * M + y * L + E * P, r[15] = f * _ + v * S + y * R + E * F, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      var e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var t = this.elements,
          e = t[0],
          n = t[4],
          i = t[8],
          r = t[12],
          s = t[1],
          a = t[5],
          o = t[9],
          l = t[13],
          c = t[2],
          h = t[6],
          u = t[10],
          d = t[14];
      return t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c);
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var t = this.elements;
      var e;
      return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    }
  }, {
    key: "setPosition",
    value: function setPosition(t, e, n) {
      var i = this.elements;
      return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this;
    }
  }, {
    key: "invert",
    value: function invert() {
      var t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          a = t[5],
          o = t[6],
          l = t[7],
          c = t[8],
          h = t[9],
          u = t[10],
          d = t[11],
          A = t[12],
          p = t[13],
          g = t[14],
          m = t[15],
          f = h * g * l - p * u * l + p * o * d - a * g * d - h * o * m + a * u * m,
          v = A * u * l - c * g * l - A * o * d + s * g * d + c * o * m - s * u * m,
          y = c * p * l - A * h * l + A * a * d - s * p * d - c * a * m + s * h * m,
          E = A * h * o - c * p * o - A * a * u + s * p * u + c * a * g - s * h * g,
          x = e * f + n * v + i * y + r * E;
      if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      var w = 1 / x;
      return t[0] = f * w, t[1] = (p * u * r - h * g * r - p * i * d + n * g * d + h * i * m - n * u * m) * w, t[2] = (a * g * r - p * o * r + p * i * l - n * g * l - a * i * m + n * o * m) * w, t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * w, t[4] = v * w, t[5] = (c * g * r - A * u * r + A * i * d - e * g * d - c * i * m + e * u * m) * w, t[6] = (A * o * r - s * g * r - A * i * l + e * g * l + s * i * m - e * o * m) * w, t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * w, t[8] = y * w, t[9] = (A * h * r - c * p * r - A * n * d + e * p * d + c * n * m - e * h * m) * w, t[10] = (s * p * r - A * a * r + A * n * l - e * p * l - s * n * m + e * a * m) * w, t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * w, t[12] = E * w, t[13] = (c * p * i - A * h * i + A * n * u - e * p * u - c * n * g + e * h * g) * w, t[14] = (A * a * i - s * p * i - A * n * o + e * p * o + s * n * g - e * a * g) * w, t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * w, this;
    }
  }, {
    key: "scale",
    value: function scale(t) {
      var e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z;
      return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this;
    }
  }, {
    key: "getMaxScaleOnAxis",
    value: function getMaxScaleOnAxis() {
      var t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(t, e, n) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(t) {
      var e = Math.cos(t),
          n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationY",
    value: function makeRotationY(t) {
      var e = Math.cos(t),
          n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationZ",
    value: function makeRotationZ(t) {
      var e = Math.cos(t),
          n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationAxis",
    value: function makeRotationAxis(t, e) {
      var n = Math.cos(e),
          i = Math.sin(e),
          r = 1 - n,
          s = t.x,
          a = t.y,
          o = t.z,
          l = r * s,
          c = r * a;
      return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeShear",
    value: function makeShear(t, e, n) {
      return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "compose",
    value: function compose(t, e, n) {
      var i = this.elements,
          r = e._x,
          s = e._y,
          a = e._z,
          o = e._w,
          l = r + r,
          c = s + s,
          h = a + a,
          u = r * l,
          d = r * c,
          A = r * h,
          p = s * c,
          g = s * h,
          m = a * h,
          f = o * l,
          v = o * c,
          y = o * h,
          E = n.x,
          x = n.y,
          w = n.z;
      return i[0] = (1 - (p + m)) * E, i[1] = (d + y) * E, i[2] = (A - v) * E, i[3] = 0, i[4] = (d - y) * x, i[5] = (1 - (u + m)) * x, i[6] = (g + f) * x, i[7] = 0, i[8] = (A + v) * w, i[9] = (g - f) * w, i[10] = (1 - (u + p)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
    }
  }, {
    key: "decompose",
    value: function decompose(t, e, n) {
      var i = this.elements;
      var r = Et.set(i[0], i[1], i[2]).length();
      var s = Et.set(i[4], i[5], i[6]).length(),
          a = Et.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], xt.copy(this);
      var o = 1 / r,
          l = 1 / s,
          c = 1 / a;
      return xt.elements[0] *= o, xt.elements[1] *= o, xt.elements[2] *= o, xt.elements[4] *= l, xt.elements[5] *= l, xt.elements[6] *= l, xt.elements[8] *= c, xt.elements[9] *= c, xt.elements[10] *= c, e.setFromRotationMatrix(xt), n.x = r, n.y = s, n.z = a, this;
    }
  }, {
    key: "makePerspective",
    value: function makePerspective(t, e, n, i, r, s) {
      void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      var a = this.elements,
          o = 2 * r / (e - t),
          l = 2 * r / (n - i),
          c = (e + t) / (e - t),
          h = (n + i) / (n - i),
          u = -(s + r) / (s - r),
          d = -2 * s * r / (s - r);
      return a[0] = o, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
    }
  }, {
    key: "makeOrthographic",
    value: function makeOrthographic(t, e, n, i, r, s) {
      var a = this.elements,
          o = 1 / (e - t),
          l = 1 / (n - i),
          c = 1 / (s - r),
          h = (e + t) * o,
          u = (n + i) * l,
          d = (s + r) * c;
      return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      var e = this.elements,
          n = t.elements;

      for (var _t28 = 0; _t28 < 16; _t28++) {
        if (e[_t28] !== n[_t28]) return !1;
      }

      return !0;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var _n16 = 0; _n16 < 16; _n16++) {
        this.elements[_n16] = t[_n16 + e];
      }

      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
    }
  }]);

  return yt;
}();

yt.prototype.isMatrix4 = !0;

var Et = new H(),
    xt = new yt(),
    wt = new H(0, 0, 0),
    bt = new H(1, 1, 1),
    _t = new H(),
    It = new H(),
    Ct = new H(),
    Mt = new yt(),
    St = new O();

var Bt = /*#__PURE__*/function () {
  function Bt() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Bt.DefaultOrder;

    _classCallCheck(this, Bt);

    this._x = t, this._y = e, this._z = n, this._order = i;
  }

  _createClass(Bt, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(t) {
      this._x = t, this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(t) {
      this._y = t, this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(t) {
      this._z = t, this._onChangeCallback();
    }
  }, {
    key: "order",
    get: function get() {
      return this._order;
    },
    set: function set(t) {
      this._order = t, this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(t, e, n, i) {
      return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(t, e, n) {
      var i = t.elements,
          r = i[0],
          s = i[4],
          a = i[8],
          o = i[1],
          l = i[5],
          c = i[9],
          h = i[2],
          u = i[6],
          d = i[10];

      switch (e = e || this._order) {
        case "XYZ":
          this._y = Math.asin(I(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
          break;

        case "YXZ":
          this._x = Math.asin(-I(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
          break;

        case "ZXY":
          this._x = Math.asin(I(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
          break;

        case "ZYX":
          this._y = Math.asin(-I(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
          break;

        case "YZX":
          this._z = Math.asin(I(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
          break;

        case "XZY":
          this._z = Math.asin(-I(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
          break;

        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
      }

      return this._order = e, !1 !== n && this._onChangeCallback(), this;
    }
  }, {
    key: "setFromQuaternion",
    value: function setFromQuaternion(t, e, n) {
      return Mt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Mt, e, n);
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(t, e) {
      return this.set(t.x, t.y, t.z, e || this._order);
    }
  }, {
    key: "reorder",
    value: function reorder(t) {
      return St.setFromEuler(this), this.setFromQuaternion(St, t);
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    }
  }, {
    key: "toVector3",
    value: function toVector3(t) {
      return t ? t.set(this._x, this._y, this._z) : new H(this._x, this._y, this._z);
    }
  }, {
    key: "_onChange",
    value: function _onChange(t) {
      return this._onChangeCallback = t, this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }]);

  return Bt;
}();

Bt.prototype.isEuler = !0, Bt.DefaultOrder = "XYZ", Bt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];

var Tt = /*#__PURE__*/function () {
  function Tt() {
    _classCallCheck(this, Tt);

    this.mask = 1;
  }

  _createClass(Tt, [{
    key: "set",
    value: function set(t) {
      this.mask = 1 << t | 0;
    }
  }, {
    key: "enable",
    value: function enable(t) {
      this.mask |= 1 << t | 0;
    }
  }, {
    key: "enableAll",
    value: function enableAll() {
      this.mask = -1;
    }
  }, {
    key: "toggle",
    value: function toggle(t) {
      this.mask ^= 1 << t | 0;
    }
  }, {
    key: "disable",
    value: function disable(t) {
      this.mask &= ~(1 << t | 0);
    }
  }, {
    key: "disableAll",
    value: function disableAll() {
      this.mask = 0;
    }
  }, {
    key: "test",
    value: function test(t) {
      return 0 != (this.mask & t.mask);
    }
  }]);

  return Tt;
}();

var Lt = 0;
var Rt = new H(),
    Dt = new O(),
    Qt = new yt(),
    Pt = new H(),
    Ft = new H(),
    Nt = new H(),
    Ut = new O(),
    Gt = new H(1, 0, 0),
    kt = new H(0, 1, 0),
    Ot = new H(0, 0, 1),
    Ht = {
  type: "added"
},
    zt = {
  type: "removed"
};

var Vt = /*#__PURE__*/function (_y4) {
  _inherits(Vt, _y4);

  var _super4 = _createSuper(Vt);

  function Vt() {
    var _this10;

    _classCallCheck(this, Vt);

    _this10 = _super4.call(this), Object.defineProperty(_assertThisInitialized(_this10), "id", {
      value: Lt++
    }), _this10.uuid = _(), _this10.name = "", _this10.type = "Object3D", _this10.parent = null, _this10.children = [], _this10.up = Vt.DefaultUp.clone();
    var t = new H(),
        e = new Bt(),
        n = new O(),
        i = new H(1, 1, 1);
    e._onChange(function () {
      n.setFromEuler(e, !1);
    }), n._onChange(function () {
      e.setFromQuaternion(n, void 0, !1);
    }), Object.defineProperties(_assertThisInitialized(_this10), {
      position: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new yt()
      },
      normalMatrix: {
        value: new D()
      }
    }), _this10.matrix = new yt(), _this10.matrixWorld = new yt(), _this10.matrixAutoUpdate = Vt.DefaultMatrixAutoUpdate, _this10.matrixWorldNeedsUpdate = !1, _this10.layers = new Tt(), _this10.visible = !0, _this10.castShadow = !1, _this10.receiveShadow = !1, _this10.frustumCulled = !0, _this10.renderOrder = 0, _this10.animations = [], _this10.userData = {};
    return _this10;
  }

  _createClass(Vt, [{
    key: "onBeforeRender",
    value: function onBeforeRender() {}
  }, {
    key: "onAfterRender",
    value: function onAfterRender() {}
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
  }, {
    key: "setRotationFromAxisAngle",
    value: function setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
  }, {
    key: "setRotationFromEuler",
    value: function setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
  }, {
    key: "setRotationFromMatrix",
    value: function setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
  }, {
    key: "setRotationFromQuaternion",
    value: function setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
  }, {
    key: "rotateOnAxis",
    value: function rotateOnAxis(t, e) {
      return Dt.setFromAxisAngle(t, e), this.quaternion.multiply(Dt), this;
    }
  }, {
    key: "rotateOnWorldAxis",
    value: function rotateOnWorldAxis(t, e) {
      return Dt.setFromAxisAngle(t, e), this.quaternion.premultiply(Dt), this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(t) {
      return this.rotateOnAxis(Gt, t);
    }
  }, {
    key: "rotateY",
    value: function rotateY(t) {
      return this.rotateOnAxis(kt, t);
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(t) {
      return this.rotateOnAxis(Ot, t);
    }
  }, {
    key: "translateOnAxis",
    value: function translateOnAxis(t, e) {
      return Rt.copy(t).applyQuaternion(this.quaternion), this.position.add(Rt.multiplyScalar(e)), this;
    }
  }, {
    key: "translateX",
    value: function translateX(t) {
      return this.translateOnAxis(Gt, t);
    }
  }, {
    key: "translateY",
    value: function translateY(t) {
      return this.translateOnAxis(kt, t);
    }
  }, {
    key: "translateZ",
    value: function translateZ(t) {
      return this.translateOnAxis(Ot, t);
    }
  }, {
    key: "localToWorld",
    value: function localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld);
    }
  }, {
    key: "worldToLocal",
    value: function worldToLocal(t) {
      return t.applyMatrix4(Qt.copy(this.matrixWorld).invert());
    }
  }, {
    key: "lookAt",
    value: function lookAt(t, e, n) {
      t.isVector3 ? Pt.copy(t) : Pt.set(t, e, n);
      var i = this.parent;
      this.updateWorldMatrix(!0, !1), Ft.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Qt.lookAt(Ft, Pt, this.up) : Qt.lookAt(Pt, Ft, this.up), this.quaternion.setFromRotationMatrix(Qt), i && (Qt.extractRotation(i.matrixWorld), Dt.setFromRotationMatrix(Qt), this.quaternion.premultiply(Dt.invert()));
    }
  }, {
    key: "add",
    value: function add(t) {
      if (arguments.length > 1) {
        for (var _t29 = 0; _t29 < arguments.length; _t29++) {
          this.add(arguments[_t29]);
        }

        return this;
      }

      return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Ht)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
    }
  }, {
    key: "remove",
    value: function remove(t) {
      if (arguments.length > 1) {
        for (var _t30 = 0; _t30 < arguments.length; _t30++) {
          this.remove(arguments[_t30]);
        }

        return this;
      }

      var e = this.children.indexOf(t);
      return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(zt)), this;
    }
  }, {
    key: "clear",
    value: function clear() {
      for (var _t31 = 0; _t31 < this.children.length; _t31++) {
        var _e10 = this.children[_t31];
        _e10.parent = null, _e10.dispatchEvent(zt);
      }

      return this.children.length = 0, this;
    }
  }, {
    key: "attach",
    value: function attach(t) {
      return this.updateWorldMatrix(!0, !1), Qt.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Qt.multiply(t.parent.matrixWorld)), t.applyMatrix4(Qt), this.add(t), t.updateWorldMatrix(!1, !0), this;
    }
  }, {
    key: "getObjectById",
    value: function getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
  }, {
    key: "getObjectByName",
    value: function getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
  }, {
    key: "getObjectByProperty",
    value: function getObjectByProperty(t, e) {
      if (this[t] === e) return this;

      for (var _n17 = 0, _i11 = this.children.length; _n17 < _i11; _n17++) {
        var _i12 = this.children[_n17].getObjectByProperty(t, e);

        if (void 0 !== _i12) return _i12;
      }
    }
  }, {
    key: "getWorldPosition",
    value: function getWorldPosition(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new H()), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
    }
  }, {
    key: "getWorldQuaternion",
    value: function getWorldQuaternion(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new O()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ft, t, Nt), t;
    }
  }, {
    key: "getWorldScale",
    value: function getWorldScale(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new H()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ft, Ut, t), t;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(t) {
      void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new H()), this.updateWorldMatrix(!0, !1);
      var e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
  }, {
    key: "raycast",
    value: function raycast() {}
  }, {
    key: "traverse",
    value: function traverse(t) {
      t(this);
      var e = this.children;

      for (var _n18 = 0, _i13 = e.length; _n18 < _i13; _n18++) {
        e[_n18].traverse(t);
      }
    }
  }, {
    key: "traverseVisible",
    value: function traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      var e = this.children;

      for (var _n19 = 0, _i14 = e.length; _n19 < _i14; _n19++) {
        e[_n19].traverseVisible(t);
      }
    }
  }, {
    key: "traverseAncestors",
    value: function traverseAncestors(t) {
      var e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
      var e = this.children;

      for (var _n20 = 0, _i15 = e.length; _n20 < _i15; _n20++) {
        e[_n20].updateMatrixWorld(t);
      }
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(t, e) {
      var n = this.parent;

      if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
        var _t32 = this.children;

        for (var _e11 = 0, _n21 = _t32.length; _e11 < _n21; _e11++) {
          _t32[_e11].updateWorldMatrix(!1, !0);
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t,
          n = {};
      e && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      }, n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      var i = {};

      function r(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }

      if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(t.geometries, this.geometry);
        var _e12 = this.geometry.parameters;

        if (void 0 !== _e12 && void 0 !== _e12.shapes) {
          var _n22 = _e12.shapes;
          if (Array.isArray(_n22)) for (var _e13 = 0, _i16 = _n22.length; _e13 < _i16; _e13++) {
            var _i17 = _n22[_e13];
            r(t.shapes, _i17);
          } else r(t.shapes, _n22);
        }
      }

      if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
        var _e14 = [];

        for (var _n23 = 0, _i18 = this.material.length; _n23 < _i18; _n23++) {
          _e14.push(r(t.materials, this.material[_n23]));
        }

        i.material = _e14;
      } else i.material = r(t.materials, this.material);

      if (this.children.length > 0) {
        i.children = [];

        for (var _e15 = 0; _e15 < this.children.length; _e15++) {
          i.children.push(this.children[_e15].toJSON(t).object);
        }
      }

      if (this.animations.length > 0) {
        i.animations = [];

        for (var _e16 = 0; _e16 < this.animations.length; _e16++) {
          var _n24 = this.animations[_e16];
          i.animations.push(r(t.animations, _n24));
        }
      }

      if (e) {
        var _e17 = s(t.geometries),
            _i19 = s(t.materials),
            _r17 = s(t.textures),
            _a4 = s(t.images),
            _o6 = s(t.shapes),
            _l7 = s(t.skeletons),
            _c5 = s(t.animations);

        _e17.length > 0 && (n.geometries = _e17), _i19.length > 0 && (n.materials = _i19), _r17.length > 0 && (n.textures = _r17), _a4.length > 0 && (n.images = _a4), _o6.length > 0 && (n.shapes = _o6), _l7.length > 0 && (n.skeletons = _l7), _c5.length > 0 && (n.animations = _c5);
      }

      return n.object = i, n;

      function s(t) {
        var e = [];

        for (var _n25 in t) {
          var _i20 = t[_n25];
          delete _i20.metadata, e.push(_i20);
        }

        return e;
      }
    }
  }, {
    key: "clone",
    value: function clone(t) {
      return new this.constructor().copy(this, t);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var _e18 = 0; _e18 < t.children.length; _e18++) {
        var _n26 = t.children[_e18];
        this.add(_n26.clone());
      }
      return this;
    }
  }]);

  return Vt;
}(y);

Vt.DefaultUp = new H(0, 1, 0), Vt.DefaultMatrixAutoUpdate = !0, Vt.prototype.isObject3D = !0;
var Wt = new H(),
    qt = new H(),
    jt = new D();

var Yt = /*#__PURE__*/function () {
  function Yt() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new H(1, 0, 0);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Yt);

    this.normal = t, this.constant = e;
  }

  _createClass(Yt, [{
    key: "set",
    value: function set(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    }
  }, {
    key: "setComponents",
    value: function setComponents(t, e, n, i) {
      return this.normal.set(t, e, n), this.constant = i, this;
    }
  }, {
    key: "setFromNormalAndCoplanarPoint",
    value: function setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    }
  }, {
    key: "setFromCoplanarPoints",
    value: function setFromCoplanarPoints(t, e, n) {
      var i = Wt.subVectors(n, e).cross(qt.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
  }, {
    key: "distanceToSphere",
    value: function distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
  }, {
    key: "projectPoint",
    value: function projectPoint(t, e) {
      return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new H()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    }
  }, {
    key: "intersectLine",
    value: function intersectLine(t, e) {
      void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new H());
      var n = t.delta(Wt),
          i = this.normal.dot(n);
      if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      var r = -(t.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start);
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(t) {
      var e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
      return e < 0 && n > 0 || n < 0 && e > 0;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return t.intersectsPlane(this);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
  }, {
    key: "coplanarPoint",
    value: function coplanarPoint(t) {
      return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new H()), t.copy(this.normal).multiplyScalar(-this.constant);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t, e) {
      var n = e || jt.getNormalMatrix(t),
          i = this.coplanarPoint(Wt).applyMatrix4(t),
          r = this.normal.applyMatrix3(n).normalize();
      return this.constant = -i.dot(r), this;
    }
  }, {
    key: "translate",
    value: function translate(t) {
      return this.constant -= t.dot(this.normal), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Yt;
}();

Yt.prototype.isPlane = !0;
var Jt = new H(),
    Xt = new H(),
    Kt = new H(),
    Zt = new H(),
    $t = new H(),
    te = new H(),
    ee = new H(),
    ne = new H(),
    ie = new H(),
    re = new H();

var se = /*#__PURE__*/function () {
  function se() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new H();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new H();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new H();

    _classCallCheck(this, se);

    this.a = t, this.b = e, this.c = n;
  }

  _createClass(se, [{
    key: "set",
    value: function set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
  }, {
    key: "setFromPointsAndIndices",
    value: function setFromPointsAndIndices(t, e, n, i) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      return Jt.subVectors(this.c, this.b), Xt.subVectors(this.a, this.b), .5 * Jt.cross(Xt).length();
    }
  }, {
    key: "getMidpoint",
    value: function getMidpoint(t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new H()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
  }, {
    key: "getNormal",
    value: function getNormal(t) {
      return se.getNormal(this.a, this.b, this.c, t);
    }
  }, {
    key: "getPlane",
    value: function getPlane(t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Yt()), t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
  }, {
    key: "getBarycoord",
    value: function getBarycoord(t, e) {
      return se.getBarycoord(t, this.a, this.b, this.c, e);
    }
  }, {
    key: "getUV",
    value: function getUV(t, e, n, i, r) {
      return se.getUV(t, this.a, this.b, this.c, e, n, i, r);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      return se.containsPoint(t, this.a, this.b, this.c);
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(t) {
      return se.isFrontFacing(this.a, this.b, this.c, t);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(t, e) {
      void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new H());
      var n = this.a,
          i = this.b,
          r = this.c;
      var s, a;
      $t.subVectors(i, n), te.subVectors(r, n), ne.subVectors(t, n);
      var o = $t.dot(ne),
          l = te.dot(ne);
      if (o <= 0 && l <= 0) return e.copy(n);
      ie.subVectors(t, i);
      var c = $t.dot(ie),
          h = te.dot(ie);
      if (c >= 0 && h <= c) return e.copy(i);
      var u = o * h - c * l;
      if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector($t, s);
      re.subVectors(t, r);
      var d = $t.dot(re),
          A = te.dot(re);
      if (A >= 0 && d <= A) return e.copy(r);
      var p = d * l - o * A;
      if (p <= 0 && l >= 0 && A <= 0) return a = l / (l - A), e.copy(n).addScaledVector(te, a);
      var g = c * A - d * h;
      if (g <= 0 && h - c >= 0 && d - A >= 0) return ee.subVectors(r, i), a = (h - c) / (h - c + (d - A)), e.copy(i).addScaledVector(ee, a);
      var m = 1 / (g + p + u);
      return s = p * m, a = u * m, e.copy(n).addScaledVector($t, s).addScaledVector(te, a);
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }], [{
    key: "getNormal",
    value: function getNormal(t, e, n, i) {
      void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new H()), i.subVectors(n, e), Jt.subVectors(t, e), i.cross(Jt);
      var r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
  }, {
    key: "getBarycoord",
    value: function getBarycoord(t, e, n, i, r) {
      Jt.subVectors(i, e), Xt.subVectors(n, e), Kt.subVectors(t, e);
      var s = Jt.dot(Jt),
          a = Jt.dot(Xt),
          o = Jt.dot(Kt),
          l = Xt.dot(Xt),
          c = Xt.dot(Kt),
          h = s * l - a * a;
      if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new H()), 0 === h) return r.set(-2, -1, -1);
      var u = 1 / h,
          d = (l * o - a * c) * u,
          A = (s * c - a * o) * u;
      return r.set(1 - d - A, A, d);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t, e, n, i) {
      return this.getBarycoord(t, e, n, i, Zt), Zt.x >= 0 && Zt.y >= 0 && Zt.x + Zt.y <= 1;
    }
  }, {
    key: "getUV",
    value: function getUV(t, e, n, i, r, s, a, o) {
      return this.getBarycoord(t, e, n, i, Zt), o.set(0, 0), o.addScaledVector(r, Zt.x), o.addScaledVector(s, Zt.y), o.addScaledVector(a, Zt.z), o;
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(t, e, n, i) {
      return Jt.subVectors(n, e), Xt.subVectors(t, e), Jt.cross(Xt).dot(i) < 0;
    }
  }]);

  return se;
}();

var ae = 0;

function oe() {
  Object.defineProperty(this, "id", {
    value: ae++
  }), this.uuid = _(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
}

oe.prototype = Object.assign(Object.create(y.prototype), {
  constructor: oe,
  isMaterial: !0,
  onBuild: function onBuild() {},
  onBeforeCompile: function onBeforeCompile() {},
  customProgramCacheKey: function customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  },
  setValues: function setValues(t) {
    if (void 0 !== t) for (var _e19 in t) {
      var _n27 = t[_e19];

      if (void 0 === _n27) {
        console.warn("THREE.Material: '" + _e19 + "' parameter is undefined.");
        continue;
      }

      if ("shading" === _e19) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === _n27;
        continue;
      }

      var _i21 = this[_e19];
      void 0 !== _i21 ? _i21 && _i21.isColor ? _i21.set(_n27) : _i21 && _i21.isVector3 && _n27 && _n27.isVector3 ? _i21.copy(_n27) : this[_e19] = _n27 : console.warn("THREE." + this.type + ": '" + _e19 + "' is not a property of this material.");
    }
  },
  toJSON: function toJSON(t) {
    var e = void 0 === t || "string" == typeof t;
    e && (t = {
      textures: {},
      images: {}
    });
    var n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };

    function i(t) {
      var e = [];

      for (var _n28 in t) {
        var _i22 = t[_n28];
        delete _i22.metadata, e.push(_i22);
      }

      return e;
    }

    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
      var _e20 = i(t.textures),
          _r18 = i(t.images);

      _e20.length > 0 && (n.textures = _e20), _r18.length > 0 && (n.images = _r18);
    }

    return n;
  },
  clone: function clone() {
    return new this.constructor().copy(this);
  },
  copy: function copy(t) {
    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    var e = t.clippingPlanes;
    var n = null;

    if (null !== e) {
      var _t33 = e.length;
      n = new Array(_t33);

      for (var _i23 = 0; _i23 !== _t33; ++_i23) {
        n[_i23] = e[_i23].clone();
      }
    }

    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  },
  dispose: function dispose() {
    this.dispatchEvent({
      type: "dispose"
    });
  }
}), Object.defineProperty(oe.prototype, "needsUpdate", {
  set: function set(t) {
    !0 === t && this.version++;
  }
});
var le = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
},
    ce = {
  h: 0,
  s: 0,
  l: 0
},
    he = {
  h: 0,
  s: 0,
  l: 0
};

function ue(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t;
}

function de(t) {
  return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4);
}

function Ae(t) {
  return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055;
}

var pe = /*#__PURE__*/function () {
  function pe(t, e, n) {
    _classCallCheck(this, pe);

    return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
  }

  _createClass(pe, [{
    key: "set",
    value: function set(t) {
      return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.r = t, this.g = t, this.b = t, this;
    }
  }, {
    key: "setHex",
    value: function setHex(t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this;
    }
  }, {
    key: "setRGB",
    value: function setRGB(t, e, n) {
      return this.r = t, this.g = e, this.b = n, this;
    }
  }, {
    key: "setHSL",
    value: function setHSL(t, e, n) {
      if (t = C(t, 1), e = I(e, 0, 1), n = I(n, 0, 1), 0 === e) this.r = this.g = this.b = n;else {
        var _i24 = n <= .5 ? n * (1 + e) : n + e - n * e,
            _r19 = 2 * n - _i24;

        this.r = ue(_r19, _i24, t + 1 / 3), this.g = ue(_r19, _i24, t), this.b = ue(_r19, _i24, t - 1 / 3);
      }
      return this;
    }
  }, {
    key: "setStyle",
    value: function setStyle(t) {
      function e(e) {
        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
      }

      var n;

      if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
        var _t34;

        var _i25 = n[1],
            _r20 = n[2];

        switch (_i25) {
          case "rgb":
          case "rgba":
            if (_t34 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_r20)) return this.r = Math.min(255, parseInt(_t34[1], 10)) / 255, this.g = Math.min(255, parseInt(_t34[2], 10)) / 255, this.b = Math.min(255, parseInt(_t34[3], 10)) / 255, e(_t34[4]), this;
            if (_t34 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_r20)) return this.r = Math.min(100, parseInt(_t34[1], 10)) / 100, this.g = Math.min(100, parseInt(_t34[2], 10)) / 100, this.b = Math.min(100, parseInt(_t34[3], 10)) / 100, e(_t34[4]), this;
            break;

          case "hsl":
          case "hsla":
            if (_t34 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_r20)) {
              var _n29 = parseFloat(_t34[1]) / 360,
                  _i26 = parseInt(_t34[2], 10) / 100,
                  _r21 = parseInt(_t34[3], 10) / 100;

              return e(_t34[4]), this.setHSL(_n29, _i26, _r21);
            }

        }
      } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
        var _t35 = n[1],
            _e21 = _t35.length;
        if (3 === _e21) return this.r = parseInt(_t35.charAt(0) + _t35.charAt(0), 16) / 255, this.g = parseInt(_t35.charAt(1) + _t35.charAt(1), 16) / 255, this.b = parseInt(_t35.charAt(2) + _t35.charAt(2), 16) / 255, this;
        if (6 === _e21) return this.r = parseInt(_t35.charAt(0) + _t35.charAt(1), 16) / 255, this.g = parseInt(_t35.charAt(2) + _t35.charAt(3), 16) / 255, this.b = parseInt(_t35.charAt(4) + _t35.charAt(5), 16) / 255, this;
      }

      return t && t.length > 0 ? this.setColorName(t) : this;
    }
  }, {
    key: "setColorName",
    value: function setColorName(t) {
      var e = le[t.toLowerCase()];
      return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    }
  }, {
    key: "copyGammaToLinear",
    value: function copyGammaToLinear(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    }
  }, {
    key: "copyLinearToGamma",
    value: function copyLinearToGamma(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      var n = e > 0 ? 1 / e : 1;
      return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this;
    }
  }, {
    key: "convertGammaToLinear",
    value: function convertGammaToLinear(t) {
      return this.copyGammaToLinear(this, t), this;
    }
  }, {
    key: "convertLinearToGamma",
    value: function convertLinearToGamma(t) {
      return this.copyLinearToGamma(this, t), this;
    }
  }, {
    key: "copySRGBToLinear",
    value: function copySRGBToLinear(t) {
      return this.r = de(t.r), this.g = de(t.g), this.b = de(t.b), this;
    }
  }, {
    key: "copyLinearToSRGB",
    value: function copyLinearToSRGB(t) {
      return this.r = Ae(t.r), this.g = Ae(t.g), this.b = Ae(t.b), this;
    }
  }, {
    key: "convertSRGBToLinear",
    value: function convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
  }, {
    key: "convertLinearToSRGB",
    value: function convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
  }, {
    key: "getHex",
    value: function getHex() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    }
  }, {
    key: "getHexString",
    value: function getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
  }, {
    key: "getHSL",
    value: function getHSL(t) {
      void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
        h: 0,
        s: 0,
        l: 0
      });
      var e = this.r,
          n = this.g,
          i = this.b,
          r = Math.max(e, n, i),
          s = Math.min(e, n, i);
      var a, o;
      var l = (s + r) / 2;
      if (s === r) a = 0, o = 0;else {
        var _t36 = r - s;

        switch (o = l <= .5 ? _t36 / (r + s) : _t36 / (2 - r - s), r) {
          case e:
            a = (n - i) / _t36 + (n < i ? 6 : 0);
            break;

          case n:
            a = (i - e) / _t36 + 2;
            break;

          case i:
            a = (e - n) / _t36 + 4;
        }

        a /= 6;
      }
      return t.h = a, t.s = o, t.l = l, t;
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    }
  }, {
    key: "offsetHSL",
    value: function offsetHSL(t, e, n) {
      return this.getHSL(ce), ce.h += t, ce.s += e, ce.l += n, this.setHSL(ce.h, ce.s, ce.l), this;
    }
  }, {
    key: "add",
    value: function add(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    }
  }, {
    key: "addColors",
    value: function addColors(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.r += t, this.g += t, this.b += t, this;
    }
  }, {
    key: "sub",
    value: function sub(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    }
  }, {
    key: "lerpColors",
    value: function lerpColors(t, e, n) {
      return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this;
    }
  }, {
    key: "lerpHSL",
    value: function lerpHSL(t, e) {
      this.getHSL(ce), t.getHSL(he);
      var n = M(ce.h, he.h, e),
          i = M(ce.s, he.s, e),
          r = M(ce.l, he.l, e);
      return this.setHSL(n, i, r), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e) {
      return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.getHex();
    }
  }]);

  return pe;
}();

pe.NAMES = le, pe.prototype.isColor = !0, pe.prototype.r = 1, pe.prototype.g = 1, pe.prototype.b = 1;

var ge = /*#__PURE__*/function (_oe) {
  _inherits(ge, _oe);

  var _super5 = _createSuper(ge);

  function ge(t) {
    var _this11;

    _classCallCheck(this, ge);

    _this11 = _super5.call(this), _this11.type = "MeshBasicMaterial", _this11.color = new pe(16777215), _this11.map = null, _this11.lightMap = null, _this11.lightMapIntensity = 1, _this11.aoMap = null, _this11.aoMapIntensity = 1, _this11.specularMap = null, _this11.alphaMap = null, _this11.envMap = null, _this11.combine = 0, _this11.reflectivity = 1, _this11.refractionRatio = .98, _this11.wireframe = !1, _this11.wireframeLinewidth = 1, _this11.wireframeLinecap = "round", _this11.wireframeLinejoin = "round", _this11.skinning = !1, _this11.morphTargets = !1, _this11.setValues(t);
    return _this11;
  }

  _createClass(ge, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(ge.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
    }
  }]);

  return ge;
}(oe);

ge.prototype.isMeshBasicMaterial = !0;
var me = new H(),
    fe = new R();

var ve = /*#__PURE__*/function () {
  function ve(t, e, n) {
    _classCallCheck(this, ve);

    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
      offset: 0,
      count: -1
    }, this.version = 0, this.onUploadCallback = function () {};
  }

  _createClass(ve, [{
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }, {
    key: "setUsage",
    value: function setUsage(t) {
      return this.usage = t, this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(t, e, n) {
      t *= this.itemSize, n *= e.itemSize;

      for (var _i27 = 0, _r22 = this.itemSize; _i27 < _r22; _i27++) {
        this.array[t + _i27] = e.array[n + _i27];
      }

      return this;
    }
  }, {
    key: "copyArray",
    value: function copyArray(t) {
      return this.array.set(t), this;
    }
  }, {
    key: "copyColorsArray",
    value: function copyColorsArray(t) {
      var e = this.array;
      var n = 0;

      for (var _i28 = 0, _r23 = t.length; _i28 < _r23; _i28++) {
        var _r24 = t[_i28];
        void 0 === _r24 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", _i28), _r24 = new pe()), e[n++] = _r24.r, e[n++] = _r24.g, e[n++] = _r24.b;
      }

      return this;
    }
  }, {
    key: "copyVector2sArray",
    value: function copyVector2sArray(t) {
      var e = this.array;
      var n = 0;

      for (var _i29 = 0, _r25 = t.length; _i29 < _r25; _i29++) {
        var _r26 = t[_i29];
        void 0 === _r26 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", _i29), _r26 = new R()), e[n++] = _r26.x, e[n++] = _r26.y;
      }

      return this;
    }
  }, {
    key: "copyVector3sArray",
    value: function copyVector3sArray(t) {
      var e = this.array;
      var n = 0;

      for (var _i30 = 0, _r27 = t.length; _i30 < _r27; _i30++) {
        var _r28 = t[_i30];
        void 0 === _r28 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", _i30), _r28 = new H()), e[n++] = _r28.x, e[n++] = _r28.y, e[n++] = _r28.z;
      }

      return this;
    }
  }, {
    key: "copyVector4sArray",
    value: function copyVector4sArray(t) {
      var e = this.array;
      var n = 0;

      for (var _i31 = 0, _r29 = t.length; _i31 < _r29; _i31++) {
        var _r30 = t[_i31];
        void 0 === _r30 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", _i31), _r30 = new G()), e[n++] = _r30.x, e[n++] = _r30.y, e[n++] = _r30.z, e[n++] = _r30.w;
      }

      return this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(t) {
      if (2 === this.itemSize) for (var _e22 = 0, _n30 = this.count; _e22 < _n30; _e22++) {
        fe.fromBufferAttribute(this, _e22), fe.applyMatrix3(t), this.setXY(_e22, fe.x, fe.y);
      } else if (3 === this.itemSize) for (var _e23 = 0, _n31 = this.count; _e23 < _n31; _e23++) {
        me.fromBufferAttribute(this, _e23), me.applyMatrix3(t), this.setXYZ(_e23, me.x, me.y, me.z);
      }
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      for (var _e24 = 0, _n32 = this.count; _e24 < _n32; _e24++) {
        me.x = this.getX(_e24), me.y = this.getY(_e24), me.z = this.getZ(_e24), me.applyMatrix4(t), this.setXYZ(_e24, me.x, me.y, me.z);
      }

      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(t) {
      for (var _e25 = 0, _n33 = this.count; _e25 < _n33; _e25++) {
        me.x = this.getX(_e25), me.y = this.getY(_e25), me.z = this.getZ(_e25), me.applyNormalMatrix(t), this.setXYZ(_e25, me.x, me.y, me.z);
      }

      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(t) {
      for (var _e26 = 0, _n34 = this.count; _e26 < _n34; _e26++) {
        me.x = this.getX(_e26), me.y = this.getY(_e26), me.z = this.getZ(_e26), me.transformDirection(t), this.setXYZ(_e26, me.x, me.y, me.z);
      }

      return this;
    }
  }, {
    key: "set",
    value: function set(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.array.set(t, e), this;
    }
  }, {
    key: "getX",
    value: function getX(t) {
      return this.array[t * this.itemSize];
    }
  }, {
    key: "setX",
    value: function setX(t, e) {
      return this.array[t * this.itemSize] = e, this;
    }
  }, {
    key: "getY",
    value: function getY(t) {
      return this.array[t * this.itemSize + 1];
    }
  }, {
    key: "setY",
    value: function setY(t, e) {
      return this.array[t * this.itemSize + 1] = e, this;
    }
  }, {
    key: "getZ",
    value: function getZ(t) {
      return this.array[t * this.itemSize + 2];
    }
  }, {
    key: "setZ",
    value: function setZ(t, e) {
      return this.array[t * this.itemSize + 2] = e, this;
    }
  }, {
    key: "getW",
    value: function getW(t) {
      return this.array[t * this.itemSize + 3];
    }
  }, {
    key: "setW",
    value: function setW(t, e) {
      return this.array[t * this.itemSize + 3] = e, this;
    }
  }, {
    key: "setXY",
    value: function setXY(t, e, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(t, e, n, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(t, e, n, i, r) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this;
    }
  }, {
    key: "onUpload",
    value: function onUpload(t) {
      return this.onUploadCallback = t, this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
      return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t;
    }
  }]);

  return ve;
}();

ve.prototype.isBufferAttribute = !0;

var ye = /*#__PURE__*/function (_ve) {
  _inherits(ye, _ve);

  var _super6 = _createSuper(ye);

  function ye(t, e, n) {
    _classCallCheck(this, ye);

    return _super6.call(this, new Uint16Array(t), e, n);
  }

  return ye;
}(ve);

var Ee = /*#__PURE__*/function (_ve2) {
  _inherits(Ee, _ve2);

  var _super7 = _createSuper(Ee);

  function Ee(t, e, n) {
    _classCallCheck(this, Ee);

    return _super7.call(this, new Uint32Array(t), e, n);
  }

  return Ee;
}(ve);

var xe = /*#__PURE__*/function (_ve3) {
  _inherits(xe, _ve3);

  var _super8 = _createSuper(xe);

  function xe(t, e, n) {
    _classCallCheck(this, xe);

    return _super8.call(this, new Float32Array(t), e, n);
  }

  return xe;
}(ve);

function we(t) {
  if (0 === t.length) return -1 / 0;
  var e = t[0];

  for (var _n35 = 1, _i32 = t.length; _n35 < _i32; ++_n35) {
    t[_n35] > e && (e = t[_n35]);
  }

  return e;
}

var be = 0;

var _e = new yt(),
    Ie = new Vt(),
    Ce = new H(),
    Me = new W(),
    Se = new W(),
    Be = new H();

var Te = /*#__PURE__*/function (_y5) {
  _inherits(Te, _y5);

  var _super9 = _createSuper(Te);

  function Te() {
    var _this12;

    _classCallCheck(this, Te);

    _this12 = _super9.call(this), Object.defineProperty(_assertThisInitialized(_this12), "id", {
      value: be++
    }), _this12.uuid = _(), _this12.name = "", _this12.type = "BufferGeometry", _this12.index = null, _this12.attributes = {}, _this12.morphAttributes = {}, _this12.morphTargetsRelative = !1, _this12.groups = [], _this12.boundingBox = null, _this12.boundingSphere = null, _this12.drawRange = {
      start: 0,
      count: 1 / 0
    }, _this12.userData = {};
    return _this12;
  }

  _createClass(Te, [{
    key: "getIndex",
    value: function getIndex() {
      return this.index;
    }
  }, {
    key: "setIndex",
    value: function setIndex(t) {
      return Array.isArray(t) ? this.index = new (we(t) > 65535 ? Ee : ye)(t, 1) : this.index = t, this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(t) {
      return this.attributes[t];
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(t, e) {
      return this.attributes[t] = e, this;
    }
  }, {
    key: "deleteAttribute",
    value: function deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(t) {
      return void 0 !== this.attributes[t];
    }
  }, {
    key: "addGroup",
    value: function addGroup(t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.groups.push({
        start: t,
        count: e,
        materialIndex: n
      });
    }
  }, {
    key: "clearGroups",
    value: function clearGroups() {
      this.groups = [];
    }
  }, {
    key: "setDrawRange",
    value: function setDrawRange(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      var e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
      var n = this.attributes.normal;

      if (void 0 !== n) {
        var _e27 = new D().getNormalMatrix(t);

        n.applyNormalMatrix(_e27), n.needsUpdate = !0;
      }

      var i = this.attributes.tangent;
      return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(t) {
      return _e.makeRotationX(t), this.applyMatrix4(_e), this;
    }
  }, {
    key: "rotateY",
    value: function rotateY(t) {
      return _e.makeRotationY(t), this.applyMatrix4(_e), this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(t) {
      return _e.makeRotationZ(t), this.applyMatrix4(_e), this;
    }
  }, {
    key: "translate",
    value: function translate(t, e, n) {
      return _e.makeTranslation(t, e, n), this.applyMatrix4(_e), this;
    }
  }, {
    key: "scale",
    value: function scale(t, e, n) {
      return _e.makeScale(t, e, n), this.applyMatrix4(_e), this;
    }
  }, {
    key: "lookAt",
    value: function lookAt(t) {
      return Ie.lookAt(t), Ie.updateMatrix(), this.applyMatrix4(Ie.matrix), this;
    }
  }, {
    key: "center",
    value: function center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(Ce).negate(), this.translate(Ce.x, Ce.y, Ce.z), this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(t) {
      var e = [];

      for (var _n36 = 0, _i33 = t.length; _n36 < _i33; _n36++) {
        var _i34 = t[_n36];
        e.push(_i34.x, _i34.y, _i34.z || 0);
      }

      return this.setAttribute("position", new xe(e, 3)), this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new W());
      var t = this.attributes.position,
          e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new H(-1 / 0, -1 / 0, -1 / 0), new H(1 / 0, 1 / 0, 1 / 0));

      if (void 0 !== t) {
        if (this.boundingBox.setFromBufferAttribute(t), e) for (var _t37 = 0, _n37 = e.length; _t37 < _n37; _t37++) {
          var _n38 = e[_t37];
          Me.setFromBufferAttribute(_n38), this.morphTargetsRelative ? (Be.addVectors(this.boundingBox.min, Me.min), this.boundingBox.expandByPoint(Be), Be.addVectors(this.boundingBox.max, Me.max), this.boundingBox.expandByPoint(Be)) : (this.boundingBox.expandByPoint(Me.min), this.boundingBox.expandByPoint(Me.max));
        }
      } else this.boundingBox.makeEmpty();

      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new ht());
      var t = this.attributes.position,
          e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new H(), 1 / 0);

      if (t) {
        var _n39 = this.boundingSphere.center;
        if (Me.setFromBufferAttribute(t), e) for (var _t38 = 0, _n40 = e.length; _t38 < _n40; _t38++) {
          var _n41 = e[_t38];
          Se.setFromBufferAttribute(_n41), this.morphTargetsRelative ? (Be.addVectors(Me.min, Se.min), Me.expandByPoint(Be), Be.addVectors(Me.max, Se.max), Me.expandByPoint(Be)) : (Me.expandByPoint(Se.min), Me.expandByPoint(Se.max));
        }
        Me.getCenter(_n39);
        var _i35 = 0;

        for (var _e28 = 0, _r31 = t.count; _e28 < _r31; _e28++) {
          Be.fromBufferAttribute(t, _e28), _i35 = Math.max(_i35, _n39.distanceToSquared(Be));
        }

        if (e) for (var _r32 = 0, _s4 = e.length; _r32 < _s4; _r32++) {
          var _s5 = e[_r32],
              _a5 = this.morphTargetsRelative;

          for (var _e29 = 0, _r33 = _s5.count; _e29 < _r33; _e29++) {
            Be.fromBufferAttribute(_s5, _e29), _a5 && (Ce.fromBufferAttribute(t, _e29), Be.add(Ce)), _i35 = Math.max(_i35, _n39.distanceToSquared(Be));
          }
        }
        this.boundingSphere.radius = Math.sqrt(_i35), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }, {
    key: "computeFaceNormals",
    value: function computeFaceNormals() {}
  }, {
    key: "computeTangents",
    value: function computeTangents() {
      var t = this.index,
          e = this.attributes;
      if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      var n = t.array,
          i = e.position.array,
          r = e.normal.array,
          s = e.uv.array,
          a = i.length / 3;
      void 0 === e.tangent && this.setAttribute("tangent", new ve(new Float32Array(4 * a), 4));
      var o = e.tangent.array,
          l = [],
          c = [];

      for (var _t39 = 0; _t39 < a; _t39++) {
        l[_t39] = new H(), c[_t39] = new H();
      }

      var h = new H(),
          u = new H(),
          d = new H(),
          A = new R(),
          p = new R(),
          g = new R(),
          m = new H(),
          f = new H();

      function v(t, e, n) {
        h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), A.fromArray(s, 2 * t), p.fromArray(s, 2 * e), g.fromArray(s, 2 * n), u.sub(h), d.sub(h), p.sub(A), g.sub(A);
        var r = 1 / (p.x * g.y - g.x * p.y);
        isFinite(r) && (m.copy(u).multiplyScalar(g.y).addScaledVector(d, -p.y).multiplyScalar(r), f.copy(d).multiplyScalar(p.x).addScaledVector(u, -g.x).multiplyScalar(r), l[t].add(m), l[e].add(m), l[n].add(m), c[t].add(f), c[e].add(f), c[n].add(f));
      }

      var y = this.groups;
      0 === y.length && (y = [{
        start: 0,
        count: n.length
      }]);

      for (var _t40 = 0, _e30 = y.length; _t40 < _e30; ++_t40) {
        var _e31 = y[_t40],
            _i36 = _e31.start;

        for (var _t41 = _i36, _r34 = _i36 + _e31.count; _t41 < _r34; _t41 += 3) {
          v(n[_t41 + 0], n[_t41 + 1], n[_t41 + 2]);
        }
      }

      var E = new H(),
          x = new H(),
          w = new H(),
          b = new H();

      function _(t) {
        w.fromArray(r, 3 * t), b.copy(w);
        var e = l[t];
        E.copy(e), E.sub(w.multiplyScalar(w.dot(e))).normalize(), x.crossVectors(b, e);
        var n = x.dot(c[t]) < 0 ? -1 : 1;
        o[4 * t] = E.x, o[4 * t + 1] = E.y, o[4 * t + 2] = E.z, o[4 * t + 3] = n;
      }

      for (var _t42 = 0, _e32 = y.length; _t42 < _e32; ++_t42) {
        var _e33 = y[_t42],
            _i37 = _e33.start;

        for (var _t43 = _i37, _r35 = _i37 + _e33.count; _t43 < _r35; _t43 += 3) {
          _(n[_t43 + 0]), _(n[_t43 + 1]), _(n[_t43 + 2]);
        }
      }
    }
  }, {
    key: "computeVertexNormals",
    value: function computeVertexNormals() {
      var t = this.index,
          e = this.getAttribute("position");

      if (void 0 !== e) {
        var _n42 = this.getAttribute("normal");

        if (void 0 === _n42) _n42 = new ve(new Float32Array(3 * e.count), 3), this.setAttribute("normal", _n42);else for (var _t44 = 0, _e34 = _n42.count; _t44 < _e34; _t44++) {
          _n42.setXYZ(_t44, 0, 0, 0);
        }

        var _i38 = new H(),
            _r36 = new H(),
            _s6 = new H(),
            _a6 = new H(),
            _o7 = new H(),
            _l8 = new H(),
            _c6 = new H(),
            _h4 = new H();

        if (t) for (var _u2 = 0, _d2 = t.count; _u2 < _d2; _u2 += 3) {
          var _d3 = t.getX(_u2 + 0),
              _A2 = t.getX(_u2 + 1),
              _p2 = t.getX(_u2 + 2);

          _i38.fromBufferAttribute(e, _d3), _r36.fromBufferAttribute(e, _A2), _s6.fromBufferAttribute(e, _p2), _c6.subVectors(_s6, _r36), _h4.subVectors(_i38, _r36), _c6.cross(_h4), _a6.fromBufferAttribute(_n42, _d3), _o7.fromBufferAttribute(_n42, _A2), _l8.fromBufferAttribute(_n42, _p2), _a6.add(_c6), _o7.add(_c6), _l8.add(_c6), _n42.setXYZ(_d3, _a6.x, _a6.y, _a6.z), _n42.setXYZ(_A2, _o7.x, _o7.y, _o7.z), _n42.setXYZ(_p2, _l8.x, _l8.y, _l8.z);
        } else for (var _t45 = 0, _a7 = e.count; _t45 < _a7; _t45 += 3) {
          _i38.fromBufferAttribute(e, _t45 + 0), _r36.fromBufferAttribute(e, _t45 + 1), _s6.fromBufferAttribute(e, _t45 + 2), _c6.subVectors(_s6, _r36), _h4.subVectors(_i38, _r36), _c6.cross(_h4), _n42.setXYZ(_t45 + 0, _c6.x, _c6.y, _c6.z), _n42.setXYZ(_t45 + 1, _c6.x, _c6.y, _c6.z), _n42.setXYZ(_t45 + 2, _c6.x, _c6.y, _c6.z);
        }
        this.normalizeNormals(), _n42.needsUpdate = !0;
      }
    }
  }, {
    key: "merge",
    value: function merge(t, e) {
      if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
      void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      var n = this.attributes;

      for (var _i39 in n) {
        if (void 0 === t.attributes[_i39]) continue;

        var _r37 = n[_i39].array,
            _s7 = t.attributes[_i39],
            _a8 = _s7.array,
            _o8 = _s7.itemSize * e,
            _l9 = Math.min(_a8.length, _r37.length - _o8);

        for (var _t46 = 0, _e35 = _o8; _t46 < _l9; _t46++, _e35++) {
          _r37[_e35] = _a8[_t46];
        }
      }

      return this;
    }
  }, {
    key: "normalizeNormals",
    value: function normalizeNormals() {
      var t = this.attributes.normal;

      for (var _e36 = 0, _n43 = t.count; _e36 < _n43; _e36++) {
        Be.fromBufferAttribute(t, _e36), Be.normalize(), t.setXYZ(_e36, Be.x, Be.y, Be.z);
      }
    }
  }, {
    key: "toNonIndexed",
    value: function toNonIndexed() {
      function t(t, e) {
        var n = t.array,
            i = t.itemSize,
            r = t.normalized,
            s = new n.constructor(e.length * i);
        var a = 0,
            o = 0;

        for (var _t47 = 0, _r38 = e.length; _t47 < _r38; _t47++) {
          a = e[_t47] * i;

          for (var _t48 = 0; _t48 < i; _t48++) {
            s[o++] = n[a++];
          }
        }

        return new ve(s, i, r);
      }

      if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      var e = new Te(),
          n = this.index.array,
          i = this.attributes;

      for (var _r39 in i) {
        var _s8 = t(i[_r39], n);

        e.setAttribute(_r39, _s8);
      }

      var r = this.morphAttributes;

      for (var _i40 in r) {
        var _s9 = [],
            _a9 = r[_i40];

        for (var _e37 = 0, _i41 = _a9.length; _e37 < _i41; _e37++) {
          var _i42 = t(_a9[_e37], n);

          _s9.push(_i42);
        }

        e.morphAttributes[_i40] = _s9;
      }

      e.morphTargetsRelative = this.morphTargetsRelative;
      var s = this.groups;

      for (var _t49 = 0, _n44 = s.length; _t49 < _n44; _t49++) {
        var _n45 = s[_t49];
        e.addGroup(_n45.start, _n45.count, _n45.materialIndex);
      }

      return e;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };

      if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
        var _e38 = this.parameters;

        for (var _n46 in _e38) {
          void 0 !== _e38[_n46] && (t[_n46] = _e38[_n46]);
        }

        return t;
      }

      t.data = {
        attributes: {}
      };
      var e = this.index;
      null !== e && (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array)
      });
      var n = this.attributes;

      for (var _e39 in n) {
        var _i43 = n[_e39];
        t.data.attributes[_e39] = _i43.toJSON(t.data);
      }

      var i = {};
      var r = !1;

      for (var _e40 in this.morphAttributes) {
        var _n47 = this.morphAttributes[_e40],
            _s10 = [];

        for (var _e41 = 0, _i44 = _n47.length; _e41 < _i44; _e41++) {
          var _i45 = _n47[_e41];

          _s10.push(_i45.toJSON(t.data));
        }

        _s10.length > 0 && (i[_e40] = _s10, r = !0);
      }

      r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
      var s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      var a = this.boundingSphere;
      return null !== a && (t.data.boundingSphere = {
        center: a.center.toArray(),
        radius: a.radius
      }), t;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Te().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      var e = {};
      this.name = t.name;
      var n = t.index;
      null !== n && this.setIndex(n.clone(e));
      var i = t.attributes;

      for (var _t50 in i) {
        var _n48 = i[_t50];
        this.setAttribute(_t50, _n48.clone(e));
      }

      var r = t.morphAttributes;

      for (var _t51 in r) {
        var _n49 = [],
            _i46 = r[_t51];

        for (var _t52 = 0, _r40 = _i46.length; _t52 < _r40; _t52++) {
          _n49.push(_i46[_t52].clone(e));
        }

        this.morphAttributes[_t51] = _n49;
      }

      this.morphTargetsRelative = t.morphTargetsRelative;
      var s = t.groups;

      for (var _t53 = 0, _e42 = s.length; _t53 < _e42; _t53++) {
        var _e43 = s[_t53];
        this.addGroup(_e43.start, _e43.count, _e43.materialIndex);
      }

      var a = t.boundingBox;
      null !== a && (this.boundingBox = a.clone());
      var o = t.boundingSphere;
      return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }]);

  return Te;
}(y);

Te.prototype.isBufferGeometry = !0;
var Le = new yt(),
    Re = new vt(),
    De = new ht(),
    Qe = new H(),
    Pe = new H(),
    Fe = new H(),
    Ne = new H(),
    Ue = new H(),
    Ge = new H(),
    ke = new H(),
    Oe = new H(),
    He = new H(),
    ze = new R(),
    Ve = new R(),
    We = new R(),
    qe = new H(),
    je = new H();

var Ye = /*#__PURE__*/function (_Vt) {
  _inherits(Ye, _Vt);

  var _super10 = _createSuper(Ye);

  function Ye() {
    var _this13;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Te();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new ge();

    _classCallCheck(this, Ye);

    _this13 = _super10.call(this), _this13.type = "Mesh", _this13.geometry = t, _this13.material = e, _this13.updateMorphTargets();
    return _this13;
  }

  _createClass(Ye, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Ye.prototype), "copy", this).call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var t = this.geometry;

      if (t.isBufferGeometry) {
        var _e44 = t.morphAttributes,
            _n50 = Object.keys(_e44);

        if (_n50.length > 0) {
          var _t54 = _e44[_n50[0]];

          if (void 0 !== _t54) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};

            for (var _e45 = 0, _n51 = _t54.length; _e45 < _n51; _e45++) {
              var _n52 = _t54[_e45].name || String(_e45);

              this.morphTargetInfluences.push(0), this.morphTargetDictionary[_n52] = _e45;
            }
          }
        }
      } else {
        var _e46 = t.morphTargets;
        void 0 !== _e46 && _e46.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.geometry,
          i = this.material,
          r = this.matrixWorld;
      if (void 0 === i) return;
      if (null === n.boundingSphere && n.computeBoundingSphere(), De.copy(n.boundingSphere), De.applyMatrix4(r), !1 === t.ray.intersectsSphere(De)) return;
      if (Le.copy(r).invert(), Re.copy(t.ray).applyMatrix4(Le), null !== n.boundingBox && !1 === Re.intersectsBox(n.boundingBox)) return;
      var s;

      if (n.isBufferGeometry) {
        var _r41 = n.index,
            _a10 = n.attributes.position,
            _o9 = n.morphAttributes.position,
            _l10 = n.morphTargetsRelative,
            _c7 = n.attributes.uv,
            _h5 = n.attributes.uv2,
            _u3 = n.groups,
            _d4 = n.drawRange;
        if (null !== _r41) {
          if (Array.isArray(i)) for (var _n53 = 0, _A3 = _u3.length; _n53 < _A3; _n53++) {
            var _A4 = _u3[_n53],
                _p3 = i[_A4.materialIndex];

            for (var _n54 = Math.max(_A4.start, _d4.start), _i47 = Math.min(_A4.start + _A4.count, _d4.start + _d4.count); _n54 < _i47; _n54 += 3) {
              var _i48 = _r41.getX(_n54),
                  _u4 = _r41.getX(_n54 + 1),
                  _d5 = _r41.getX(_n54 + 2);

              s = Je(this, _p3, t, Re, _a10, _o9, _l10, _c7, _h5, _i48, _u4, _d5), s && (s.faceIndex = Math.floor(_n54 / 3), s.face.materialIndex = _A4.materialIndex, e.push(s));
            }
          } else {
            for (var _n55 = Math.max(0, _d4.start), _u5 = Math.min(_r41.count, _d4.start + _d4.count); _n55 < _u5; _n55 += 3) {
              var _u6 = _r41.getX(_n55),
                  _d6 = _r41.getX(_n55 + 1),
                  _A5 = _r41.getX(_n55 + 2);

              s = Je(this, i, t, Re, _a10, _o9, _l10, _c7, _h5, _u6, _d6, _A5), s && (s.faceIndex = Math.floor(_n55 / 3), e.push(s));
            }
          }
        } else if (void 0 !== _a10) if (Array.isArray(i)) for (var _n56 = 0, _r42 = _u3.length; _n56 < _r42; _n56++) {
          var _r43 = _u3[_n56],
              _A6 = i[_r43.materialIndex];

          for (var _n57 = Math.max(_r43.start, _d4.start), _i49 = Math.min(_r43.start + _r43.count, _d4.start + _d4.count); _n57 < _i49; _n57 += 3) {
            s = Je(this, _A6, t, Re, _a10, _o9, _l10, _c7, _h5, _n57, _n57 + 1, _n57 + 2), s && (s.faceIndex = Math.floor(_n57 / 3), s.face.materialIndex = _r43.materialIndex, e.push(s));
          }
        } else {
          for (var _n58 = Math.max(0, _d4.start), _r44 = Math.min(_a10.count, _d4.start + _d4.count); _n58 < _r44; _n58 += 3) {
            s = Je(this, i, t, Re, _a10, _o9, _l10, _c7, _h5, _n58, _n58 + 1, _n58 + 2), s && (s.faceIndex = Math.floor(_n58 / 3), e.push(s));
          }
        }
      } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }]);

  return Ye;
}(Vt);

function Je(t, e, n, i, r, s, a, o, l, c, h, u) {
  Qe.fromBufferAttribute(r, c), Pe.fromBufferAttribute(r, h), Fe.fromBufferAttribute(r, u);
  var d = t.morphTargetInfluences;

  if (e.morphTargets && s && d) {
    ke.set(0, 0, 0), Oe.set(0, 0, 0), He.set(0, 0, 0);

    for (var _t55 = 0, _e47 = s.length; _t55 < _e47; _t55++) {
      var _e48 = d[_t55],
          _n59 = s[_t55];
      0 !== _e48 && (Ne.fromBufferAttribute(_n59, c), Ue.fromBufferAttribute(_n59, h), Ge.fromBufferAttribute(_n59, u), a ? (ke.addScaledVector(Ne, _e48), Oe.addScaledVector(Ue, _e48), He.addScaledVector(Ge, _e48)) : (ke.addScaledVector(Ne.sub(Qe), _e48), Oe.addScaledVector(Ue.sub(Pe), _e48), He.addScaledVector(Ge.sub(Fe), _e48)));
    }

    Qe.add(ke), Pe.add(Oe), Fe.add(He);
  }

  t.isSkinnedMesh && e.skinning && (t.boneTransform(c, Qe), t.boneTransform(h, Pe), t.boneTransform(u, Fe));

  var A = function (t, e, n, i, r, s, a, o) {
    var l;
    if (l = 1 === e.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== e.side, o), null === l) return null;
    je.copy(o), je.applyMatrix4(t.matrixWorld);
    var c = n.ray.origin.distanceTo(je);
    return c < n.near || c > n.far ? null : {
      distance: c,
      point: je.clone(),
      object: t
    };
  }(t, e, n, i, Qe, Pe, Fe, qe);

  if (A) {
    o && (ze.fromBufferAttribute(o, c), Ve.fromBufferAttribute(o, h), We.fromBufferAttribute(o, u), A.uv = se.getUV(qe, Qe, Pe, Fe, ze, Ve, We, new R())), l && (ze.fromBufferAttribute(l, c), Ve.fromBufferAttribute(l, h), We.fromBufferAttribute(l, u), A.uv2 = se.getUV(qe, Qe, Pe, Fe, ze, Ve, We, new R()));
    var _t56 = {
      a: c,
      b: h,
      c: u,
      normal: new H(),
      materialIndex: 0
    };
    se.getNormal(Qe, Pe, Fe, _t56.normal), A.face = _t56;
  }

  return A;
}

Ye.prototype.isMesh = !0;

var Xe = /*#__PURE__*/function (_Te) {
  _inherits(Xe, _Te);

  var _super11 = _createSuper(Xe);

  function Xe() {
    var _this14;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

    _classCallCheck(this, Xe);

    _this14 = _super11.call(this), _this14.type = "BoxGeometry", _this14.parameters = {
      width: t,
      height: e,
      depth: n,
      widthSegments: i,
      heightSegments: r,
      depthSegments: s
    };

    var a = _assertThisInitialized(_this14);

    i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
    var o = [],
        l = [],
        c = [],
        h = [];
    var u = 0,
        d = 0;

    function A(t, e, n, i, r, s, A, p, g, m, f) {
      var v = s / g,
          y = A / m,
          E = s / 2,
          x = A / 2,
          w = p / 2,
          b = g + 1,
          _ = m + 1;

      var I = 0,
          C = 0;
      var M = new H();

      for (var _s11 = 0; _s11 < _; _s11++) {
        var _a11 = _s11 * y - x;

        for (var _o10 = 0; _o10 < b; _o10++) {
          var _u7 = _o10 * v - E;

          M[t] = _u7 * i, M[e] = _a11 * r, M[n] = w, l.push(M.x, M.y, M.z), M[t] = 0, M[e] = 0, M[n] = p > 0 ? 1 : -1, c.push(M.x, M.y, M.z), h.push(_o10 / g), h.push(1 - _s11 / m), I += 1;
        }
      }

      for (var _t57 = 0; _t57 < m; _t57++) {
        for (var _e49 = 0; _e49 < g; _e49++) {
          var _n60 = u + _e49 + b * _t57,
              _i50 = u + _e49 + b * (_t57 + 1),
              _r45 = u + (_e49 + 1) + b * (_t57 + 1),
              _s12 = u + (_e49 + 1) + b * _t57;

          o.push(_n60, _i50, _s12), o.push(_i50, _r45, _s12), C += 6;
        }
      }

      a.addGroup(d, C, f), d += C, u += I;
    }

    A("z", "y", "x", -1, -1, n, e, t, s, r, 0), A("z", "y", "x", 1, -1, n, e, -t, s, r, 1), A("x", "z", "y", 1, 1, t, n, e, i, s, 2), A("x", "z", "y", 1, -1, t, n, -e, i, s, 3), A("x", "y", "z", 1, -1, t, e, n, i, r, 4), A("x", "y", "z", -1, -1, t, e, -n, i, r, 5), _this14.setIndex(o), _this14.setAttribute("position", new xe(l, 3)), _this14.setAttribute("normal", new xe(c, 3)), _this14.setAttribute("uv", new xe(h, 2));
    return _this14;
  }

  return Xe;
}(Te);

function Ke(t) {
  var e = {};

  for (var _n61 in t) {
    e[_n61] = {};

    for (var _i51 in t[_n61]) {
      var _r46 = t[_n61][_i51];
      _r46 && (_r46.isColor || _r46.isMatrix3 || _r46.isMatrix4 || _r46.isVector2 || _r46.isVector3 || _r46.isVector4 || _r46.isTexture || _r46.isQuaternion) ? e[_n61][_i51] = _r46.clone() : Array.isArray(_r46) ? e[_n61][_i51] = _r46.slice() : e[_n61][_i51] = _r46;
    }
  }

  return e;
}

function Ze(t) {
  var e = {};

  for (var _n62 = 0; _n62 < t.length; _n62++) {
    var _i52 = Ke(t[_n62]);

    for (var _t58 in _i52) {
      e[_t58] = _i52[_t58];
    }
  }

  return e;
}

var $e = {
  clone: Ke,
  merge: Ze
};

var tn = /*#__PURE__*/function (_oe2) {
  _inherits(tn, _oe2);

  var _super12 = _createSuper(tn);

  function tn(t) {
    var _this15;

    _classCallCheck(this, tn);

    _this15 = _super12.call(this), _this15.type = "ShaderMaterial", _this15.defines = {}, _this15.uniforms = {}, _this15.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", _this15.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", _this15.linewidth = 1, _this15.wireframe = !1, _this15.wireframeLinewidth = 1, _this15.fog = !1, _this15.lights = !1, _this15.clipping = !1, _this15.skinning = !1, _this15.morphTargets = !1, _this15.morphNormals = !1, _this15.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, _this15.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, _this15.index0AttributeName = void 0, _this15.uniformsNeedUpdate = !1, _this15.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), _this15.setValues(t));
    return _this15;
  }

  _createClass(tn, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(tn.prototype), "copy", this).call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ke(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(tn.prototype), "toJSON", this).call(this, t);

      e.glslVersion = this.glslVersion, e.uniforms = {};

      for (var _n63 in this.uniforms) {
        var _i53 = this.uniforms[_n63].value;
        _i53 && _i53.isTexture ? e.uniforms[_n63] = {
          type: "t",
          value: _i53.toJSON(t).uuid
        } : _i53 && _i53.isColor ? e.uniforms[_n63] = {
          type: "c",
          value: _i53.getHex()
        } : _i53 && _i53.isVector2 ? e.uniforms[_n63] = {
          type: "v2",
          value: _i53.toArray()
        } : _i53 && _i53.isVector3 ? e.uniforms[_n63] = {
          type: "v3",
          value: _i53.toArray()
        } : _i53 && _i53.isVector4 ? e.uniforms[_n63] = {
          type: "v4",
          value: _i53.toArray()
        } : _i53 && _i53.isMatrix3 ? e.uniforms[_n63] = {
          type: "m3",
          value: _i53.toArray()
        } : _i53 && _i53.isMatrix4 ? e.uniforms[_n63] = {
          type: "m4",
          value: _i53.toArray()
        } : e.uniforms[_n63] = {
          value: _i53
        };
      }

      Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
      var n = {};

      for (var _t59 in this.extensions) {
        !0 === this.extensions[_t59] && (n[_t59] = !0);
      }

      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  }]);

  return tn;
}(oe);

tn.prototype.isShaderMaterial = !0;

var en = /*#__PURE__*/function (_Vt2) {
  _inherits(en, _Vt2);

  var _super13 = _createSuper(en);

  function en() {
    var _this16;

    _classCallCheck(this, en);

    _this16 = _super13.call(this), _this16.type = "Camera", _this16.matrixWorldInverse = new yt(), _this16.projectionMatrix = new yt(), _this16.projectionMatrixInverse = new yt();
    return _this16;
  }

  _createClass(en, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(en.prototype), "copy", this).call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(t) {
      void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new H()), this.updateWorldMatrix(!0, !1);
      var e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      _get(_getPrototypeOf(en.prototype), "updateMatrixWorld", this).call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(t, e) {
      _get(_getPrototypeOf(en.prototype), "updateWorldMatrix", this).call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return en;
}(Vt);

en.prototype.isCamera = !0;

var nn = /*#__PURE__*/function (_en) {
  _inherits(nn, _en);

  var _super14 = _createSuper(nn);

  function nn() {
    var _this17;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2e3;

    _classCallCheck(this, nn);

    _this17 = _super14.call(this), _this17.type = "PerspectiveCamera", _this17.fov = t, _this17.zoom = 1, _this17.near = n, _this17.far = i, _this17.focus = 10, _this17.aspect = e, _this17.view = null, _this17.filmGauge = 35, _this17.filmOffset = 0, _this17.updateProjectionMatrix();
    return _this17;
  }

  _createClass(nn, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(nn.prototype), "copy", this).call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    }
  }, {
    key: "setFocalLength",
    value: function setFocalLength(t) {
      var e = .5 * this.getFilmHeight() / t;
      this.fov = 2 * b * Math.atan(e), this.updateProjectionMatrix();
    }
  }, {
    key: "getFocalLength",
    value: function getFocalLength() {
      var t = Math.tan(.5 * w * this.fov);
      return .5 * this.getFilmHeight() / t;
    }
  }, {
    key: "getEffectiveFOV",
    value: function getEffectiveFOV() {
      return 2 * b * Math.atan(Math.tan(.5 * w * this.fov) / this.zoom);
    }
  }, {
    key: "getFilmWidth",
    value: function getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
  }, {
    key: "getFilmHeight",
    value: function getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
  }, {
    key: "setViewOffset",
    value: function setViewOffset(t, e, n, i, r, s) {
      this.aspect = t / e, null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var t = this.near;
      var e = t * Math.tan(.5 * w * this.fov) / this.zoom,
          n = 2 * e,
          i = this.aspect * n,
          r = -.5 * i;
      var s = this.view;

      if (null !== this.view && this.view.enabled) {
        var _t60 = s.fullWidth,
            _a12 = s.fullHeight;
        r += s.offsetX * i / _t60, e -= s.offsetY * n / _a12, i *= s.width / _t60, n *= s.height / _a12;
      }

      var a = this.filmOffset;
      0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(nn.prototype), "toJSON", this).call(this, t);

      return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
    }
  }]);

  return nn;
}(en);

nn.prototype.isPerspectiveCamera = !0;

var rn = /*#__PURE__*/function (_Vt3) {
  _inherits(rn, _Vt3);

  var _super15 = _createSuper(rn);

  function rn(t, e, n) {
    var _this18;

    _classCallCheck(this, rn);

    if (_this18 = _super15.call(this), _this18.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return _possibleConstructorReturn(_this18, void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."));
    _this18.renderTarget = n;
    var i = new nn(90, 1, t, e);
    i.layers = _this18.layers, i.up.set(0, -1, 0), i.lookAt(new H(1, 0, 0)), _this18.add(i);
    var r = new nn(90, 1, t, e);
    r.layers = _this18.layers, r.up.set(0, -1, 0), r.lookAt(new H(-1, 0, 0)), _this18.add(r);
    var s = new nn(90, 1, t, e);
    s.layers = _this18.layers, s.up.set(0, 0, 1), s.lookAt(new H(0, 1, 0)), _this18.add(s);
    var a = new nn(90, 1, t, e);
    a.layers = _this18.layers, a.up.set(0, 0, -1), a.lookAt(new H(0, -1, 0)), _this18.add(a);
    var o = new nn(90, 1, t, e);
    o.layers = _this18.layers, o.up.set(0, -1, 0), o.lookAt(new H(0, 0, 1)), _this18.add(o);
    var l = new nn(90, 1, t, e);
    l.layers = _this18.layers, l.up.set(0, -1, 0), l.lookAt(new H(0, 0, -1)), _this18.add(l);
    return _possibleConstructorReturn(_this18);
  }

  _createClass(rn, [{
    key: "update",
    value: function update(t, e) {
      null === this.parent && this.updateMatrixWorld();

      var n = this.renderTarget,
          _this$children = _slicedToArray(this.children, 6),
          i = _this$children[0],
          r = _this$children[1],
          s = _this$children[2],
          a = _this$children[3],
          o = _this$children[4],
          l = _this$children[5],
          c = t.xr.enabled,
          h = t.getRenderTarget();

      t.xr.enabled = !1;
      var u = n.texture.generateMipmaps;
      n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, o), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c;
    }
  }]);

  return rn;
}(Vt);

var sn = /*#__PURE__*/function (_N) {
  _inherits(sn, _N);

  var _super16 = _createSuper(sn);

  function sn(t, e, n, i, r, s, a, o, l, c) {
    var _this19;

    _classCallCheck(this, sn);

    _this19 = _super16.call(this, t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, n, i, r, s, a = void 0 !== a ? a : 1022, o, l, c), _this19._needsFlipEnvMap = !0, _this19.flipY = !1;
    return _this19;
  }

  _createClass(sn, [{
    key: "images",
    get: function get() {
      return this.image;
    },
    set: function set(t) {
      this.image = t;
    }
  }]);

  return sn;
}(N);

sn.prototype.isCubeTexture = !0;

var an = /*#__PURE__*/function (_k) {
  _inherits(an, _k);

  var _super17 = _createSuper(an);

  function an(t, e, n) {
    var _this20;

    _classCallCheck(this, an);

    Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), _this20 = _super17.call(this, t, t, e), e = e || {}, _this20.texture = new sn(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), _this20.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, _this20.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006, _this20.texture._needsFlipEnvMap = !1;
    return _this20;
  }

  _createClass(an, [{
    key: "fromEquirectangularTexture",
    value: function fromEquirectangularTexture(t, e) {
      this.texture.type = e.type, this.texture.format = 1023, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
      var n = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
      },
          i = new Xe(5, 5, 5),
          r = new tn({
        name: "CubemapFromEquirect",
        uniforms: Ke(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: 1,
        blending: 0
      });
      r.uniforms.tEquirect.value = e;
      var s = new Ye(i, r),
          a = e.minFilter;
      1008 === e.minFilter && (e.minFilter = 1006);
      return new rn(1, 10, this).update(t, s), e.minFilter = a, s.geometry.dispose(), s.material.dispose(), this;
    }
  }, {
    key: "clear",
    value: function clear(t, e, n, i) {
      var r = t.getRenderTarget();

      for (var _r47 = 0; _r47 < 6; _r47++) {
        t.setRenderTarget(this, _r47), t.clear(e, n, i);
      }

      t.setRenderTarget(r);
    }
  }]);

  return an;
}(k);

an.prototype.isWebGLCubeRenderTarget = !0;

var on = /*#__PURE__*/function (_N2) {
  _inherits(on, _N2);

  var _super18 = _createSuper(on);

  function on(t, e, n, i, r, s, a, o, l, c, h, u) {
    var _this21;

    _classCallCheck(this, on);

    _this21 = _super18.call(this, null, s, a, o, l, c, i, r, h, u), _this21.image = {
      data: t || null,
      width: e || 1,
      height: n || 1
    }, _this21.magFilter = void 0 !== l ? l : 1003, _this21.minFilter = void 0 !== c ? c : 1003, _this21.generateMipmaps = !1, _this21.flipY = !1, _this21.unpackAlignment = 1, _this21.needsUpdate = !0;
    return _this21;
  }

  return on;
}(N);

on.prototype.isDataTexture = !0;
var ln = new ht(),
    cn = new H();

var hn = /*#__PURE__*/function () {
  function hn() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Yt();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Yt();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Yt();
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Yt();
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Yt();
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Yt();

    _classCallCheck(this, hn);

    this.planes = [t, e, n, i, r, s];
  }

  _createClass(hn, [{
    key: "set",
    value: function set(t, e, n, i, r, s) {
      var a = this.planes;
      return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = this.planes;

      for (var _n64 = 0; _n64 < 6; _n64++) {
        e[_n64].copy(t.planes[_n64]);
      }

      return this;
    }
  }, {
    key: "setFromProjectionMatrix",
    value: function setFromProjectionMatrix(t) {
      var e = this.planes,
          n = t.elements,
          i = n[0],
          r = n[1],
          s = n[2],
          a = n[3],
          o = n[4],
          l = n[5],
          c = n[6],
          h = n[7],
          u = n[8],
          d = n[9],
          A = n[10],
          p = n[11],
          g = n[12],
          m = n[13],
          f = n[14],
          v = n[15];
      return e[0].setComponents(a - i, h - o, p - u, v - g).normalize(), e[1].setComponents(a + i, h + o, p + u, v + g).normalize(), e[2].setComponents(a + r, h + l, p + d, v + m).normalize(), e[3].setComponents(a - r, h - l, p - d, v - m).normalize(), e[4].setComponents(a - s, h - c, p - A, v - f).normalize(), e[5].setComponents(a + s, h + c, p + A, v + f).normalize(), this;
    }
  }, {
    key: "intersectsObject",
    value: function intersectsObject(t) {
      var e = t.geometry;
      return null === e.boundingSphere && e.computeBoundingSphere(), ln.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(ln);
    }
  }, {
    key: "intersectsSprite",
    value: function intersectsSprite(t) {
      return ln.center.set(0, 0, 0), ln.radius = .7071067811865476, ln.applyMatrix4(t.matrixWorld), this.intersectsSphere(ln);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      var e = this.planes,
          n = t.center,
          i = -t.radius;

      for (var _t61 = 0; _t61 < 6; _t61++) {
        if (e[_t61].distanceToPoint(n) < i) return !1;
      }

      return !0;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      var e = this.planes;

      for (var _n65 = 0; _n65 < 6; _n65++) {
        var _i54 = e[_n65];
        if (cn.x = _i54.normal.x > 0 ? t.max.x : t.min.x, cn.y = _i54.normal.y > 0 ? t.max.y : t.min.y, cn.z = _i54.normal.z > 0 ? t.max.z : t.min.z, _i54.distanceToPoint(cn) < 0) return !1;
      }

      return !0;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      var e = this.planes;

      for (var _n66 = 0; _n66 < 6; _n66++) {
        if (e[_n66].distanceToPoint(t) < 0) return !1;
      }

      return !0;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return hn;
}();

function un() {
  var t = null,
      e = !1,
      n = null,
      i = null;

  function r(e, s) {
    n(e, s), i = t.requestAnimationFrame(r);
  }

  return {
    start: function start() {
      !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0);
    },
    stop: function stop() {
      t.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function setAnimationLoop(t) {
      n = t;
    },
    setContext: function setContext(e) {
      t = e;
    }
  };
}

function dn(t, e) {
  var n = e.isWebGL2,
      i = new WeakMap();
  return {
    get: function get(t) {
      return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
    },
    remove: function remove(e) {
      e.isInterleavedBufferAttribute && (e = e.data);
      var n = i.get(e);
      n && (t.deleteBuffer(n.buffer), i.delete(e));
    },
    update: function update(e, r) {
      if (e.isGLBufferAttribute) {
        var _t62 = i.get(e);

        return void ((!_t62 || _t62.version < e.version) && i.set(e, {
          buffer: e.buffer,
          type: e.type,
          bytesPerElement: e.elementSize,
          version: e.version
        }));
      }

      e.isInterleavedBufferAttribute && (e = e.data);
      var s = i.get(e);
      void 0 === s ? i.set(e, function (e, i) {
        var r = e.array,
            s = e.usage,
            a = t.createBuffer();
        t.bindBuffer(i, a), t.bufferData(i, r, s), e.onUploadCallback();
        var o = 5126;
        return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : r instanceof Uint8Array && (o = 5121), {
          buffer: a,
          type: o,
          bytesPerElement: r.BYTES_PER_ELEMENT,
          version: e.version
        };
      }(e, r)) : s.version < e.version && (!function (e, i, r) {
        var s = i.array,
            a = i.updateRange;
        t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1);
      }(s.buffer, e, r), s.version = e.version);
    }
  };
}

var An = /*#__PURE__*/function (_Te2) {
  _inherits(An, _Te2);

  var _super19 = _createSuper(An);

  function An() {
    var _this22;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, An);

    _this22 = _super19.call(this), _this22.type = "PlaneGeometry", _this22.parameters = {
      width: t,
      height: e,
      widthSegments: n,
      heightSegments: i
    };
    var r = t / 2,
        s = e / 2,
        a = Math.floor(n),
        o = Math.floor(i),
        l = a + 1,
        c = o + 1,
        h = t / a,
        u = e / o,
        d = [],
        A = [],
        p = [],
        g = [];

    for (var _t63 = 0; _t63 < c; _t63++) {
      var _e50 = _t63 * u - s;

      for (var _n67 = 0; _n67 < l; _n67++) {
        var _i55 = _n67 * h - r;

        A.push(_i55, -_e50, 0), p.push(0, 0, 1), g.push(_n67 / a), g.push(1 - _t63 / o);
      }
    }

    for (var _t64 = 0; _t64 < o; _t64++) {
      for (var _e51 = 0; _e51 < a; _e51++) {
        var _n68 = _e51 + l * _t64,
            _i56 = _e51 + l * (_t64 + 1),
            _r48 = _e51 + 1 + l * (_t64 + 1),
            _s13 = _e51 + 1 + l * _t64;

        d.push(_n68, _i56, _s13), d.push(_i56, _r48, _s13);
      }
    }

    _this22.setIndex(d), _this22.setAttribute("position", new xe(A, 3)), _this22.setAttribute("normal", new xe(p, 3)), _this22.setAttribute("uv", new xe(g, 2));
    return _this22;
  }

  return An;
}(Te);

var pn = {
  alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
  alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
  alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
  aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
  aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
  begin_vertex: "vec3 transformed = vec3( position );",
  beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
  bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
  bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
  clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
  clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
  clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
  clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
  color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
  color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
  color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
  color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
  common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
  cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
  defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
  displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
  displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
  emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
  emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
  encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
  envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
  envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
  envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
  envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
  envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
  envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
  fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
  fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
  fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
  fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
  gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
  lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
  lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
  lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
  lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
  lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
  lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
  lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
  lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
  lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
  lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
  lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
  lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
  lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
  logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
  logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
  logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
  logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
  map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
  map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
  map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
  map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
  metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
  metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
  morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
  morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
  morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
  normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
  normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
  normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
  clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
  clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
  clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
  packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
  premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
  project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
  dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
  dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
  roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
  roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
  shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
  shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
  shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
  shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
  skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
  skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
  skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
  skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
  specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
  specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
  tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
  tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
  transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
  transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
  uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
  uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
  uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
  uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
  uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
  uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
  worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
  background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
  background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
  cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
  cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
  depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
  depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
  distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
  distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
  equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
  equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
  linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
  linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
  meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
  meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
  meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
  normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
  points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
  points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
  shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
  shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
  sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
},
    gn = {
  common: {
    diffuse: {
      value: new pe(15658734)
    },
    opacity: {
      value: 1
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new D()
    },
    uv2Transform: {
      value: new D()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1
    },
    refractionRatio: {
      value: .98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new R(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 25e-5
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2e3
    },
    fogColor: {
      value: new pe(16777215)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    },
    ltc_1: {
      value: null
    },
    ltc_2: {
      value: null
    }
  },
  points: {
    diffuse: {
      value: new pe(15658734)
    },
    opacity: {
      value: 1
    },
    size: {
      value: 1
    },
    scale: {
      value: 1
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new D()
    }
  },
  sprite: {
    diffuse: {
      value: new pe(15658734)
    },
    opacity: {
      value: 1
    },
    center: {
      value: new R(.5, .5)
    },
    rotation: {
      value: 0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new D()
    }
  }
},
    mn = {
  basic: {
    uniforms: Ze([gn.common, gn.specularmap, gn.envmap, gn.aomap, gn.lightmap, gn.fog]),
    vertexShader: pn.meshbasic_vert,
    fragmentShader: pn.meshbasic_frag
  },
  lambert: {
    uniforms: Ze([gn.common, gn.specularmap, gn.envmap, gn.aomap, gn.lightmap, gn.emissivemap, gn.fog, gn.lights, {
      emissive: {
        value: new pe(0)
      }
    }]),
    vertexShader: pn.meshlambert_vert,
    fragmentShader: pn.meshlambert_frag
  },
  phong: {
    uniforms: Ze([gn.common, gn.specularmap, gn.envmap, gn.aomap, gn.lightmap, gn.emissivemap, gn.bumpmap, gn.normalmap, gn.displacementmap, gn.fog, gn.lights, {
      emissive: {
        value: new pe(0)
      },
      specular: {
        value: new pe(1118481)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: pn.meshphong_vert,
    fragmentShader: pn.meshphong_frag
  },
  standard: {
    uniforms: Ze([gn.common, gn.envmap, gn.aomap, gn.lightmap, gn.emissivemap, gn.bumpmap, gn.normalmap, gn.displacementmap, gn.roughnessmap, gn.metalnessmap, gn.fog, gn.lights, {
      emissive: {
        value: new pe(0)
      },
      roughness: {
        value: 1
      },
      metalness: {
        value: 0
      },
      envMapIntensity: {
        value: 1
      }
    }]),
    vertexShader: pn.meshphysical_vert,
    fragmentShader: pn.meshphysical_frag
  },
  toon: {
    uniforms: Ze([gn.common, gn.aomap, gn.lightmap, gn.emissivemap, gn.bumpmap, gn.normalmap, gn.displacementmap, gn.gradientmap, gn.fog, gn.lights, {
      emissive: {
        value: new pe(0)
      }
    }]),
    vertexShader: pn.meshtoon_vert,
    fragmentShader: pn.meshtoon_frag
  },
  matcap: {
    uniforms: Ze([gn.common, gn.bumpmap, gn.normalmap, gn.displacementmap, gn.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: pn.meshmatcap_vert,
    fragmentShader: pn.meshmatcap_frag
  },
  points: {
    uniforms: Ze([gn.points, gn.fog]),
    vertexShader: pn.points_vert,
    fragmentShader: pn.points_frag
  },
  dashed: {
    uniforms: Ze([gn.common, gn.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: pn.linedashed_vert,
    fragmentShader: pn.linedashed_frag
  },
  depth: {
    uniforms: Ze([gn.common, gn.displacementmap]),
    vertexShader: pn.depth_vert,
    fragmentShader: pn.depth_frag
  },
  normal: {
    uniforms: Ze([gn.common, gn.bumpmap, gn.normalmap, gn.displacementmap, {
      opacity: {
        value: 1
      }
    }]),
    vertexShader: pn.normal_vert,
    fragmentShader: pn.normal_frag
  },
  sprite: {
    uniforms: Ze([gn.sprite, gn.fog]),
    vertexShader: pn.sprite_vert,
    fragmentShader: pn.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new D()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: pn.background_vert,
    fragmentShader: pn.background_frag
  },
  cube: {
    uniforms: Ze([gn.envmap, {
      opacity: {
        value: 1
      }
    }]),
    vertexShader: pn.cube_vert,
    fragmentShader: pn.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: pn.equirect_vert,
    fragmentShader: pn.equirect_frag
  },
  distanceRGBA: {
    uniforms: Ze([gn.common, gn.displacementmap, {
      referencePosition: {
        value: new H()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1e3
      }
    }]),
    vertexShader: pn.distanceRGBA_vert,
    fragmentShader: pn.distanceRGBA_frag
  },
  shadow: {
    uniforms: Ze([gn.lights, gn.fog, {
      color: {
        value: new pe(0)
      },
      opacity: {
        value: 1
      }
    }]),
    vertexShader: pn.shadow_vert,
    fragmentShader: pn.shadow_frag
  }
};

function fn(t, e, n, i, r) {
  var s = new pe(0);
  var a,
      o,
      l = 0,
      c = null,
      h = 0,
      u = null;

  function d(t, e) {
    n.buffers.color.setClear(t.r, t.g, t.b, e, r);
  }

  return {
    getClearColor: function getClearColor() {
      return s;
    },
    setClearColor: function setClearColor(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      s.set(t), l = e, d(s, l);
    },
    getClearAlpha: function getClearAlpha() {
      return l;
    },
    setClearAlpha: function setClearAlpha(t) {
      l = t, d(s, l);
    },
    render: function render(n, r, A, p) {
      var g = !0 === r.isScene ? r.background : null;
      g && g.isTexture && (g = e.get(g));
      var m = t.xr,
          f = m.getSession && m.getSession();
      f && "additive" === f.environmentBlendMode && (g = null), null === g ? d(s, l) : g && g.isColor && (d(g, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || 306 === g.mapping) ? (void 0 === o && (o = new Ye(new Xe(1, 1, 1), new tn({
        name: "BackgroundCubeMaterial",
        uniforms: Ke(mn.cube.uniforms),
        vertexShader: mn.cube.vertexShader,
        fragmentShader: mn.cube.fragmentShader,
        side: 1,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })), o.geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (t, e, n) {
        this.matrixWorld.copyPosition(n.matrixWorld);
      }, Object.defineProperty(o.material, "envMap", {
        get: function get() {
          return this.uniforms.envMap.value;
        }
      }), i.update(o)), o.material.uniforms.envMap.value = g, o.material.uniforms.flipEnvMap.value = g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1, c === g && h === g.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = g, h = g.version, u = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : g && g.isTexture && (void 0 === a && (a = new Ye(new An(2, 2), new tn({
        name: "BackgroundMaterial",
        uniforms: Ke(mn.background.uniforms),
        vertexShader: mn.background.vertexShader,
        fragmentShader: mn.background.fragmentShader,
        side: 0,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
        get: function get() {
          return this.uniforms.t2D.value;
        }
      }), i.update(a)), a.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), a.material.uniforms.uvTransform.value.copy(g.matrix), c === g && h === g.version && u === t.toneMapping || (a.material.needsUpdate = !0, c = g, h = g.version, u = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null));
    }
  };
}

function vn(t, e, n, i) {
  var r = t.getParameter(34921),
      s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
      a = i.isWebGL2 || null !== s,
      o = {},
      l = d(null);
  var c = l;

  function h(e) {
    return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
  }

  function u(e) {
    return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
  }

  function d(t) {
    var e = [],
        n = [],
        i = [];

    for (var _t65 = 0; _t65 < r; _t65++) {
      e[_t65] = 0, n[_t65] = 0, i[_t65] = 0;
    }

    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: e,
      enabledAttributes: n,
      attributeDivisors: i,
      object: t,
      attributes: {},
      index: null
    };
  }

  function A() {
    var t = c.newAttributes;

    for (var _e52 = 0, _n69 = t.length; _e52 < _n69; _e52++) {
      t[_e52] = 0;
    }
  }

  function p(t) {
    g(t, 0);
  }

  function g(n, r) {
    var s = c.newAttributes,
        a = c.enabledAttributes,
        o = c.attributeDivisors;

    if (s[n] = 1, 0 === a[n] && (t.enableVertexAttribArray(n), a[n] = 1), o[n] !== r) {
      (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r;
    }
  }

  function m() {
    var e = c.newAttributes,
        n = c.enabledAttributes;

    for (var _i57 = 0, _r49 = n.length; _i57 < _r49; _i57++) {
      n[_i57] !== e[_i57] && (t.disableVertexAttribArray(_i57), n[_i57] = 0);
    }
  }

  function f(e, n, r, s, a, o) {
    !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, a, o) : t.vertexAttribIPointer(e, n, r, a, o);
  }

  function v() {
    y(), c !== l && (c = l, h(c.object));
  }

  function y() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }

  return {
    setup: function setup(r, l, u, v, y) {
      var E = !1;

      if (a) {
        var _e53 = function (e, n, r) {
          var a = !0 === r.wireframe;
          var l = o[e.id];
          void 0 === l && (l = {}, o[e.id] = l);
          var c = l[n.id];
          void 0 === c && (c = {}, l[n.id] = c);
          var h = c[a];
          void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[a] = h);
          return h;
        }(v, u, l);

        c !== _e53 && (c = _e53, h(c.object)), E = function (t, e) {
          var n = c.attributes,
              i = t.attributes;
          var r = 0;

          for (var _t66 in i) {
            var _e54 = n[_t66],
                _s14 = i[_t66];
            if (void 0 === _e54) return !0;
            if (_e54.attribute !== _s14) return !0;
            if (_e54.data !== _s14.data) return !0;
            r++;
          }

          return c.attributesNum !== r || c.index !== e;
        }(v, y), E && function (t, e) {
          var n = {},
              i = t.attributes;
          var r = 0;

          for (var _t67 in i) {
            var _e55 = i[_t67],
                _s15 = {};
            _s15.attribute = _e55, _e55.data && (_s15.data = _e55.data), n[_t67] = _s15, r++;
          }

          c.attributes = n, c.attributesNum = r, c.index = e;
        }(v, y);
      } else {
        var _t68 = !0 === l.wireframe;

        c.geometry === v.id && c.program === u.id && c.wireframe === _t68 || (c.geometry = v.id, c.program = u.id, c.wireframe = _t68, E = !0);
      }

      !0 === r.isInstancedMesh && (E = !0), null !== y && n.update(y, 34963), E && (!function (r, s, a, o) {
        if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
        A();
        var l = o.attributes,
            c = a.getAttributes(),
            h = s.defaultAttributeValues;

        for (var _e56 in c) {
          var _i58 = c[_e56];

          if (_i58 >= 0) {
            var _s16 = l[_e56];

            if (void 0 !== _s16) {
              var _e57 = _s16.normalized,
                  _r50 = _s16.itemSize,
                  _a13 = n.get(_s16);

              if (void 0 === _a13) continue;
              var _l11 = _a13.buffer,
                  _c8 = _a13.type,
                  _h6 = _a13.bytesPerElement;

              if (_s16.isInterleavedBufferAttribute) {
                var _n70 = _s16.data,
                    _a14 = _n70.stride,
                    _u8 = _s16.offset;
                _n70 && _n70.isInstancedInterleavedBuffer ? (g(_i58, _n70.meshPerAttribute), void 0 === o._maxInstanceCount && (o._maxInstanceCount = _n70.meshPerAttribute * _n70.count)) : p(_i58), t.bindBuffer(34962, _l11), f(_i58, _r50, _c8, _e57, _a14 * _h6, _u8 * _h6);
              } else _s16.isInstancedBufferAttribute ? (g(_i58, _s16.meshPerAttribute), void 0 === o._maxInstanceCount && (o._maxInstanceCount = _s16.meshPerAttribute * _s16.count)) : p(_i58), t.bindBuffer(34962, _l11), f(_i58, _r50, _c8, _e57, 0, 0);
            } else if ("instanceMatrix" === _e56) {
              var _e58 = n.get(r.instanceMatrix);

              if (void 0 === _e58) continue;
              var _s17 = _e58.buffer,
                  _a15 = _e58.type;
              g(_i58 + 0, 1), g(_i58 + 1, 1), g(_i58 + 2, 1), g(_i58 + 3, 1), t.bindBuffer(34962, _s17), t.vertexAttribPointer(_i58 + 0, 4, _a15, !1, 64, 0), t.vertexAttribPointer(_i58 + 1, 4, _a15, !1, 64, 16), t.vertexAttribPointer(_i58 + 2, 4, _a15, !1, 64, 32), t.vertexAttribPointer(_i58 + 3, 4, _a15, !1, 64, 48);
            } else if ("instanceColor" === _e56) {
              var _e59 = n.get(r.instanceColor);

              if (void 0 === _e59) continue;
              var _s18 = _e59.buffer,
                  _a16 = _e59.type;
              g(_i58, 1), t.bindBuffer(34962, _s18), t.vertexAttribPointer(_i58, 3, _a16, !1, 12, 0);
            } else if (void 0 !== h) {
              var _n71 = h[_e56];
              if (void 0 !== _n71) switch (_n71.length) {
                case 2:
                  t.vertexAttrib2fv(_i58, _n71);
                  break;

                case 3:
                  t.vertexAttrib3fv(_i58, _n71);
                  break;

                case 4:
                  t.vertexAttrib4fv(_i58, _n71);
                  break;

                default:
                  t.vertexAttrib1fv(_i58, _n71);
              }
            }
          }
        }

        m();
      }(r, l, u, v), null !== y && t.bindBuffer(34963, n.get(y).buffer));
    },
    reset: v,
    resetDefaultState: y,
    dispose: function dispose() {
      v();

      for (var _t69 in o) {
        var _e60 = o[_t69];

        for (var _t70 in _e60) {
          var _n72 = _e60[_t70];

          for (var _t71 in _n72) {
            u(_n72[_t71].object), delete _n72[_t71];
          }

          delete _e60[_t70];
        }

        delete o[_t69];
      }
    },
    releaseStatesOfGeometry: function releaseStatesOfGeometry(t) {
      if (void 0 === o[t.id]) return;
      var e = o[t.id];

      for (var _t72 in e) {
        var _n73 = e[_t72];

        for (var _t73 in _n73) {
          u(_n73[_t73].object), delete _n73[_t73];
        }

        delete e[_t72];
      }

      delete o[t.id];
    },
    releaseStatesOfProgram: function releaseStatesOfProgram(t) {
      for (var _e61 in o) {
        var _n74 = o[_e61];
        if (void 0 === _n74[t.id]) continue;
        var _i59 = _n74[t.id];

        for (var _t74 in _i59) {
          u(_i59[_t74].object), delete _i59[_t74];
        }

        delete _n74[t.id];
      }
    },
    initAttributes: A,
    enableAttribute: p,
    disableUnusedAttributes: m
  };
}

function yn(t, e, n, i) {
  var r = i.isWebGL2;
  var s;
  this.setMode = function (t) {
    s = t;
  }, this.render = function (e, i) {
    t.drawArrays(s, e, i), n.update(i, s, 1);
  }, this.renderInstances = function (i, a, o) {
    if (0 === o) return;
    var l, c;
    if (r) l = t, c = "drawArraysInstanced";else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l[c](s, i, a, o), n.update(a, s, o);
  };
}

function En(t, e, n) {
  var i;

  function r(e) {
    if ("highp" === e) {
      if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
      e = "mediump";
    }

    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }

  var s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
  var a = void 0 !== n.precision ? n.precision : "highp";
  var o = r(a);
  o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
  var l = !0 === n.logarithmicDepthBuffer,
      c = t.getParameter(34930),
      h = t.getParameter(35660),
      u = t.getParameter(3379),
      d = t.getParameter(34076),
      A = t.getParameter(34921),
      p = t.getParameter(36347),
      g = t.getParameter(36348),
      m = t.getParameter(36349),
      f = h > 0,
      v = s || e.has("OES_texture_float");
  return {
    isWebGL2: s,
    getMaxAnisotropy: function getMaxAnisotropy() {
      if (void 0 !== i) return i;

      if (!0 === e.has("EXT_texture_filter_anisotropic")) {
        var _n75 = e.get("EXT_texture_filter_anisotropic");

        i = t.getParameter(_n75.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else i = 0;

      return i;
    },
    getMaxPrecision: r,
    precision: a,
    logarithmicDepthBuffer: l,
    maxTextures: c,
    maxVertexTextures: h,
    maxTextureSize: u,
    maxCubemapSize: d,
    maxAttributes: A,
    maxVertexUniforms: p,
    maxVaryings: g,
    maxFragmentUniforms: m,
    vertexTextures: f,
    floatFragmentTextures: v,
    floatVertexTextures: f && v,
    maxSamples: s ? t.getParameter(36183) : 0
  };
}

function xn(t) {
  var e = this;
  var n = null,
      i = 0,
      r = !1,
      s = !1;
  var a = new Yt(),
      o = new D(),
      l = {
    value: null,
    needsUpdate: !1
  };

  function c() {
    l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }

  function h(t, n, i, r) {
    var s = null !== t ? t.length : 0;
    var c = null;

    if (0 !== s) {
      if (c = l.value, !0 !== r || null === c) {
        var _e62 = i + 4 * s,
            _r51 = n.matrixWorldInverse;

        o.getNormalMatrix(_r51), (null === c || c.length < _e62) && (c = new Float32Array(_e62));

        for (var _e63 = 0, _n76 = i; _e63 !== s; ++_e63, _n76 += 4) {
          a.copy(t[_e63]).applyMatrix4(_r51, o), a.normal.toArray(c, _n76), c[_n76 + 3] = a.constant;
        }
      }

      l.value = c, l.needsUpdate = !0;
    }

    return e.numPlanes = s, e.numIntersection = 0, c;
  }

  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, s) {
    var a = 0 !== t.length || e || 0 !== i || r;
    return r = e, n = h(t, s, 0), i = t.length, a;
  }, this.beginShadows = function () {
    s = !0, h(null);
  }, this.endShadows = function () {
    s = !1, c();
  }, this.setState = function (e, a, o) {
    var u = e.clippingPlanes,
        d = e.clipIntersection,
        A = e.clipShadows,
        p = t.get(e);
    if (!r || null === u || 0 === u.length || s && !A) s ? h(null) : c();else {
      var _t75 = s ? 0 : i,
          _e64 = 4 * _t75;

      var _r52 = p.clippingState || null;

      l.value = _r52, _r52 = h(u, a, _e64, o);

      for (var _t76 = 0; _t76 !== _e64; ++_t76) {
        _r52[_t76] = n[_t76];
      }

      p.clippingState = _r52, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += _t75;
    }
  };
}

function wn(t) {
  var e = new WeakMap();

  function n(t, e) {
    return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t;
  }

  function i(t) {
    var n = t.target;
    n.removeEventListener("dispose", i);
    var r = e.get(n);
    void 0 !== r && (e.delete(n), r.dispose());
  }

  return {
    get: function get(r) {
      if (r && r.isTexture) {
        var _s19 = r.mapping;

        if (303 === _s19 || 304 === _s19) {
          if (e.has(r)) {
            return n(e.get(r).texture, r.mapping);
          }

          {
            var _s20 = r.image;

            if (_s20 && _s20.height > 0) {
              var _a17 = t.getRenderTarget(),
                  _o11 = new an(_s20.height / 2);

              return _o11.fromEquirectangularTexture(t, r), e.set(r, _o11), t.setRenderTarget(_a17), r.addEventListener("dispose", i), n(_o11.texture, r.mapping);
            }

            return null;
          }
        }
      }

      return r;
    },
    dispose: function dispose() {
      e = new WeakMap();
    }
  };
}

function bn(t) {
  var e = {};

  function n(n) {
    if (void 0 !== e[n]) return e[n];
    var i;

    switch (n) {
      case "WEBGL_depth_texture":
        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;

      case "EXT_texture_filter_anisotropic":
        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;

      case "WEBGL_compressed_texture_s3tc":
        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;

      case "WEBGL_compressed_texture_pvrtc":
        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;

      default:
        i = t.getExtension(n);
    }

    return e[n] = i, i;
  }

  return {
    has: function has(t) {
      return null !== n(t);
    },
    init: function init(t) {
      t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float");
    },
    get: function get(t) {
      var e = n(t);
      return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e;
    }
  };
}

function _n(t, e, n, i) {
  var r = {},
      s = new WeakMap();

  function a(t) {
    var o = t.target;
    null !== o.index && e.remove(o.index);

    for (var _t77 in o.attributes) {
      e.remove(o.attributes[_t77]);
    }

    o.removeEventListener("dispose", a), delete r[o.id];
    var l = s.get(o);
    l && (e.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--;
  }

  function o(t) {
    var n = [],
        i = t.index,
        r = t.attributes.position;
    var a = 0;

    if (null !== i) {
      var _t78 = i.array;
      a = i.version;

      for (var _e65 = 0, _i60 = _t78.length; _e65 < _i60; _e65 += 3) {
        var _i61 = _t78[_e65 + 0],
            _r53 = _t78[_e65 + 1],
            _s21 = _t78[_e65 + 2];
        n.push(_i61, _r53, _r53, _s21, _s21, _i61);
      }
    } else {
      var _t79 = r.array;
      a = r.version;

      for (var _e66 = 0, _i62 = _t79.length / 3 - 1; _e66 < _i62; _e66 += 3) {
        var _t80 = _e66 + 0,
            _i63 = _e66 + 1,
            _r54 = _e66 + 2;

        n.push(_t80, _i63, _i63, _r54, _r54, _t80);
      }
    }

    var o = new (we(n) > 65535 ? Ee : ye)(n, 1);
    o.version = a;
    var l = s.get(t);
    l && e.remove(l), s.set(t, o);
  }

  return {
    get: function get(t, e) {
      return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, n.memory.geometries++), e;
    },
    update: function update(t) {
      var n = t.attributes;

      for (var _t81 in n) {
        e.update(n[_t81], 34962);
      }

      var i = t.morphAttributes;

      for (var _t82 in i) {
        var _n77 = i[_t82];

        for (var _t83 = 0, _i64 = _n77.length; _t83 < _i64; _t83++) {
          e.update(_n77[_t83], 34962);
        }
      }
    },
    getWireframeAttribute: function getWireframeAttribute(t) {
      var e = s.get(t);

      if (e) {
        var _n78 = t.index;
        null !== _n78 && e.version < _n78.version && o(t);
      } else o(t);

      return s.get(t);
    }
  };
}

function In(t, e, n, i) {
  var r = i.isWebGL2;
  var s, a, o;
  this.setMode = function (t) {
    s = t;
  }, this.setIndex = function (t) {
    a = t.type, o = t.bytesPerElement;
  }, this.render = function (e, i) {
    t.drawElements(s, i, a, e * o), n.update(i, s, 1);
  }, this.renderInstances = function (i, l, c) {
    if (0 === c) return;
    var h, u;
    if (r) h = t, u = "drawElementsInstanced";else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h[u](s, l, a, i * o, c), n.update(l, s, c);
  };
}

function Cn(t) {
  var e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  return {
    memory: {
      geometries: 0,
      textures: 0
    },
    render: e,
    programs: null,
    autoReset: !0,
    reset: function reset() {
      e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
    },
    update: function update(t, n, i) {
      switch (e.calls++, n) {
        case 4:
          e.triangles += i * (t / 3);
          break;

        case 1:
          e.lines += i * (t / 2);
          break;

        case 3:
          e.lines += i * (t - 1);
          break;

        case 2:
          e.lines += i * t;
          break;

        case 0:
          e.points += i * t;
          break;

        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", n);
      }
    }
  };
}

function Mn(t, e) {
  return t[0] - e[0];
}

function Sn(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}

function Bn(t) {
  var e = {},
      n = new Float32Array(8),
      i = [];

  for (var _t84 = 0; _t84 < 8; _t84++) {
    i[_t84] = [_t84, 0];
  }

  return {
    update: function update(r, s, a, o) {
      var l = r.morphTargetInfluences,
          c = void 0 === l ? 0 : l.length;
      var h = e[s.id];

      if (void 0 === h) {
        h = [];

        for (var _t85 = 0; _t85 < c; _t85++) {
          h[_t85] = [_t85, 0];
        }

        e[s.id] = h;
      }

      for (var _t86 = 0; _t86 < c; _t86++) {
        var _e67 = h[_t86];
        _e67[0] = _t86, _e67[1] = l[_t86];
      }

      h.sort(Sn);

      for (var _t87 = 0; _t87 < 8; _t87++) {
        _t87 < c && h[_t87][1] ? (i[_t87][0] = h[_t87][0], i[_t87][1] = h[_t87][1]) : (i[_t87][0] = Number.MAX_SAFE_INTEGER, i[_t87][1] = 0);
      }

      i.sort(Mn);
      var u = a.morphTargets && s.morphAttributes.position,
          d = a.morphNormals && s.morphAttributes.normal;
      var A = 0;

      for (var _t88 = 0; _t88 < 8; _t88++) {
        var _e68 = i[_t88],
            _r55 = _e68[0],
            _a18 = _e68[1];
        _r55 !== Number.MAX_SAFE_INTEGER && _a18 ? (u && s.getAttribute("morphTarget" + _t88) !== u[_r55] && s.setAttribute("morphTarget" + _t88, u[_r55]), d && s.getAttribute("morphNormal" + _t88) !== d[_r55] && s.setAttribute("morphNormal" + _t88, d[_r55]), n[_t88] = _a18, A += _a18) : (u && !0 === s.hasAttribute("morphTarget" + _t88) && s.deleteAttribute("morphTarget" + _t88), d && !0 === s.hasAttribute("morphNormal" + _t88) && s.deleteAttribute("morphNormal" + _t88), n[_t88] = 0);
      }

      var p = s.morphTargetsRelative ? 1 : 1 - A;
      o.getUniforms().setValue(t, "morphTargetBaseInfluence", p), o.getUniforms().setValue(t, "morphTargetInfluences", n);
    }
  };
}

function Tn(t, e, n, i) {
  var r = new WeakMap();

  function s(t) {
    var e = t.target;
    e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor);
  }

  return {
    update: function update(t) {
      var a = i.render.frame,
          o = t.geometry,
          l = e.get(t, o);
      return r.get(l) !== a && (e.update(l), r.set(l, a)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l;
    },
    dispose: function dispose() {
      r = new WeakMap();
    }
  };
}

mn.physical = {
  uniforms: Ze([mn.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatNormalScale: {
      value: new R(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    },
    sheen: {
      value: new pe(0)
    },
    transmission: {
      value: 0
    },
    transmissionMap: {
      value: null
    }
  }]),
  vertexShader: pn.meshphysical_vert,
  fragmentShader: pn.meshphysical_frag
};

var Ln = /*#__PURE__*/function (_N3) {
  _inherits(Ln, _N3);

  var _super20 = _createSuper(Ln);

  function Ln() {
    var _this23;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, Ln);

    _this23 = _super20.call(this, null), _this23.image = {
      data: t,
      width: e,
      height: n,
      depth: i
    }, _this23.magFilter = 1003, _this23.minFilter = 1003, _this23.wrapR = 1001, _this23.generateMipmaps = !1, _this23.flipY = !1, _this23.unpackAlignment = 1, _this23.needsUpdate = !0;
    return _this23;
  }

  return Ln;
}(N);

Ln.prototype.isDataTexture2DArray = !0;

var Rn = /*#__PURE__*/function (_N4) {
  _inherits(Rn, _N4);

  var _super21 = _createSuper(Rn);

  function Rn() {
    var _this24;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, Rn);

    _this24 = _super21.call(this, null), _this24.image = {
      data: t,
      width: e,
      height: n,
      depth: i
    }, _this24.magFilter = 1003, _this24.minFilter = 1003, _this24.wrapR = 1001, _this24.generateMipmaps = !1, _this24.flipY = !1, _this24.unpackAlignment = 1, _this24.needsUpdate = !0;
    return _this24;
  }

  return Rn;
}(N);

Rn.prototype.isDataTexture3D = !0;
var Dn = new N(),
    Qn = new Ln(),
    Pn = new Rn(),
    Fn = new sn(),
    Nn = [],
    Un = [],
    Gn = new Float32Array(16),
    kn = new Float32Array(9),
    On = new Float32Array(4);

function Hn(t, e, n) {
  var i = t[0];
  if (i <= 0 || i > 0) return t;
  var r = e * n;
  var s = Nn[r];

  if (void 0 === s && (s = new Float32Array(r), Nn[r] = s), 0 !== e) {
    i.toArray(s, 0);

    for (var _i65 = 1, _r56 = 0; _i65 !== e; ++_i65) {
      _r56 += n, t[_i65].toArray(s, _r56);
    }
  }

  return s;
}

function zn(t, e) {
  if (t.length !== e.length) return !1;

  for (var _n79 = 0, _i66 = t.length; _n79 < _i66; _n79++) {
    if (t[_n79] !== e[_n79]) return !1;
  }

  return !0;
}

function Vn(t, e) {
  for (var _n80 = 0, _i67 = e.length; _n80 < _i67; _n80++) {
    t[_n80] = e[_n80];
  }
}

function Wn(t, e) {
  var n = Un[e];
  void 0 === n && (n = new Int32Array(e), Un[e] = n);

  for (var _i68 = 0; _i68 !== e; ++_i68) {
    n[_i68] = t.allocateTextureUnit();
  }

  return n;
}

function qn(t, e) {
  var n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
}

function jn(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);else {
    if (zn(n, e)) return;
    t.uniform2fv(this.addr, e), Vn(n, e);
  }
}

function Yn(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);else {
    if (zn(n, e)) return;
    t.uniform3fv(this.addr, e), Vn(n, e);
  }
}

function Jn(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);else {
    if (zn(n, e)) return;
    t.uniform4fv(this.addr, e), Vn(n, e);
  }
}

function Xn(t, e) {
  var n = this.cache,
      i = e.elements;

  if (void 0 === i) {
    if (zn(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), Vn(n, e);
  } else {
    if (zn(n, i)) return;
    On.set(i), t.uniformMatrix2fv(this.addr, !1, On), Vn(n, i);
  }
}

function Kn(t, e) {
  var n = this.cache,
      i = e.elements;

  if (void 0 === i) {
    if (zn(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), Vn(n, e);
  } else {
    if (zn(n, i)) return;
    kn.set(i), t.uniformMatrix3fv(this.addr, !1, kn), Vn(n, i);
  }
}

function Zn(t, e) {
  var n = this.cache,
      i = e.elements;

  if (void 0 === i) {
    if (zn(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), Vn(n, e);
  } else {
    if (zn(n, i)) return;
    Gn.set(i), t.uniformMatrix4fv(this.addr, !1, Gn), Vn(n, i);
  }
}

function $n(t, e) {
  var n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
}

function ti(t, e) {
  var n = this.cache;
  zn(n, e) || (t.uniform2iv(this.addr, e), Vn(n, e));
}

function ei(t, e) {
  var n = this.cache;
  zn(n, e) || (t.uniform3iv(this.addr, e), Vn(n, e));
}

function ni(t, e) {
  var n = this.cache;
  zn(n, e) || (t.uniform4iv(this.addr, e), Vn(n, e));
}

function ii(t, e) {
  var n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
}

function ri(t, e) {
  var n = this.cache;
  zn(n, e) || (t.uniform2uiv(this.addr, e), Vn(n, e));
}

function si(t, e) {
  var n = this.cache;
  zn(n, e) || (t.uniform3uiv(this.addr, e), Vn(n, e));
}

function ai(t, e) {
  var n = this.cache;
  zn(n, e) || (t.uniform4uiv(this.addr, e), Vn(n, e));
}

function oi(t, e, n) {
  var i = this.cache,
      r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || Dn, r);
}

function li(t, e, n) {
  var i = this.cache,
      r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Pn, r);
}

function ci(t, e, n) {
  var i = this.cache,
      r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Fn, r);
}

function hi(t, e, n) {
  var i = this.cache,
      r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Qn, r);
}

function ui(t, e) {
  t.uniform1fv(this.addr, e);
}

function di(t, e) {
  var n = Hn(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}

function Ai(t, e) {
  var n = Hn(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}

function pi(t, e) {
  var n = Hn(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}

function gi(t, e) {
  var n = Hn(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}

function mi(t, e) {
  var n = Hn(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}

function fi(t, e) {
  var n = Hn(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}

function vi(t, e) {
  t.uniform1iv(this.addr, e);
}

function yi(t, e) {
  t.uniform2iv(this.addr, e);
}

function Ei(t, e) {
  t.uniform3iv(this.addr, e);
}

function xi(t, e) {
  t.uniform4iv(this.addr, e);
}

function wi(t, e) {
  t.uniform1uiv(this.addr, e);
}

function bi(t, e) {
  t.uniform2uiv(this.addr, e);
}

function _i(t, e) {
  t.uniform3uiv(this.addr, e);
}

function Ii(t, e) {
  t.uniform4uiv(this.addr, e);
}

function Ci(t, e, n) {
  var i = e.length,
      r = Wn(n, i);
  t.uniform1iv(this.addr, r);

  for (var _t89 = 0; _t89 !== i; ++_t89) {
    n.safeSetTexture2D(e[_t89] || Dn, r[_t89]);
  }
}

function Mi(t, e, n) {
  var i = e.length,
      r = Wn(n, i);
  t.uniform1iv(this.addr, r);

  for (var _t90 = 0; _t90 !== i; ++_t90) {
    n.safeSetTextureCube(e[_t90] || Fn, r[_t90]);
  }
}

function Si(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
    switch (t) {
      case 5126:
        return qn;

      case 35664:
        return jn;

      case 35665:
        return Yn;

      case 35666:
        return Jn;

      case 35674:
        return Xn;

      case 35675:
        return Kn;

      case 35676:
        return Zn;

      case 5124:
      case 35670:
        return $n;

      case 35667:
      case 35671:
        return ti;

      case 35668:
      case 35672:
        return ei;

      case 35669:
      case 35673:
        return ni;

      case 5125:
        return ii;

      case 36294:
        return ri;

      case 36295:
        return si;

      case 36296:
        return ai;

      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return oi;

      case 35679:
      case 36299:
      case 36307:
        return li;

      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return ci;

      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return hi;
    }
  }(e.type);
}

function Bi(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
    switch (t) {
      case 5126:
        return ui;

      case 35664:
        return di;

      case 35665:
        return Ai;

      case 35666:
        return pi;

      case 35674:
        return gi;

      case 35675:
        return mi;

      case 35676:
        return fi;

      case 5124:
      case 35670:
        return vi;

      case 35667:
      case 35671:
        return yi;

      case 35668:
      case 35672:
        return Ei;

      case 35669:
      case 35673:
        return xi;

      case 5125:
        return wi;

      case 36294:
        return bi;

      case 36295:
        return _i;

      case 36296:
        return Ii;

      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Ci;

      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Mi;
    }
  }(e.type);
}

function Ti(t) {
  this.id = t, this.seq = [], this.map = {};
}

Bi.prototype.updateCache = function (t) {
  var e = this.cache;
  t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Vn(e, t);
}, Ti.prototype.setValue = function (t, e, n) {
  var i = this.seq;

  for (var _r57 = 0, _s22 = i.length; _r57 !== _s22; ++_r57) {
    var _s23 = i[_r57];

    _s23.setValue(t, e[_s23.id], n);
  }
};
var Li = /(\w+)(\])?(\[|\.)?/g;

function Ri(t, e) {
  t.seq.push(e), t.map[e.id] = e;
}

function Di(t, e, n) {
  var i = t.name,
      r = i.length;

  for (Li.lastIndex = 0;;) {
    var _s24 = Li.exec(i),
        _a19 = Li.lastIndex;

    var _o12 = _s24[1];

    var _l12 = "]" === _s24[2],
        _c9 = _s24[3];

    if (_l12 && (_o12 |= 0), void 0 === _c9 || "[" === _c9 && _a19 + 2 === r) {
      Ri(n, void 0 === _c9 ? new Si(_o12, t, e) : new Bi(_o12, t, e));
      break;
    }

    {
      var _t91 = n.map[_o12];
      void 0 === _t91 && (_t91 = new Ti(_o12), Ri(n, _t91)), n = _t91;
    }
  }
}

function Qi(t, e) {
  this.seq = [], this.map = {};
  var n = t.getProgramParameter(e, 35718);

  for (var _i69 = 0; _i69 < n; ++_i69) {
    var _n81 = t.getActiveUniform(e, _i69);

    Di(_n81, t.getUniformLocation(e, _n81.name), this);
  }
}

function Pi(t, e, n) {
  var i = t.createShader(e);
  return t.shaderSource(i, n), t.compileShader(i), i;
}

Qi.prototype.setValue = function (t, e, n, i) {
  var r = this.map[e];
  void 0 !== r && r.setValue(t, n, i);
}, Qi.prototype.setOptional = function (t, e, n) {
  var i = e[n];
  void 0 !== i && this.setValue(t, n, i);
}, Qi.upload = function (t, e, n, i) {
  for (var _r58 = 0, _s25 = e.length; _r58 !== _s25; ++_r58) {
    var _s26 = e[_r58],
        _a20 = n[_s26.id];
    !1 !== _a20.needsUpdate && _s26.setValue(t, _a20.value, i);
  }
}, Qi.seqWithValue = function (t, e) {
  var n = [];

  for (var _i70 = 0, _r59 = t.length; _i70 !== _r59; ++_i70) {
    var _r60 = t[_i70];
    _r60.id in e && n.push(_r60);
  }

  return n;
};
var Fi = 0;

function Ni(t) {
  switch (t) {
    case 3e3:
      return ["Linear", "( value )"];

    case 3001:
      return ["sRGB", "( value )"];

    case 3002:
      return ["RGBE", "( value )"];

    case 3004:
      return ["RGBM", "( value, 7.0 )"];

    case 3005:
      return ["RGBM", "( value, 16.0 )"];

    case 3006:
      return ["RGBD", "( value, 256.0 )"];

    case 3007:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];

    case 3003:
      return ["LogLuv", "( value )"];

    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
  }
}

function Ui(t, e, n) {
  var i = t.getShaderParameter(e, 35713),
      r = t.getShaderInfoLog(e).trim();
  if (i && "" === r) return "";
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (t) {
    var e = t.split("\n");

    for (var _t92 = 0; _t92 < e.length; _t92++) {
      e[_t92] = _t92 + 1 + ": " + e[_t92];
    }

    return e.join("\n");
  }(t.getShaderSource(e));
}

function Gi(t, e) {
  var n = Ni(e);
  return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
}

function ki(t, e) {
  var n = Ni(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}

function Oi(t, e) {
  var n;

  switch (e) {
    case 1:
      n = "Linear";
      break;

    case 2:
      n = "Reinhard";
      break;

    case 3:
      n = "OptimizedCineon";
      break;

    case 4:
      n = "ACESFilmic";
      break;

    case 5:
      n = "Custom";
      break;

    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }

  return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}

function Hi(t) {
  return "" !== t;
}

function zi(t, e) {
  return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}

function Vi(t, e) {
  return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}

var Wi = /^[ \t]*#include +<([\w\d./]+)>/gm;

function qi(t) {
  return t.replace(Wi, ji);
}

function ji(t, e) {
  var n = pn[e];
  if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
  return qi(n);
}

var Yi = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    Ji = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function Xi(t) {
  return t.replace(Ji, Zi).replace(Yi, Ki);
}

function Ki(t, e, n, i) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Zi(t, e, n, i);
}

function Zi(t, e, n, i) {
  var r = "";

  for (var _t93 = parseInt(e); _t93 < parseInt(n); _t93++) {
    r += i.replace(/\[\s*i\s*\]/g, "[ " + _t93 + " ]").replace(/UNROLLED_LOOP_INDEX/g, _t93);
  }

  return r;
}

function $i(t) {
  var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
  return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
}

function tr(t, e, n, i) {
  var r = t.getContext(),
      s = n.defines;
  var a = n.vertexShader,
      o = n.fragmentShader;

  var l = function (t) {
    var e = "SHADOWMAP_TYPE_BASIC";
    return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e;
  }(n),
      c = function (t) {
    var e = "ENVMAP_TYPE_CUBE";
    if (t.envMap) switch (t.envMapMode) {
      case 301:
      case 302:
        e = "ENVMAP_TYPE_CUBE";
        break;

      case 306:
      case 307:
        e = "ENVMAP_TYPE_CUBE_UV";
    }
    return e;
  }(n),
      h = function (t) {
    var e = "ENVMAP_MODE_REFLECTION";
    if (t.envMap) switch (t.envMapMode) {
      case 302:
      case 307:
        e = "ENVMAP_MODE_REFRACTION";
    }
    return e;
  }(n),
      u = function (t) {
    var e = "ENVMAP_BLENDING_NONE";
    if (t.envMap) switch (t.combine) {
      case 0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;

      case 1:
        e = "ENVMAP_BLENDING_MIX";
        break;

      case 2:
        e = "ENVMAP_BLENDING_ADD";
    }
    return e;
  }(n),
      d = t.gammaFactor > 0 ? t.gammaFactor : 1,
      A = n.isWebGL2 ? "" : function (t) {
    return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Hi).join("\n");
  }(n),
      p = function (t) {
    var e = [];

    for (var _n82 in t) {
      var _i71 = t[_n82];
      !1 !== _i71 && e.push("#define " + _n82 + " " + _i71);
    }

    return e.join("\n");
  }(s),
      g = r.createProgram();

  var m,
      f,
      v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
  n.isRawShaderMaterial ? (m = [p].filter(Hi).join("\n"), m.length > 0 && (m += "\n"), f = [A, p].filter(Hi).join("\n"), f.length > 0 && (f += "\n")) : (m = [$i(n), "#define SHADER_NAME " + n.shaderName, p, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Hi).join("\n"), f = [A, $i(n), "#define SHADER_NAME " + n.shaderName, p, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? pn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Oi("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", pn.encodings_pars_fragment, n.map ? Gi("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Gi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Gi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Gi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Gi("lightMapTexelToLinear", n.lightMapEncoding) : "", ki("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Hi).join("\n")), a = qi(a), a = zi(a, n), a = Vi(a, n), o = qi(o), o = zi(o, n), o = Vi(o, n), a = Xi(a), o = Xi(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (v = "#version 300 es\n", m = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m, f = ["#define varying in", "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + f);
  var y = v + f + o,
      E = Pi(r, 35633, v + m + a),
      x = Pi(r, 35632, y);

  if (r.attachShader(g, E), r.attachShader(g, x), void 0 !== n.index0AttributeName ? r.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g), t.debug.checkShaderErrors) {
    var _t94 = r.getProgramInfoLog(g).trim(),
        _e69 = r.getShaderInfoLog(E).trim(),
        _n83 = r.getShaderInfoLog(x).trim();

    var _i72 = !0,
        _s27 = !0;

    if (!1 === r.getProgramParameter(g, 35714)) {
      _i72 = !1;

      var _e70 = Ui(r, E, "vertex"),
          _n84 = Ui(r, x, "fragment");

      console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(g, 35715), "gl.getProgramInfoLog", _t94, _e70, _n84);
    } else "" !== _t94 ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", _t94) : "" !== _e69 && "" !== _n83 || (_s27 = !1);

    _s27 && (this.diagnostics = {
      runnable: _i72,
      programLog: _t94,
      vertexShader: {
        log: _e69,
        prefix: m
      },
      fragmentShader: {
        log: _n83,
        prefix: f
      }
    });
  }

  var w, b;
  return r.deleteShader(E), r.deleteShader(x), this.getUniforms = function () {
    return void 0 === w && (w = new Qi(r, g)), w;
  }, this.getAttributes = function () {
    return void 0 === b && (b = function (t, e) {
      var n = {},
          i = t.getProgramParameter(e, 35721);

      for (var _r61 = 0; _r61 < i; _r61++) {
        var _i73 = t.getActiveAttrib(e, _r61).name;
        n[_i73] = t.getAttribLocation(e, _i73);
      }

      return n;
    }(r, g)), b;
  }, this.destroy = function () {
    i.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0;
  }, this.name = n.shaderName, this.id = Fi++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = E, this.fragmentShader = x, this;
}

function er(t, e, n, i, r, s) {
  var a = [],
      o = i.isWebGL2,
      l = i.logarithmicDepthBuffer,
      c = i.floatVertexTextures,
      h = i.maxVertexUniforms,
      u = i.vertexTextures;
  var d = i.precision;
  var A = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  },
      p = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

  function g(t) {
    var e;
    return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e;
  }

  return {
    getParameters: function getParameters(r, a, p, m, f) {
      var v = m.fog,
          y = r.isMeshStandardMaterial ? m.environment : null,
          E = e.get(r.envMap || y),
          x = A[r.type],
          w = f.isSkinnedMesh ? function (t) {
        var e = t.skeleton.bones;
        if (c) return 1024;
        {
          var _t95 = h,
              _n85 = Math.floor((_t95 - 20) / 4),
              _i74 = Math.min(_n85, e.length);

          return _i74 < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + _i74 + "."), 0) : _i74;
        }
      }(f) : 0;

      var b, _;

      if (null !== r.precision && (d = i.getMaxPrecision(r.precision), d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")), x) {
        var _t96 = mn[x];
        b = _t96.vertexShader, _ = _t96.fragmentShader;
      } else b = r.vertexShader, _ = r.fragmentShader;

      var I = t.getRenderTarget();
      return {
        isWebGL2: o,
        shaderID: x,
        shaderName: r.type,
        vertexShader: b,
        fragmentShader: _,
        defines: r.defines,
        isRawShaderMaterial: !0 === r.isRawShaderMaterial,
        glslVersion: r.glslVersion,
        precision: d,
        instancing: !0 === f.isInstancedMesh,
        instancingColor: !0 === f.isInstancedMesh && null !== f.instanceColor,
        supportsVertexTextures: u,
        outputEncoding: null !== I ? g(I.texture) : t.outputEncoding,
        map: !!r.map,
        mapEncoding: g(r.map),
        matcap: !!r.matcap,
        matcapEncoding: g(r.matcap),
        envMap: !!E,
        envMapMode: E && E.mapping,
        envMapEncoding: g(E),
        envMapCubeUV: !!E && (306 === E.mapping || 307 === E.mapping),
        lightMap: !!r.lightMap,
        lightMapEncoding: g(r.lightMap),
        aoMap: !!r.aoMap,
        emissiveMap: !!r.emissiveMap,
        emissiveMapEncoding: g(r.emissiveMap),
        bumpMap: !!r.bumpMap,
        normalMap: !!r.normalMap,
        objectSpaceNormalMap: 1 === r.normalMapType,
        tangentSpaceNormalMap: 0 === r.normalMapType,
        clearcoatMap: !!r.clearcoatMap,
        clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
        clearcoatNormalMap: !!r.clearcoatNormalMap,
        displacementMap: !!r.displacementMap,
        roughnessMap: !!r.roughnessMap,
        metalnessMap: !!r.metalnessMap,
        specularMap: !!r.specularMap,
        alphaMap: !!r.alphaMap,
        gradientMap: !!r.gradientMap,
        sheen: !!r.sheen,
        transmissionMap: !!r.transmissionMap,
        combine: r.combine,
        vertexTangents: r.normalMap && r.vertexTangents,
        vertexColors: r.vertexColors,
        vertexAlphas: !0 === r.vertexColors && f.geometry && f.geometry.attributes.color && 4 === f.geometry.attributes.color.itemSize,
        vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
        uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
        fog: !!v,
        useFog: r.fog,
        fogExp2: v && v.isFogExp2,
        flatShading: !!r.flatShading,
        sizeAttenuation: r.sizeAttenuation,
        logarithmicDepthBuffer: l,
        skinning: r.skinning && w > 0,
        maxBones: w,
        useVertexTexture: c,
        morphTargets: r.morphTargets,
        morphNormals: r.morphNormals,
        numDirLights: a.directional.length,
        numPointLights: a.point.length,
        numSpotLights: a.spot.length,
        numRectAreaLights: a.rectArea.length,
        numHemiLights: a.hemi.length,
        numDirLightShadows: a.directionalShadowMap.length,
        numPointLightShadows: a.pointShadowMap.length,
        numSpotLightShadows: a.spotShadowMap.length,
        numClippingPlanes: s.numPlanes,
        numClipIntersection: s.numIntersection,
        dithering: r.dithering,
        shadowMapEnabled: t.shadowMap.enabled && p.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: r.toneMapped ? t.toneMapping : 0,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: r.premultipliedAlpha,
        alphaTest: r.alphaTest,
        doubleSided: 2 === r.side,
        flipSided: 1 === r.side,
        depthPacking: void 0 !== r.depthPacking && r.depthPacking,
        index0AttributeName: r.index0AttributeName,
        extensionDerivatives: r.extensions && r.extensions.derivatives,
        extensionFragDepth: r.extensions && r.extensions.fragDepth,
        extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
        extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: o || n.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: o || n.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: o || n.has("EXT_shader_texture_lod"),
        customProgramCacheKey: r.customProgramCacheKey()
      };
    },
    getProgramCacheKey: function getProgramCacheKey(e) {
      var n = [];
      if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (var _t97 in e.defines) {
        n.push(_t97), n.push(e.defines[_t97]);
      }

      if (!1 === e.isRawShaderMaterial) {
        for (var _t98 = 0; _t98 < p.length; _t98++) {
          n.push(e[p[_t98]]);
        }

        n.push(t.outputEncoding), n.push(t.gammaFactor);
      }

      return n.push(e.customProgramCacheKey), n.join();
    },
    getUniforms: function getUniforms(t) {
      var e = A[t.type];
      var n;

      if (e) {
        var _t99 = mn[e];
        n = $e.clone(_t99.uniforms);
      } else n = t.uniforms;

      return n;
    },
    acquireProgram: function acquireProgram(e, n) {
      var i;

      for (var _t100 = 0, _e71 = a.length; _t100 < _e71; _t100++) {
        var _e72 = a[_t100];

        if (_e72.cacheKey === n) {
          i = _e72, ++i.usedTimes;
          break;
        }
      }

      return void 0 === i && (i = new tr(t, n, e, r), a.push(i)), i;
    },
    releaseProgram: function releaseProgram(t) {
      if (0 == --t.usedTimes) {
        var _e73 = a.indexOf(t);

        a[_e73] = a[a.length - 1], a.pop(), t.destroy();
      }
    },
    programs: a
  };
}

function nr() {
  var t = new WeakMap();
  return {
    get: function get(e) {
      var n = t.get(e);
      return void 0 === n && (n = {}, t.set(e, n)), n;
    },
    remove: function remove(e) {
      t.delete(e);
    },
    update: function update(e, n, i) {
      t.get(e)[n] = i;
    },
    dispose: function dispose() {
      t = new WeakMap();
    }
  };
}

function ir(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
}

function rr(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
}

function sr(t) {
  var e = [];
  var n = 0;
  var i = [],
      r = [],
      s = {
    id: -1
  };

  function a(i, r, a, o, l, c) {
    var h = e[n];
    var u = t.get(a);
    return void 0 === h ? (h = {
      id: i.id,
      object: i,
      geometry: r,
      material: a,
      program: u.program || s,
      groupOrder: o,
      renderOrder: i.renderOrder,
      z: l,
      group: c
    }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = a, h.program = u.program || s, h.groupOrder = o, h.renderOrder = i.renderOrder, h.z = l, h.group = c), n++, h;
  }

  return {
    opaque: i,
    transparent: r,
    init: function init() {
      n = 0, i.length = 0, r.length = 0;
    },
    push: function push(t, e, n, s, o, l) {
      var c = a(t, e, n, s, o, l);
      (!0 === n.transparent ? r : i).push(c);
    },
    unshift: function unshift(t, e, n, s, o, l) {
      var c = a(t, e, n, s, o, l);
      (!0 === n.transparent ? r : i).unshift(c);
    },
    finish: function finish() {
      for (var _t101 = n, _i75 = e.length; _t101 < _i75; _t101++) {
        var _n86 = e[_t101];
        if (null === _n86.id) break;
        _n86.id = null, _n86.object = null, _n86.geometry = null, _n86.material = null, _n86.program = null, _n86.group = null;
      }
    },
    sort: function sort(t, e) {
      i.length > 1 && i.sort(t || ir), r.length > 1 && r.sort(e || rr);
    }
  };
}

function ar(t) {
  var e = new WeakMap();
  return {
    get: function get(n, i) {
      var r;
      return !1 === e.has(n) ? (r = new sr(t), e.set(n, [r])) : i >= e.get(n).length ? (r = new sr(t), e.get(n).push(r)) : r = e.get(n)[i], r;
    },
    dispose: function dispose() {
      e = new WeakMap();
    }
  };
}

function or() {
  var t = {};
  return {
    get: function get(e) {
      if (void 0 !== t[e.id]) return t[e.id];
      var n;

      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new H(),
            color: new pe()
          };
          break;

        case "SpotLight":
          n = {
            position: new H(),
            direction: new H(),
            color: new pe(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;

        case "PointLight":
          n = {
            position: new H(),
            color: new pe(),
            distance: 0,
            decay: 0
          };
          break;

        case "HemisphereLight":
          n = {
            direction: new H(),
            skyColor: new pe(),
            groundColor: new pe()
          };
          break;

        case "RectAreaLight":
          n = {
            color: new pe(),
            position: new H(),
            halfWidth: new H(),
            halfHeight: new H()
          };
      }

      return t[e.id] = n, n;
    }
  };
}

var lr = 0;

function cr(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}

function hr(t, e) {
  var n = new or(),
      i = function () {
    var t = {};
    return {
      get: function get(e) {
        if (void 0 !== t[e.id]) return t[e.id];
        var n;

        switch (e.type) {
          case "DirectionalLight":
          case "SpotLight":
            n = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new R()
            };
            break;

          case "PointLight":
            n = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new R(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
        }

        return t[e.id] = n, n;
      }
    };
  }(),
      r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };

  for (var _t102 = 0; _t102 < 9; _t102++) {
    r.probe.push(new H());
  }

  var s = new H(),
      a = new yt(),
      o = new yt();
  return {
    setup: function setup(s) {
      var a = 0,
          o = 0,
          l = 0;

      for (var _t103 = 0; _t103 < 9; _t103++) {
        r.probe[_t103].set(0, 0, 0);
      }

      var c = 0,
          h = 0,
          u = 0,
          d = 0,
          A = 0,
          p = 0,
          g = 0,
          m = 0;
      s.sort(cr);

      for (var _t104 = 0, _e74 = s.length; _t104 < _e74; _t104++) {
        var _e75 = s[_t104],
            _f2 = _e75.color,
            _v2 = _e75.intensity,
            _y6 = _e75.distance,
            _E2 = _e75.shadow && _e75.shadow.map ? _e75.shadow.map.texture : null;

        if (_e75.isAmbientLight) a += _f2.r * _v2, o += _f2.g * _v2, l += _f2.b * _v2;else if (_e75.isLightProbe) for (var _t105 = 0; _t105 < 9; _t105++) {
          r.probe[_t105].addScaledVector(_e75.sh.coefficients[_t105], _v2);
        } else if (_e75.isDirectionalLight) {
          var _t106 = n.get(_e75);

          if (_t106.color.copy(_e75.color).multiplyScalar(_e75.intensity), _e75.castShadow) {
            var _t107 = _e75.shadow,
                _n87 = i.get(_e75);

            _n87.shadowBias = _t107.bias, _n87.shadowNormalBias = _t107.normalBias, _n87.shadowRadius = _t107.radius, _n87.shadowMapSize = _t107.mapSize, r.directionalShadow[c] = _n87, r.directionalShadowMap[c] = _E2, r.directionalShadowMatrix[c] = _e75.shadow.matrix, p++;
          }

          r.directional[c] = _t106, c++;
        } else if (_e75.isSpotLight) {
          var _t108 = n.get(_e75);

          if (_t108.position.setFromMatrixPosition(_e75.matrixWorld), _t108.color.copy(_f2).multiplyScalar(_v2), _t108.distance = _y6, _t108.coneCos = Math.cos(_e75.angle), _t108.penumbraCos = Math.cos(_e75.angle * (1 - _e75.penumbra)), _t108.decay = _e75.decay, _e75.castShadow) {
            var _t109 = _e75.shadow,
                _n88 = i.get(_e75);

            _n88.shadowBias = _t109.bias, _n88.shadowNormalBias = _t109.normalBias, _n88.shadowRadius = _t109.radius, _n88.shadowMapSize = _t109.mapSize, r.spotShadow[u] = _n88, r.spotShadowMap[u] = _E2, r.spotShadowMatrix[u] = _e75.shadow.matrix, m++;
          }

          r.spot[u] = _t108, u++;
        } else if (_e75.isRectAreaLight) {
          var _t110 = n.get(_e75);

          _t110.color.copy(_f2).multiplyScalar(_v2), _t110.halfWidth.set(.5 * _e75.width, 0, 0), _t110.halfHeight.set(0, .5 * _e75.height, 0), r.rectArea[d] = _t110, d++;
        } else if (_e75.isPointLight) {
          var _t111 = n.get(_e75);

          if (_t111.color.copy(_e75.color).multiplyScalar(_e75.intensity), _t111.distance = _e75.distance, _t111.decay = _e75.decay, _e75.castShadow) {
            var _t112 = _e75.shadow,
                _n89 = i.get(_e75);

            _n89.shadowBias = _t112.bias, _n89.shadowNormalBias = _t112.normalBias, _n89.shadowRadius = _t112.radius, _n89.shadowMapSize = _t112.mapSize, _n89.shadowCameraNear = _t112.camera.near, _n89.shadowCameraFar = _t112.camera.far, r.pointShadow[h] = _n89, r.pointShadowMap[h] = _E2, r.pointShadowMatrix[h] = _e75.shadow.matrix, g++;
          }

          r.point[h] = _t111, h++;
        } else if (_e75.isHemisphereLight) {
          var _t113 = n.get(_e75);

          _t113.skyColor.copy(_e75.color).multiplyScalar(_v2), _t113.groundColor.copy(_e75.groundColor).multiplyScalar(_v2), r.hemi[A] = _t113, A++;
        }
      }

      d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = gn.LTC_FLOAT_1, r.rectAreaLTC2 = gn.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = gn.LTC_HALF_1, r.rectAreaLTC2 = gn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a, r.ambient[1] = o, r.ambient[2] = l;
      var f = r.hash;
      f.directionalLength === c && f.pointLength === h && f.spotLength === u && f.rectAreaLength === d && f.hemiLength === A && f.numDirectionalShadows === p && f.numPointShadows === g && f.numSpotShadows === m || (r.directional.length = c, r.spot.length = u, r.rectArea.length = d, r.point.length = h, r.hemi.length = A, r.directionalShadow.length = p, r.directionalShadowMap.length = p, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = m, r.spotShadowMap.length = m, r.directionalShadowMatrix.length = p, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = m, f.directionalLength = c, f.pointLength = h, f.spotLength = u, f.rectAreaLength = d, f.hemiLength = A, f.numDirectionalShadows = p, f.numPointShadows = g, f.numSpotShadows = m, r.version = lr++);
    },
    setupView: function setupView(t, e) {
      var n = 0,
          i = 0,
          l = 0,
          c = 0,
          h = 0;
      var u = e.matrixWorldInverse;

      for (var _e76 = 0, _d7 = t.length; _e76 < _d7; _e76++) {
        var _d8 = t[_e76];

        if (_d8.isDirectionalLight) {
          var _t114 = r.directional[n];
          _t114.direction.setFromMatrixPosition(_d8.matrixWorld), s.setFromMatrixPosition(_d8.target.matrixWorld), _t114.direction.sub(s), _t114.direction.transformDirection(u), n++;
        } else if (_d8.isSpotLight) {
          var _t115 = r.spot[l];
          _t115.position.setFromMatrixPosition(_d8.matrixWorld), _t115.position.applyMatrix4(u), _t115.direction.setFromMatrixPosition(_d8.matrixWorld), s.setFromMatrixPosition(_d8.target.matrixWorld), _t115.direction.sub(s), _t115.direction.transformDirection(u), l++;
        } else if (_d8.isRectAreaLight) {
          var _t116 = r.rectArea[c];
          _t116.position.setFromMatrixPosition(_d8.matrixWorld), _t116.position.applyMatrix4(u), o.identity(), a.copy(_d8.matrixWorld), a.premultiply(u), o.extractRotation(a), _t116.halfWidth.set(.5 * _d8.width, 0, 0), _t116.halfHeight.set(0, .5 * _d8.height, 0), _t116.halfWidth.applyMatrix4(o), _t116.halfHeight.applyMatrix4(o), c++;
        } else if (_d8.isPointLight) {
          var _t117 = r.point[i];
          _t117.position.setFromMatrixPosition(_d8.matrixWorld), _t117.position.applyMatrix4(u), i++;
        } else if (_d8.isHemisphereLight) {
          var _t118 = r.hemi[h];
          _t118.direction.setFromMatrixPosition(_d8.matrixWorld), _t118.direction.transformDirection(u), _t118.direction.normalize(), h++;
        }
      }
    },
    state: r
  };
}

function ur(t, e) {
  var n = new hr(t, e),
      i = [],
      r = [];
  return {
    init: function init() {
      i.length = 0, r.length = 0;
    },
    state: {
      lightsArray: i,
      shadowsArray: r,
      lights: n
    },
    setupLights: function setupLights() {
      n.setup(i);
    },
    setupLightsView: function setupLightsView(t) {
      n.setupView(i, t);
    },
    pushLight: function pushLight(t) {
      i.push(t);
    },
    pushShadow: function pushShadow(t) {
      r.push(t);
    }
  };
}

function dr(t, e) {
  var n = new WeakMap();
  return {
    get: function get(i) {
      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s;
      return !1 === n.has(i) ? (s = new ur(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new ur(t, e), n.get(i).push(s)) : s = n.get(i)[r], s;
    },
    dispose: function dispose() {
      n = new WeakMap();
    }
  };
}

var Ar = /*#__PURE__*/function (_oe3) {
  _inherits(Ar, _oe3);

  var _super22 = _createSuper(Ar);

  function Ar(t) {
    var _this25;

    _classCallCheck(this, Ar);

    _this25 = _super22.call(this), _this25.type = "MeshDepthMaterial", _this25.depthPacking = 3200, _this25.skinning = !1, _this25.morphTargets = !1, _this25.map = null, _this25.alphaMap = null, _this25.displacementMap = null, _this25.displacementScale = 1, _this25.displacementBias = 0, _this25.wireframe = !1, _this25.wireframeLinewidth = 1, _this25.fog = !1, _this25.setValues(t);
    return _this25;
  }

  _createClass(Ar, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Ar.prototype), "copy", this).call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
    }
  }]);

  return Ar;
}(oe);

Ar.prototype.isMeshDepthMaterial = !0;

var pr = /*#__PURE__*/function (_oe4) {
  _inherits(pr, _oe4);

  var _super23 = _createSuper(pr);

  function pr(t) {
    var _this26;

    _classCallCheck(this, pr);

    _this26 = _super23.call(this), _this26.type = "MeshDistanceMaterial", _this26.referencePosition = new H(), _this26.nearDistance = 1, _this26.farDistance = 1e3, _this26.skinning = !1, _this26.morphTargets = !1, _this26.map = null, _this26.alphaMap = null, _this26.displacementMap = null, _this26.displacementScale = 1, _this26.displacementBias = 0, _this26.fog = !1, _this26.setValues(t);
    return _this26;
  }

  _createClass(pr, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(pr.prototype), "copy", this).call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
    }
  }]);

  return pr;
}(oe);

pr.prototype.isMeshDistanceMaterial = !0;

function gr(t, e, n) {
  var i = new hn();
  var r = new R(),
      s = new R(),
      a = new G(),
      o = [],
      l = [],
      c = {},
      h = n.maxTextureSize,
      u = {
    0: 1,
    1: 0,
    2: 2
  },
      d = new tn({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new R()
      },
      radius: {
        value: 4
      }
    },
    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
  }),
      A = d.clone();
  A.defines.HORIZONTAL_PASS = 1;
  var p = new Te();
  p.setAttribute("position", new ve(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
  var g = new Ye(p, d),
      m = this;

  function f(n, i) {
    var r = e.update(g);
    d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, g, null), A.uniforms.shadow_pass.value = n.mapPass.texture, A.uniforms.resolution.value = n.mapSize, A.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, A, g, null);
  }

  function v(t, e, n) {
    var i = t << 0 | e << 1 | n << 2;
    var r = o[i];
    return void 0 === r && (r = new Ar({
      depthPacking: 3201,
      morphTargets: t,
      skinning: e
    }), o[i] = r), r;
  }

  function y(t, e, n) {
    var i = t << 0 | e << 1 | n << 2;
    var r = l[i];
    return void 0 === r && (r = new pr({
      morphTargets: t,
      skinning: e
    }), l[i] = r), r;
  }

  function E(e, n, i, r, s, a, o) {
    var l = null,
        h = v,
        d = e.customDepthMaterial;

    if (!0 === r.isPointLight && (h = y, d = e.customDistanceMaterial), void 0 === d) {
      var _t119 = !1;

      !0 === i.morphTargets && (_t119 = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);

      var _r62 = !1;

      !0 === e.isSkinnedMesh && (!0 === i.skinning ? _r62 = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
      l = h(_t119, _r62, !0 === e.isInstancedMesh);
    } else l = d;

    if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
      var _t120 = l.uuid,
          _e77 = i.uuid;
      var _n90 = c[_t120];
      void 0 === _n90 && (_n90 = {}, c[_t120] = _n90);
      var _r63 = _n90[_e77];
      void 0 === _r63 && (_r63 = l.clone(), _n90[_e77] = _r63), l = _r63;
    }

    return l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === o ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = s, l.farDistance = a), l;
  }

  function x(n, r, s, a, o) {
    if (!1 === n.visible) return;

    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
      n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);

      var _i76 = e.update(n),
          _r64 = n.material;

      if (Array.isArray(_r64)) {
        var _e78 = _i76.groups;

        for (var _l13 = 0, _c10 = _e78.length; _l13 < _c10; _l13++) {
          var _c11 = _e78[_l13],
              _h7 = _r64[_c11.materialIndex];

          if (_h7 && _h7.visible) {
            var _e79 = E(n, _i76, _h7, a, s.near, s.far, o);

            t.renderBufferDirect(s, null, _i76, _e79, n, _c11);
          }
        }
      } else if (_r64.visible) {
        var _e80 = E(n, _i76, _r64, a, s.near, s.far, o);

        t.renderBufferDirect(s, null, _i76, _e80, n, null);
      }
    }

    var l = n.children;

    for (var _t121 = 0, _e81 = l.length; _t121 < _e81; _t121++) {
      x(l[_t121], r, s, a, o);
    }
  }

  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, n, o) {
    if (!1 === m.enabled) return;
    if (!1 === m.autoUpdate && !1 === m.needsUpdate) return;
    if (0 === e.length) return;
    var l = t.getRenderTarget(),
        c = t.getActiveCubeFace(),
        u = t.getActiveMipmapLevel(),
        d = t.state;
    d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);

    for (var _l14 = 0, _c12 = e.length; _l14 < _c12; _l14++) {
      var _c13 = e[_l14],
          _u9 = _c13.shadow;

      if (void 0 === _u9) {
        console.warn("THREE.WebGLShadowMap:", _c13, "has no shadow.");
        continue;
      }

      if (!1 === _u9.autoUpdate && !1 === _u9.needsUpdate) continue;
      r.copy(_u9.mapSize);

      var _A7 = _u9.getFrameExtents();

      if (r.multiply(_A7), s.copy(_u9.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / _A7.x), r.x = s.x * _A7.x, _u9.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / _A7.y), r.y = s.y * _A7.y, _u9.mapSize.y = s.y)), null === _u9.map && !_u9.isPointLightShadow && 3 === this.type) {
        var _t122 = {
          minFilter: 1006,
          magFilter: 1006,
          format: 1023
        };
        _u9.map = new k(r.x, r.y, _t122), _u9.map.texture.name = _c13.name + ".shadowMap", _u9.mapPass = new k(r.x, r.y, _t122), _u9.camera.updateProjectionMatrix();
      }

      if (null === _u9.map) {
        var _t123 = {
          minFilter: 1003,
          magFilter: 1003,
          format: 1023
        };
        _u9.map = new k(r.x, r.y, _t123), _u9.map.texture.name = _c13.name + ".shadowMap", _u9.camera.updateProjectionMatrix();
      }

      t.setRenderTarget(_u9.map), t.clear();

      var _p4 = _u9.getViewportCount();

      for (var _t124 = 0; _t124 < _p4; _t124++) {
        var _e82 = _u9.getViewport(_t124);

        a.set(s.x * _e82.x, s.y * _e82.y, s.x * _e82.z, s.y * _e82.w), d.viewport(a), _u9.updateMatrices(_c13, _t124), i = _u9.getFrustum(), x(n, o, _u9.camera, _c13, this.type);
      }

      _u9.isPointLightShadow || 3 !== this.type || f(_u9, o), _u9.needsUpdate = !1;
    }

    m.needsUpdate = !1, t.setRenderTarget(l, c, u);
  };
}

function mr(t, e, n) {
  var i = n.isWebGL2;
  var r = new function () {
    var e = !1;
    var n = new G();
    var i = null;
    var r = new G(0, 0, 0, 0);
    return {
      setMask: function setMask(n) {
        i === n || e || (t.colorMask(n, n, n, n), i = n);
      },
      setLocked: function setLocked(t) {
        e = t;
      },
      setClear: function setClear(e, i, s, a, o) {
        !0 === o && (e *= a, i *= a, s *= a), n.set(e, i, s, a), !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
      },
      reset: function reset() {
        e = !1, i = null, r.set(-1, 0, 0, 0);
      }
    };
  }(),
      s = new function () {
    var e = !1,
        n = null,
        i = null,
        r = null;
    return {
      setTest: function setTest(t) {
        t ? P(2929) : F(2929);
      },
      setMask: function setMask(i) {
        n === i || e || (t.depthMask(i), n = i);
      },
      setFunc: function setFunc(e) {
        if (i !== e) {
          if (e) switch (e) {
            case 0:
              t.depthFunc(512);
              break;

            case 1:
              t.depthFunc(519);
              break;

            case 2:
              t.depthFunc(513);
              break;

            case 3:
              t.depthFunc(515);
              break;

            case 4:
              t.depthFunc(514);
              break;

            case 5:
              t.depthFunc(518);
              break;

            case 6:
              t.depthFunc(516);
              break;

            case 7:
              t.depthFunc(517);
              break;

            default:
              t.depthFunc(515);
          } else t.depthFunc(515);
          i = e;
        }
      },
      setLocked: function setLocked(t) {
        e = t;
      },
      setClear: function setClear(e) {
        r !== e && (t.clearDepth(e), r = e);
      },
      reset: function reset() {
        e = !1, n = null, i = null, r = null;
      }
    };
  }(),
      a = new function () {
    var e = !1,
        n = null,
        i = null,
        r = null,
        s = null,
        a = null,
        o = null,
        l = null,
        c = null;
    return {
      setTest: function setTest(t) {
        e || (t ? P(2960) : F(2960));
      },
      setMask: function setMask(i) {
        n === i || e || (t.stencilMask(i), n = i);
      },
      setFunc: function setFunc(e, n, a) {
        i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a);
      },
      setOp: function setOp(e, n, i) {
        a === e && o === n && l === i || (t.stencilOp(e, n, i), a = e, o = n, l = i);
      },
      setLocked: function setLocked(t) {
        e = t;
      },
      setClear: function setClear(e) {
        c !== e && (t.clearStencil(e), c = e);
      },
      reset: function reset() {
        e = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null;
      }
    };
  }();
  var o = {},
      l = null,
      c = {},
      h = null,
      u = !1,
      d = null,
      A = null,
      p = null,
      g = null,
      m = null,
      f = null,
      v = null,
      y = !1,
      E = null,
      x = null,
      w = null,
      b = null,
      _ = null;
  var I = t.getParameter(35661);
  var C = !1,
      M = 0;
  var S = t.getParameter(7938);
  -1 !== S.indexOf("WebGL") ? (M = parseFloat(/^WebGL (\d)/.exec(S)[1]), C = M >= 1) : -1 !== S.indexOf("OpenGL ES") && (M = parseFloat(/^OpenGL ES (\d)/.exec(S)[1]), C = M >= 2);
  var B = null,
      T = {};
  var L = new G(0, 0, t.canvas.width, t.canvas.height),
      R = new G(0, 0, t.canvas.width, t.canvas.height);

  function D(e, n, i) {
    var r = new Uint8Array(4),
        s = t.createTexture();
    t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);

    for (var _e83 = 0; _e83 < i; _e83++) {
      t.texImage2D(n + _e83, 0, 6408, 1, 1, 0, 6408, 5121, r);
    }

    return s;
  }

  var Q = {};

  function P(e) {
    !0 !== o[e] && (t.enable(e), o[e] = !0);
  }

  function F(e) {
    !1 !== o[e] && (t.disable(e), o[e] = !1);
  }

  Q[3553] = D(3553, 3553, 1), Q[34067] = D(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), P(2929), s.setFunc(3), O(!1), H(1), P(2884), k(0);
  var N = {
    100: 32774,
    101: 32778,
    102: 32779
  };
  if (i) N[103] = 32775, N[104] = 32776;else {
    var _t125 = e.get("EXT_blend_minmax");

    null !== _t125 && (N[103] = _t125.MIN_EXT, N[104] = _t125.MAX_EXT);
  }
  var U = {
    200: 0,
    201: 1,
    202: 768,
    204: 770,
    210: 776,
    208: 774,
    206: 772,
    203: 769,
    205: 771,
    209: 775,
    207: 773
  };

  function k(e, n, i, r, s, a, o, l) {
    if (0 !== e) {
      if (!1 === u && (P(3042), u = !0), 5 === e) s = s || n, a = a || i, o = o || r, n === A && s === m || (t.blendEquationSeparate(N[n], N[s]), A = n, m = s), i === p && r === g && a === f && o === v || (t.blendFuncSeparate(U[i], U[r], U[a], U[o]), p = i, g = r, f = a, v = o), d = e, y = null;else if (e !== d || l !== y) {
        if (100 === A && 100 === m || (t.blendEquation(32774), A = 100, m = 100), l) switch (e) {
          case 1:
            t.blendFuncSeparate(1, 771, 1, 771);
            break;

          case 2:
            t.blendFunc(1, 1);
            break;

          case 3:
            t.blendFuncSeparate(0, 0, 769, 771);
            break;

          case 4:
            t.blendFuncSeparate(0, 768, 0, 770);
            break;

          default:
            console.error("THREE.WebGLState: Invalid blending: ", e);
        } else switch (e) {
          case 1:
            t.blendFuncSeparate(770, 771, 1, 771);
            break;

          case 2:
            t.blendFunc(770, 1);
            break;

          case 3:
            t.blendFunc(0, 769);
            break;

          case 4:
            t.blendFunc(0, 768);
            break;

          default:
            console.error("THREE.WebGLState: Invalid blending: ", e);
        }
        p = null, g = null, f = null, v = null, d = e, y = l;
      }
    } else !0 === u && (F(3042), u = !1);
  }

  function O(e) {
    E !== e && (e ? t.frontFace(2304) : t.frontFace(2305), E = e);
  }

  function H(e) {
    0 !== e ? (P(2884), e !== x && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : F(2884), x = e;
  }

  function z(e, n, i) {
    e ? (P(32823), b === n && _ === i || (t.polygonOffset(n, i), b = n, _ = i)) : F(32823);
  }

  function V(e) {
    void 0 === e && (e = 33984 + I - 1), B !== e && (t.activeTexture(e), B = e);
  }

  return {
    buffers: {
      color: r,
      depth: s,
      stencil: a
    },
    enable: P,
    disable: F,
    bindFramebuffer: function bindFramebuffer(e, n) {
      null === n && null !== l && (n = l), c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, i && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)));
    },
    bindXRFramebuffer: function bindXRFramebuffer(e) {
      e !== l && (t.bindFramebuffer(36160, e), l = e);
    },
    useProgram: function useProgram(e) {
      return h !== e && (t.useProgram(e), h = e, !0);
    },
    setBlending: k,
    setMaterial: function setMaterial(t, e) {
      2 === t.side ? F(2884) : P(2884);
      var n = 1 === t.side;
      e && (n = !n), O(n), 1 === t.blending && !1 === t.transparent ? k(0) : k(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
      var i = t.stencilWrite;
      a.setTest(i), i && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), z(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? P(32926) : F(32926);
    },
    setFlipSided: O,
    setCullFace: H,
    setLineWidth: function setLineWidth(e) {
      e !== w && (C && t.lineWidth(e), w = e);
    },
    setPolygonOffset: z,
    setScissorTest: function setScissorTest(t) {
      t ? P(3089) : F(3089);
    },
    activeTexture: V,
    bindTexture: function bindTexture(e, n) {
      null === B && V();
      var i = T[B];
      void 0 === i && (i = {
        type: void 0,
        texture: void 0
      }, T[B] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || Q[e]), i.type = e, i.texture = n);
    },
    unbindTexture: function unbindTexture() {
      var e = T[B];
      void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0);
    },
    compressedTexImage2D: function compressedTexImage2D() {
      try {
        t.compressedTexImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage2D: function texImage2D() {
      try {
        t.texImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage3D: function texImage3D() {
      try {
        t.texImage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    scissor: function scissor(e) {
      !1 === L.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), L.copy(e));
    },
    viewport: function viewport(e) {
      !1 === R.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), R.copy(e));
    },
    reset: function reset() {
      t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), o = {}, B = null, T = {}, l = null, c = {}, h = null, u = !1, d = null, A = null, p = null, g = null, m = null, f = null, v = null, y = !1, E = null, x = null, w = null, b = null, _ = null, L.set(0, 0, t.canvas.width, t.canvas.height), R.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), a.reset();
    }
  };
}

function fr(t, e, n, i, r, s, a) {
  var o = r.isWebGL2,
      l = r.maxTextures,
      c = r.maxCubemapSize,
      h = r.maxTextureSize,
      u = r.maxSamples,
      d = new WeakMap();
  var A,
      p = !1;

  try {
    p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (t) {}

  function g(t, e) {
    return p ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }

  function m(t, e, n, i) {
    var r = 1;

    if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
      if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
        var _i77 = e ? T : Math.floor,
            _s28 = _i77(r * t.width),
            _a21 = _i77(r * t.height);

        void 0 === A && (A = g(_s28, _a21));

        var _o13 = n ? g(_s28, _a21) : A;

        _o13.width = _s28, _o13.height = _a21;
        return _o13.getContext("2d").drawImage(t, 0, 0, _s28, _a21), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + _s28 + "x" + _a21 + ")."), _o13;
      }

      return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
    }

    return t;
  }

  function f(t) {
    return S(t.width) && S(t.height);
  }

  function v(t, e) {
    return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter;
  }

  function y(e, n, r, s) {
    t.generateMipmap(e);
    i.get(n).__maxMipLevel = Math.log2(Math.max(r, s));
  }

  function E(n, i, r) {
    if (!1 === o) return i;

    if (null !== n) {
      if (void 0 !== t[n]) return t[n];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'");
    }

    var s = i;
    return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s;
  }

  function x(t) {
    return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
  }

  function w(e) {
    var n = e.target;
    n.removeEventListener("dispose", w), function (e) {
      var n = i.get(e);
      if (void 0 === n.__webglInit) return;
      t.deleteTexture(n.__webglTexture), i.remove(e);
    }(n), n.isVideoTexture && d.delete(n), a.memory.textures--;
  }

  function b(e) {
    var n = e.target;
    n.removeEventListener("dispose", b), function (e) {
      var n = e.texture,
          r = i.get(e),
          s = i.get(n);
      if (!e) return;
      void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture);
      e.depthTexture && e.depthTexture.dispose();
      if (e.isWebGLCubeRenderTarget) for (var _e84 = 0; _e84 < 6; _e84++) {
        t.deleteFramebuffer(r.__webglFramebuffer[_e84]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[_e84]);
      } else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
      i.remove(n), i.remove(e);
    }(n), a.memory.textures--;
  }

  var _ = 0;

  function I(t, e) {
    var r = i.get(t);

    if (t.isVideoTexture && function (t) {
      var e = a.render.frame;
      d.get(t) !== e && (d.set(t, e), t.update());
    }(t), t.version > 0 && r.__version !== t.version) {
      var _n91 = t.image;
      if (void 0 === _n91) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else {
        if (!1 !== _n91.complete) return void D(r, t, e);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }

    n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
  }

  function C(e, r) {
    var a = i.get(e);
    e.version > 0 && a.__version !== e.version ? function (e, i, r) {
      if (6 !== i.image.length) return;
      R(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
      var a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
          l = i.image[0] && i.image[0].isDataTexture,
          h = [];

      for (var _t126 = 0; _t126 < 6; _t126++) {
        h[_t126] = a || l ? l ? i.image[_t126].image : i.image[_t126] : m(i.image[_t126], !1, !0, c);
      }

      var u = h[0],
          d = f(u) || o,
          A = s.convert(i.format),
          p = s.convert(i.type),
          g = E(i.internalFormat, A, p);
      var x;

      if (L(34067, i, d), a) {
        for (var _t127 = 0; _t127 < 6; _t127++) {
          x = h[_t127].mipmaps;

          for (var _e85 = 0; _e85 < x.length; _e85++) {
            var _r65 = x[_e85];
            1023 !== i.format && 1022 !== i.format ? null !== A ? n.compressedTexImage2D(34069 + _t127, _e85, g, _r65.width, _r65.height, 0, _r65.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + _t127, _e85, g, _r65.width, _r65.height, 0, A, p, _r65.data);
          }
        }

        e.__maxMipLevel = x.length - 1;
      } else {
        x = i.mipmaps;

        for (var _t128 = 0; _t128 < 6; _t128++) {
          if (l) {
            n.texImage2D(34069 + _t128, 0, g, h[_t128].width, h[_t128].height, 0, A, p, h[_t128].data);

            for (var _e86 = 0; _e86 < x.length; _e86++) {
              var _i78 = x[_e86].image[_t128].image;
              n.texImage2D(34069 + _t128, _e86 + 1, g, _i78.width, _i78.height, 0, A, p, _i78.data);
            }
          } else {
            n.texImage2D(34069 + _t128, 0, g, A, p, h[_t128]);

            for (var _e87 = 0; _e87 < x.length; _e87++) {
              var _i79 = x[_e87];
              n.texImage2D(34069 + _t128, _e87 + 1, g, A, p, _i79.image[_t128]);
            }
          }
        }

        e.__maxMipLevel = x.length;
      }

      v(i, d) && y(34067, i, u.width, u.height);
      e.__version = i.version, i.onUpdate && i.onUpdate(i);
    }(a, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture));
  }

  var M = {
    1e3: 10497,
    1001: 33071,
    1002: 33648
  },
      B = {
    1003: 9728,
    1004: 9984,
    1005: 9986,
    1006: 9729,
    1007: 9985,
    1008: 9987
  };

  function L(n, s, a) {
    if (a ? (t.texParameteri(n, 10242, M[s.wrapS]), t.texParameteri(n, 10243, M[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, M[s.wrapR]), t.texParameteri(n, 10240, B[s.magFilter]), t.texParameteri(n, 10241, B[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), 1001 === s.wrapS && 1001 === s.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, x(s.magFilter)), t.texParameteri(n, 10241, x(s.minFilter)), 1003 !== s.minFilter && 1006 !== s.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
      var _a22 = e.get("EXT_texture_filter_anisotropic");

      if (1015 === s.type && !1 === e.has("OES_texture_float_linear")) return;
      if (!1 === o && 1016 === s.type && !1 === e.has("OES_texture_half_float_linear")) return;
      (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, _a22.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy);
    }
  }

  function R(e, n) {
    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), a.memory.textures++);
  }

  function D(e, i, r) {
    var a = 3553;
    i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), R(e, i), n.activeTexture(33984 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);

    var l = function (t) {
      return !o && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter);
    }(i) && !1 === f(i.image),
        c = m(i.image, l, !1, h),
        u = f(c) || o,
        d = s.convert(i.format);

    var A,
        p = s.convert(i.type),
        g = E(i.internalFormat, d, p);
    L(a, i, u);
    var x = i.mipmaps;
    if (i.isDepthTexture) g = 6402, o ? g = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i.format && 6402 === g && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = 1012, p = s.convert(i.type)), 1027 === i.format && 6402 === g && (g = 34041, 1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = 1020, p = s.convert(i.type))), n.texImage2D(3553, 0, g, c.width, c.height, 0, d, p, null);else if (i.isDataTexture) {
      if (x.length > 0 && u) {
        for (var _t129 = 0, _e88 = x.length; _t129 < _e88; _t129++) {
          A = x[_t129], n.texImage2D(3553, _t129, g, A.width, A.height, 0, d, p, A.data);
        }

        i.generateMipmaps = !1, e.__maxMipLevel = x.length - 1;
      } else n.texImage2D(3553, 0, g, c.width, c.height, 0, d, p, c.data), e.__maxMipLevel = 0;
    } else if (i.isCompressedTexture) {
      for (var _t130 = 0, _e89 = x.length; _t130 < _e89; _t130++) {
        A = x[_t130], 1023 !== i.format && 1022 !== i.format ? null !== d ? n.compressedTexImage2D(3553, _t130, g, A.width, A.height, 0, A.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, _t130, g, A.width, A.height, 0, d, p, A.data);
      }

      e.__maxMipLevel = x.length - 1;
    } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, g, c.width, c.height, c.depth, 0, d, p, c.data), e.__maxMipLevel = 0;else if (i.isDataTexture3D) n.texImage3D(32879, 0, g, c.width, c.height, c.depth, 0, d, p, c.data), e.__maxMipLevel = 0;else if (x.length > 0 && u) {
      for (var _t131 = 0, _e90 = x.length; _t131 < _e90; _t131++) {
        A = x[_t131], n.texImage2D(3553, _t131, g, d, p, A);
      }

      i.generateMipmaps = !1, e.__maxMipLevel = x.length - 1;
    } else n.texImage2D(3553, 0, g, d, p, c), e.__maxMipLevel = 0;
    v(i, u) && y(a, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i);
  }

  function Q(e, r, a, o) {
    var l = r.texture,
        c = s.convert(l.format),
        h = s.convert(l.type),
        u = E(l.internalFormat, c, h);
    32879 === o || 35866 === o ? n.texImage3D(o, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(o, 0, u, r.width, r.height, 0, c, h, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, o, i.get(l).__webglTexture, 0), n.bindFramebuffer(36160, null);
  }

  function P(e, n, i) {
    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
      var _r66 = 33189;

      if (i) {
        var _e91 = n.depthTexture;
        _e91 && _e91.isDepthTexture && (1015 === _e91.type ? _r66 = 36012 : 1014 === _e91.type && (_r66 = 33190));

        var _i80 = N(n);

        t.renderbufferStorageMultisample(36161, _i80, _r66, n.width, n.height);
      } else t.renderbufferStorage(36161, _r66, n.width, n.height);

      t.framebufferRenderbuffer(36160, 36096, 36161, e);
    } else if (n.depthBuffer && n.stencilBuffer) {
      if (i) {
        var _e92 = N(n);

        t.renderbufferStorageMultisample(36161, _e92, 35056, n.width, n.height);
      } else t.renderbufferStorage(36161, 34041, n.width, n.height);

      t.framebufferRenderbuffer(36160, 33306, 36161, e);
    } else {
      var _e93 = n.texture,
          _r67 = s.convert(_e93.format),
          _a23 = s.convert(_e93.type),
          _o14 = E(_e93.internalFormat, _r67, _a23);

      if (i) {
        var _e94 = N(n);

        t.renderbufferStorageMultisample(36161, _e94, _o14, n.width, n.height);
      } else t.renderbufferStorage(36161, _o14, n.width, n.height);
    }

    t.bindRenderbuffer(36161, null);
  }

  function F(e) {
    var r = i.get(e),
        s = !0 === e.isWebGLCubeRenderTarget;

    if (e.depthTexture) {
      if (s) throw new Error("target.depthTexture not supported in Cube render targets");
      !function (e, r) {
        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), I(r.depthTexture, 0);

        var s = i.get(r.depthTexture).__webglTexture;

        if (1026 === r.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, s, 0);else {
          if (1027 !== r.depthTexture.format) throw new Error("Unknown depthTexture format");
          t.framebufferTexture2D(36160, 33306, 3553, s, 0);
        }
      }(r.__webglFramebuffer, e);
    } else if (s) {
      r.__webglDepthbuffer = [];

      for (var _i81 = 0; _i81 < 6; _i81++) {
        n.bindFramebuffer(36160, r.__webglFramebuffer[_i81]), r.__webglDepthbuffer[_i81] = t.createRenderbuffer(), P(r.__webglDepthbuffer[_i81], e, !1);
      }
    } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), P(r.__webglDepthbuffer, e, !1);

    n.bindFramebuffer(36160, null);
  }

  function N(t) {
    return o && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0;
  }

  var U = !1,
      G = !1;
  this.allocateTextureUnit = function () {
    var t = _;
    return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), _ += 1, t;
  }, this.resetTextureUnits = function () {
    _ = 0;
  }, this.setTexture2D = I, this.setTexture2DArray = function (t, e) {
    var r = i.get(t);
    t.version > 0 && r.__version !== t.version ? D(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture));
  }, this.setTexture3D = function (t, e) {
    var r = i.get(t);
    t.version > 0 && r.__version !== t.version ? D(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture));
  }, this.setTextureCube = C, this.setupRenderTarget = function (e) {
    var r = e.texture,
        l = i.get(e),
        c = i.get(r);
    e.addEventListener("dispose", b), c.__webglTexture = t.createTexture(), c.__version = r.version, a.memory.textures++;
    var h = !0 === e.isWebGLCubeRenderTarget,
        u = !0 === e.isWebGLMultisampleRenderTarget,
        d = r.isDataTexture3D || r.isDataTexture2DArray,
        A = f(e) || o;

    if (!o || 1022 !== r.format || 1015 !== r.type && 1016 !== r.type || (r.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
      l.__webglFramebuffer = [];

      for (var _e95 = 0; _e95 < 6; _e95++) {
        l.__webglFramebuffer[_e95] = t.createFramebuffer();
      }
    } else if (l.__webglFramebuffer = t.createFramebuffer(), u) if (o) {
      l.__webglMultisampledFramebuffer = t.createFramebuffer(), l.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);

      var _i82 = s.convert(r.format),
          _a24 = s.convert(r.type),
          _o15 = E(r.internalFormat, _i82, _a24),
          _c14 = N(e);

      t.renderbufferStorageMultisample(36161, _c14, _o15, e.width, e.height), n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(), P(l.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null);
    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");

    if (h) {
      n.bindTexture(34067, c.__webglTexture), L(34067, r, A);

      for (var _t132 = 0; _t132 < 6; _t132++) {
        Q(l.__webglFramebuffer[_t132], e, 36064, 34069 + _t132);
      }

      v(r, A) && y(34067, r, e.width, e.height), n.bindTexture(34067, null);
    } else {
      var _t133 = 3553;
      if (d) if (o) {
        _t133 = r.isDataTexture3D ? 32879 : 35866;
      } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
      n.bindTexture(_t133, c.__webglTexture), L(_t133, r, A), Q(l.__webglFramebuffer, e, 36064, _t133), v(r, A) && y(3553, r, e.width, e.height), n.bindTexture(3553, null);
    }

    e.depthBuffer && F(e);
  }, this.updateRenderTargetMipmap = function (t) {
    var e = t.texture;

    if (v(e, f(t) || o)) {
      var _r68 = t.isWebGLCubeRenderTarget ? 34067 : 3553,
          _s29 = i.get(e).__webglTexture;

      n.bindTexture(_r68, _s29), y(_r68, e, t.width, t.height), n.bindTexture(_r68, null);
    }
  }, this.updateMultisampleRenderTarget = function (e) {
    if (e.isWebGLMultisampleRenderTarget) if (o) {
      var _r69 = e.width,
          _s30 = e.height;
      var _a25 = 16384;
      e.depthBuffer && (_a25 |= 256), e.stencilBuffer && (_a25 |= 1024);

      var _o16 = i.get(e);

      n.bindFramebuffer(36008, _o16.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, _o16.__webglFramebuffer), t.blitFramebuffer(0, 0, _r69, _s30, 0, 0, _r69, _s30, _a25, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, _o16.__webglMultisampledFramebuffer);
    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }, this.safeSetTexture2D = function (t, e) {
    t && t.isWebGLRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U = !0), t = t.texture), I(t, e);
  }, this.safeSetTextureCube = function (t, e) {
    t && t.isWebGLCubeRenderTarget && (!1 === G && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), G = !0), t = t.texture), C(t, e);
  };
}

function vr(t, e, n) {
  var i = n.isWebGL2;
  return {
    convert: function convert(t) {
      var n;
      if (1009 === t) return 5121;
      if (1017 === t) return 32819;
      if (1018 === t) return 32820;
      if (1019 === t) return 33635;
      if (1010 === t) return 5120;
      if (1011 === t) return 5122;
      if (1012 === t) return 5123;
      if (1013 === t) return 5124;
      if (1014 === t) return 5125;
      if (1015 === t) return 5126;
      if (1016 === t) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
      if (1021 === t) return 6406;
      if (1022 === t) return 6407;
      if (1023 === t) return 6408;
      if (1024 === t) return 6409;
      if (1025 === t) return 6410;
      if (1026 === t) return 6402;
      if (1027 === t) return 34041;
      if (1028 === t) return 6403;
      if (1029 === t) return 36244;
      if (1030 === t) return 33319;
      if (1031 === t) return 33320;
      if (1032 === t) return 36248;
      if (1033 === t) return 36249;

      if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
        if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
        if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }

      if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
        if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
        if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }

      if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;

      if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
        if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
        if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
      }

      return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : 1020 === t ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
    }
  };
}

var yr = /*#__PURE__*/function (_nn) {
  _inherits(yr, _nn);

  var _super24 = _createSuper(yr);

  function yr() {
    var _this27;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, yr);

    _this27 = _super24.call(this), _this27.cameras = t;
    return _this27;
  }

  return yr;
}(nn);

yr.prototype.isArrayCamera = !0;

var Er = /*#__PURE__*/function (_Vt4) {
  _inherits(Er, _Vt4);

  var _super25 = _createSuper(Er);

  function Er() {
    var _this28;

    _classCallCheck(this, Er);

    _this28 = _super25.call(this), _this28.type = "Group";
    return _this28;
  }

  return Er;
}(Vt);

Er.prototype.isGroup = !0;
var xr = {
  type: "move"
};

var wr = /*#__PURE__*/function () {
  function wr() {
    _classCallCheck(this, wr);

    this._targetRay = null, this._grip = null, this._hand = null;
  }

  _createClass(wr, [{
    key: "getHandSpace",
    value: function getHandSpace() {
      return null === this._hand && (this._hand = new Er(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
        pinching: !1
      }), this._hand;
    }
  }, {
    key: "getTargetRaySpace",
    value: function getTargetRaySpace() {
      return null === this._targetRay && (this._targetRay = new Er(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new H(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new H()), this._targetRay;
    }
  }, {
    key: "getGripSpace",
    value: function getGripSpace() {
      return null === this._grip && (this._grip = new Er(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new H(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new H()), this._grip;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(t) {
      return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
    }
  }, {
    key: "disconnect",
    value: function disconnect(t) {
      return this.dispatchEvent({
        type: "disconnected",
        data: t
      }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
    }
  }, {
    key: "update",
    value: function update(t, e, n) {
      var i = null,
          r = null,
          s = null;
      var a = this._targetRay,
          o = this._grip,
          l = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) if (null !== a && (i = e.getPose(t.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(xr))), l && t.hand) {
        s = !0;

        var _iterator2 = _createForOfIteratorHelper(t.hand.values()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _i84 = _step2.value;

            var _t134 = e.getJointPose(_i84, n);

            if (void 0 === l.joints[_i84.jointName]) {
              var _t135 = new Er();

              _t135.matrixAutoUpdate = !1, _t135.visible = !1, l.joints[_i84.jointName] = _t135, l.add(_t135);
            }

            var _r71 = l.joints[_i84.jointName];
            null !== _t134 && (_r71.matrix.fromArray(_t134.transform.matrix), _r71.matrix.decompose(_r71.position, _r71.rotation, _r71.scale), _r71.jointRadius = _t134.radius), _r71.visible = null !== _t134;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var _i83 = l.joints["index-finger-tip"],
            _r70 = l.joints["thumb-tip"],
            _a26 = _i83.position.distanceTo(_r70.position),
            _o17 = .02,
            _c15 = .005;

        l.inputState.pinching && _a26 > _o17 + _c15 ? (l.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: t.handedness,
          target: this
        })) : !l.inputState.pinching && _a26 <= _o17 - _c15 && (l.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: t.handedness,
          target: this
        }));
      } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
      return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this;
    }
  }]);

  return wr;
}();

var br = /*#__PURE__*/function (_y7) {
  _inherits(br, _y7);

  var _super26 = _createSuper(br);

  function br(t, e) {
    var _this29;

    _classCallCheck(this, br);

    _this29 = _super26.call(this);

    var n = _assertThisInitialized(_this29),
        i = t.state;

    var r = null,
        s = 1,
        a = null,
        o = "local-floor",
        l = null;
    var c = [],
        h = new Map(),
        u = new nn();
    u.layers.enable(1), u.viewport = new G();
    var d = new nn();
    d.layers.enable(2), d.viewport = new G();
    var A = [u, d],
        p = new yr();
    p.layers.enable(1), p.layers.enable(2);
    var g = null,
        m = null;

    function f(t) {
      var e = h.get(t.inputSource);
      e && e.dispatchEvent({
        type: t.type,
        data: t.inputSource
      });
    }

    function v() {
      h.forEach(function (t, e) {
        t.disconnect(e);
      }), h.clear(), g = null, m = null, i.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), _.stop(), n.isPresenting = !1, n.dispatchEvent({
        type: "sessionend"
      });
    }

    function y(t) {
      var e = r.inputSources;

      for (var _t136 = 0; _t136 < c.length; _t136++) {
        h.set(e[_t136], c[_t136]);
      }

      for (var _e96 = 0; _e96 < t.removed.length; _e96++) {
        var _n92 = t.removed[_e96],
            _i85 = h.get(_n92);

        _i85 && (_i85.dispatchEvent({
          type: "disconnected",
          data: _n92
        }), h.delete(_n92));
      }

      for (var _e97 = 0; _e97 < t.added.length; _e97++) {
        var _n93 = t.added[_e97],
            _i86 = h.get(_n93);

        _i86 && _i86.dispatchEvent({
          type: "connected",
          data: _n93
        });
      }
    }

    _this29.enabled = !1, _this29.isPresenting = !1, _this29.getController = function (t) {
      var e = c[t];
      return void 0 === e && (e = new wr(), c[t] = e), e.getTargetRaySpace();
    }, _this29.getControllerGrip = function (t) {
      var e = c[t];
      return void 0 === e && (e = new wr(), c[t] = e), e.getGripSpace();
    }, _this29.getHand = function (t) {
      var e = c[t];
      return void 0 === e && (e = new wr(), c[t] = e), e.getHandSpace();
    }, _this29.setFramebufferScaleFactor = function (t) {
      s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, _this29.setReferenceSpaceType = function (t) {
      o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, _this29.getReferenceSpace = function () {
      return a;
    }, _this29.getSession = function () {
      return r;
    }, _this29.setSession = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(t) {
        var _t137, _i87, _l15;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(r = t, null !== r)) {
                  _context2.next = 16;
                  break;
                }

                r.addEventListener("select", f), r.addEventListener("selectstart", f), r.addEventListener("selectend", f), r.addEventListener("squeeze", f), r.addEventListener("squeezestart", f), r.addEventListener("squeezeend", f), r.addEventListener("end", v), r.addEventListener("inputsourceschange", y);
                _t137 = e.getContextAttributes();
                _context2.t0 = !0 !== _t137.xrCompatible;

                if (!_context2.t0) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 7;
                return e.makeXRCompatible();

              case 7:
                _i87 = {
                  antialias: _t137.antialias,
                  alpha: _t137.alpha,
                  depth: _t137.depth,
                  stencil: _t137.stencil,
                  framebufferScaleFactor: s
                }, _l15 = new XRWebGLLayer(r, e, _i87);
                r.updateRenderState({
                  baseLayer: _l15
                });
                _context2.next = 11;
                return r.requestReferenceSpace(o);

              case 11:
                a = _context2.sent;

                _.setContext(r);

                _.start();

                n.isPresenting = !0;
                n.dispatchEvent({
                  type: "sessionstart"
                });

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    var E = new H(),
        x = new H();

    function w(t, e) {
      null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert();
    }

    _this29.getCamera = function (t) {
      p.near = d.near = u.near = t.near, p.far = d.far = u.far = t.far, g === p.near && m === p.far || (r.updateRenderState({
        depthNear: p.near,
        depthFar: p.far
      }), g = p.near, m = p.far);
      var e = t.parent,
          n = p.cameras;
      w(p, e);

      for (var _t138 = 0; _t138 < n.length; _t138++) {
        w(n[_t138], e);
      }

      t.matrixWorld.copy(p.matrixWorld), t.matrix.copy(p.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale);
      var i = t.children;

      for (var _t139 = 0, _e98 = i.length; _t139 < _e98; _t139++) {
        i[_t139].updateMatrixWorld(!0);
      }

      return 2 === n.length ? function (t, e, n) {
        E.setFromMatrixPosition(e.matrixWorld), x.setFromMatrixPosition(n.matrixWorld);
        var i = E.distanceTo(x),
            r = e.projectionMatrix.elements,
            s = n.projectionMatrix.elements,
            a = r[14] / (r[10] - 1),
            o = r[14] / (r[10] + 1),
            l = (r[9] + 1) / r[5],
            c = (r[9] - 1) / r[5],
            h = (r[8] - 1) / r[0],
            u = (s[8] + 1) / s[0],
            d = a * h,
            A = a * u,
            p = i / (-h + u),
            g = p * -h;
        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(g), t.translateZ(p), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
        var m = a + p,
            f = o + p,
            v = d - g,
            y = A + (i - g),
            w = l * o / f * m,
            b = c * o / f * m;
        t.projectionMatrix.makePerspective(v, y, w, b, m, f);
      }(p, u, d) : p.projectionMatrix.copy(u.projectionMatrix), p;
    };

    var b = null;

    var _ = new un();

    _.setAnimationLoop(function (t, e) {
      if (l = e.getViewerPose(a), null !== l) {
        var _t140 = l.views,
            _e99 = r.renderState.baseLayer;
        i.bindXRFramebuffer(_e99.framebuffer);

        var _n94 = !1;

        _t140.length !== p.cameras.length && (p.cameras.length = 0, _n94 = !0);

        for (var _i88 = 0; _i88 < _t140.length; _i88++) {
          var _r72 = _t140[_i88],
              _s31 = _e99.getViewport(_r72),
              _a27 = A[_i88];

          _a27.matrix.fromArray(_r72.transform.matrix), _a27.projectionMatrix.fromArray(_r72.projectionMatrix), _a27.viewport.set(_s31.x, _s31.y, _s31.width, _s31.height), 0 === _i88 && p.matrix.copy(_a27.matrix), !0 === _n94 && p.cameras.push(_a27);
        }
      }

      var n = r.inputSources;

      for (var _t141 = 0; _t141 < c.length; _t141++) {
        var _i89 = c[_t141],
            _r73 = n[_t141];

        _i89.update(_r73, e, a);
      }

      b && b(t, e);
    }), _this29.setAnimationLoop = function (t) {
      b = t;
    }, _this29.dispose = function () {};
    return _this29;
  }

  return br;
}(y);

function _r(t) {
  function e(e, n) {
    e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
    var i = t.get(n).envMap;

    if (i) {
      e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;

      var _r74 = t.get(i).__maxMipLevel;

      void 0 !== _r74 && (e.maxMipLevel.value = _r74);
    }

    var r, s;
    n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix));
  }

  function n(e, n) {
    e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
    t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
  }

  return {
    refreshFogUniforms: function refreshFogUniforms(t, e) {
      t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density);
    },
    refreshMaterialUniforms: function refreshMaterialUniforms(t, i, r, s) {
      i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function (t, e) {
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
      }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function (t, e) {
        e.gradientMap && (t.gradientMap.value = e.gradientMap);
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function (t, e) {
        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function (t, e) {
        n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
        t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap);
      }(t, i) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function (t, e) {
        e.matcap && (t.matcap.value = e.matcap);
        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function (t, e) {
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function (t, e) {
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance;
      }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function (t, e) {
        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isLineBasicMaterial ? (function (t, e) {
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity;
      }(t, i), i.isLineDashedMaterial && function (t, e) {
        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale;
      }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) {
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map);
        e.alphaMap && (t.alphaMap.value = e.alphaMap);
        var r;
        e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
        void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix));
      }(t, i, r, s) : i.isSpriteMaterial ? function (t, e) {
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
        e.alphaMap && (t.alphaMap.value = e.alphaMap);
        var n;
        e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix));
      }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
    }
  };
}

function Ir(t) {
  var e = void 0 !== (t = t || {}).canvas ? t.canvas : function () {
    var t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    return t.style.display = "block", t;
  }(),
      n = void 0 !== t.context ? t.context : null,
      i = void 0 !== t.alpha && t.alpha,
      r = void 0 === t.depth || t.depth,
      s = void 0 === t.stencil || t.stencil,
      a = void 0 !== t.antialias && t.antialias,
      o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
      l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
      c = void 0 !== t.powerPreference ? t.powerPreference : "default",
      h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
  var u = null,
      d = null;
  var A = [],
      p = [];
  this.domElement = e, this.debug = {
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
  var g = this;
  var m = !1,
      f = 0,
      v = 0,
      y = null,
      E = -1,
      x = null;
  var w = new G(),
      b = new G();
  var _ = null,
      I = e.width,
      C = e.height,
      M = 1,
      S = null,
      T = null;
  var L = new G(0, 0, I, C),
      D = new G(0, 0, I, C);
  var Q = !1;
  var P = new hn();
  var F = !1,
      N = !1;
  var U = new yt(),
      k = new H(),
      O = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: !0
  };

  function z() {
    return null === y ? M : 1;
  }

  var V,
      W,
      q,
      j,
      Y,
      J,
      X,
      K,
      Z,
      $,
      tt,
      et,
      nt,
      it,
      rt,
      st,
      at,
      ot,
      lt,
      ct,
      ht,
      ut,
      dt = n;

  function At(t, n) {
    for (var _i90 = 0; _i90 < t.length; _i90++) {
      var _r75 = t[_i90],
          _s32 = e.getContext(_r75, n);

      if (null !== _s32) return _s32;
    }

    return null;
  }

  try {
    var _t142 = {
      alpha: i,
      depth: r,
      stencil: s,
      antialias: a,
      premultipliedAlpha: o,
      preserveDrawingBuffer: l,
      powerPreference: c,
      failIfMajorPerformanceCaveat: h
    };

    if (e.addEventListener("webglcontextlost", mt, !1), e.addEventListener("webglcontextrestored", ft, !1), null === dt) {
      var _e100 = ["webgl2", "webgl", "experimental-webgl"];
      if (!0 === g.isWebGL1Renderer && _e100.shift(), dt = At(_e100, _t142), null === dt) throw At(_e100) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }

    void 0 === dt.getShaderPrecisionFormat && (dt.getShaderPrecisionFormat = function () {
      return {
        rangeMin: 1,
        rangeMax: 1,
        precision: 1
      };
    });
  } catch (t) {
    throw console.error("THREE.WebGLRenderer: " + t.message), t;
  }

  function pt() {
    V = new bn(dt), W = new En(dt, V, t), V.init(W), ht = new vr(dt, V, W), q = new mr(dt, V, W), j = new Cn(dt), Y = new nr(), J = new fr(dt, V, q, Y, W, ht, j), X = new wn(g), K = new dn(dt, W), ut = new vn(dt, V, K, W), Z = new _n(dt, K, j, ut), $ = new Tn(dt, Z, K, j), ot = new Bn(dt), rt = new xn(Y), tt = new er(g, X, V, W, ut, rt), et = new _r(Y), nt = new ar(Y), it = new dr(V, W), at = new fn(g, X, q, $, o), st = new gr(g, $, W), lt = new yn(dt, V, j, W), ct = new In(dt, V, j, W), j.programs = tt.programs, g.capabilities = W, g.extensions = V, g.properties = Y, g.renderLists = nt, g.shadowMap = st, g.state = q, g.info = j;
  }

  pt();
  var gt = new br(g, dt);

  function mt(t) {
    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), m = !0;
  }

  function ft() {
    console.log("THREE.WebGLRenderer: Context Restored."), m = !1;
    var t = j.autoReset,
        e = st.enabled,
        n = st.autoUpdate,
        i = st.needsUpdate,
        r = st.type;
    pt(), j.autoReset = t, st.enabled = e, st.autoUpdate = n, st.needsUpdate = i, st.type = r;
  }

  function vt(t) {
    var e = t.target;
    e.removeEventListener("dispose", vt), function (t) {
      (function (t) {
        var e = Y.get(t).programs;
        void 0 !== e && e.forEach(function (t) {
          tt.releaseProgram(t);
        });
      })(t), Y.remove(t);
    }(e);
  }

  this.xr = gt, this.getContext = function () {
    return dt;
  }, this.getContextAttributes = function () {
    return dt.getContextAttributes();
  }, this.forceContextLoss = function () {
    var t = V.get("WEBGL_lose_context");
    t && t.loseContext();
  }, this.forceContextRestore = function () {
    var t = V.get("WEBGL_lose_context");
    t && t.restoreContext();
  }, this.getPixelRatio = function () {
    return M;
  }, this.setPixelRatio = function (t) {
    void 0 !== t && (M = t, this.setSize(I, C, !1));
  }, this.getSize = function (t) {
    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new R()), t.set(I, C);
  }, this.setSize = function (t, n, i) {
    gt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = t, C = n, e.width = Math.floor(t * M), e.height = Math.floor(n * M), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n));
  }, this.getDrawingBufferSize = function (t) {
    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new R()), t.set(I * M, C * M).floor();
  }, this.setDrawingBufferSize = function (t, n, i) {
    I = t, C = n, M = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n);
  }, this.getCurrentViewport = function (t) {
    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new G()), t.copy(w);
  }, this.getViewport = function (t) {
    return t.copy(L);
  }, this.setViewport = function (t, e, n, i) {
    t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, n, i), q.viewport(w.copy(L).multiplyScalar(M).floor());
  }, this.getScissor = function (t) {
    return t.copy(D);
  }, this.setScissor = function (t, e, n, i) {
    t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, i), q.scissor(b.copy(D).multiplyScalar(M).floor());
  }, this.getScissorTest = function () {
    return Q;
  }, this.setScissorTest = function (t) {
    q.setScissorTest(Q = t);
  }, this.setOpaqueSort = function (t) {
    S = t;
  }, this.setTransparentSort = function (t) {
    T = t;
  }, this.getClearColor = function (t) {
    return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new pe()), t.copy(at.getClearColor());
  }, this.setClearColor = function () {
    at.setClearColor.apply(at, arguments);
  }, this.getClearAlpha = function () {
    return at.getClearAlpha();
  }, this.setClearAlpha = function () {
    at.setClearAlpha.apply(at, arguments);
  }, this.clear = function (t, e, n) {
    var i = 0;
    (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), dt.clear(i);
  }, this.clearColor = function () {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function () {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function () {
    this.clear(!1, !1, !0);
  }, this.dispose = function () {
    e.removeEventListener("webglcontextlost", mt, !1), e.removeEventListener("webglcontextrestored", ft, !1), nt.dispose(), it.dispose(), Y.dispose(), X.dispose(), $.dispose(), ut.dispose(), gt.dispose(), gt.removeEventListener("sessionstart", xt), gt.removeEventListener("sessionend", wt), bt.stop();
  }, this.renderBufferImmediate = function (t, e) {
    ut.initAttributes();
    var n = Y.get(t);
    t.hasPositions && !n.position && (n.position = dt.createBuffer()), t.hasNormals && !n.normal && (n.normal = dt.createBuffer()), t.hasUvs && !n.uv && (n.uv = dt.createBuffer()), t.hasColors && !n.color && (n.color = dt.createBuffer());
    var i = e.getAttributes();
    t.hasPositions && (dt.bindBuffer(34962, n.position), dt.bufferData(34962, t.positionArray, 35048), ut.enableAttribute(i.position), dt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (dt.bindBuffer(34962, n.normal), dt.bufferData(34962, t.normalArray, 35048), ut.enableAttribute(i.normal), dt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (dt.bindBuffer(34962, n.uv), dt.bufferData(34962, t.uvArray, 35048), ut.enableAttribute(i.uv), dt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (dt.bindBuffer(34962, n.color), dt.bufferData(34962, t.colorArray, 35048), ut.enableAttribute(i.color), dt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), ut.disableUnusedAttributes(), dt.drawArrays(4, 0, t.count), t.count = 0;
  }, this.renderBufferDirect = function (t, e, n, i, r, s) {
    null === e && (e = O);
    var a = r.isMesh && r.matrixWorld.determinant() < 0,
        o = Bt(t, e, i, r);
    q.setMaterial(i, a);
    var l = n.index;
    var c = n.attributes.position;

    if (null === l) {
      if (void 0 === c || 0 === c.count) return;
    } else if (0 === l.count) return;

    var h,
        u = 1;
    !0 === i.wireframe && (l = Z.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && ot.update(r, n, i, o), ut.setup(r, i, o, n, l);
    var d = lt;
    null !== l && (h = K.get(l), d = ct, d.setIndex(h));
    var A = null !== l ? l.count : c.count,
        p = n.drawRange.start * u,
        g = n.drawRange.count * u,
        m = null !== s ? s.start * u : 0,
        f = null !== s ? s.count * u : 1 / 0,
        v = Math.max(p, m),
        y = Math.min(A, p + g, m + f) - 1,
        E = Math.max(0, y - v + 1);

    if (0 !== E) {
      if (r.isMesh) !0 === i.wireframe ? (q.setLineWidth(i.wireframeLinewidth * z()), d.setMode(1)) : d.setMode(4);else if (r.isLine) {
        var _t143 = i.linewidth;
        void 0 === _t143 && (_t143 = 1), q.setLineWidth(_t143 * z()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3);
      } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
      if (r.isInstancedMesh) d.renderInstances(v, E, r.count);else if (n.isInstancedBufferGeometry) {
        var _t144 = Math.min(n.instanceCount, n._maxInstanceCount);

        d.renderInstances(v, E, _t144);
      } else d.render(v, E);
    }
  }, this.compile = function (t, e) {
    d = it.get(t), d.init(), t.traverseVisible(function (t) {
      t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t));
    }), d.setupLights(), t.traverse(function (e) {
      var n = e.material;
      if (n) if (Array.isArray(n)) for (var _i91 = 0; _i91 < n.length; _i91++) {
        Mt(n[_i91], t, e);
      } else Mt(n, t, e);
    });
  };
  var Et = null;

  function xt() {
    bt.stop();
  }

  function wt() {
    bt.start();
  }

  var bt = new un();

  function _t(t, e, n, i) {
    if (!1 === t.visible) return;
    if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder;else if (t.isLOD) !0 === t.autoUpdate && t.update(e);else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);else if (t.isSprite) {
      if (!t.frustumCulled || P.intersectsSprite(t)) {
        i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);

        var _e101 = $.update(t),
            _r76 = t.material;

        _r76.visible && u.push(t, _e101, _r76, n, k.z, null);
      }
    } else if (t.isImmediateRenderObject) i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U), u.push(t, null, t.material, n, k.z, null);else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || P.intersectsObject(t))) {
      i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);

      var _e102 = $.update(t),
          _r77 = t.material;

      if (Array.isArray(_r77)) {
        var _i92 = _e102.groups;

        for (var _s33 = 0, _a28 = _i92.length; _s33 < _a28; _s33++) {
          var _a29 = _i92[_s33],
              _o18 = _r77[_a29.materialIndex];
          _o18 && _o18.visible && u.push(t, _e102, _o18, n, k.z, _a29);
        }
      } else _r77.visible && u.push(t, _e102, _r77, n, k.z, null);
    }
    var r = t.children;

    for (var _t145 = 0, _s34 = r.length; _t145 < _s34; _t145++) {
      _t(r[_t145], e, n, i);
    }
  }

  function It(t, e, n) {
    var i = !0 === e.isScene ? e.overrideMaterial : null;

    for (var _r78 = 0, _s35 = t.length; _r78 < _s35; _r78++) {
      var _s36 = t[_r78],
          _a30 = _s36.object,
          _o19 = _s36.geometry,
          _l16 = null === i ? _s36.material : i,
          _c16 = _s36.group;

      if (n.isArrayCamera) {
        var _t146 = n.cameras;

        for (var _n95 = 0, _i93 = _t146.length; _n95 < _i93; _n95++) {
          var _i94 = _t146[_n95];
          _a30.layers.test(_i94.layers) && (q.viewport(w.copy(_i94.viewport)), d.setupLightsView(_i94), Ct(_a30, e, _i94, _o19, _l16, _c16));
        }
      } else Ct(_a30, e, n, _o19, _l16, _c16);
    }
  }

  function Ct(t, e, n, i, r, s) {
    if (t.onBeforeRender(g, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
      var _i95 = Bt(n, e, r, t);

      q.setMaterial(r), ut.reset(), function (t, e) {
        t.render(function (t) {
          g.renderBufferImmediate(t, e);
        });
      }(t, _i95);
    } else g.renderBufferDirect(n, e, i, r, t, s);

    t.onAfterRender(g, e, n, i, r, s);
  }

  function Mt(t, e, n) {
    !0 !== e.isScene && (e = O);
    var i = Y.get(t),
        r = d.state.lights,
        s = d.state.shadowsArray,
        a = r.state.version,
        o = tt.getParameters(t, r.state, s, e, n),
        l = tt.getProgramCacheKey(o);
    var c = i.programs;
    i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = X.get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", vt), c = new Map(), i.programs = c);
    var h = c.get(l);

    if (void 0 !== h) {
      if (i.currentProgram === h && i.lightsStateVersion === a) return St(t, o), h;
    } else o.uniforms = tt.getUniforms(t), t.onBuild(o, g), t.onBeforeCompile(o, g), h = tt.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;

    var u = i.uniforms;
    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = rt.uniform), St(t, o), i.needsLights = function (t) {
      return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights;
    }(t), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
    var A = h.getUniforms(),
        p = Qi.seqWithValue(A.seq, u);
    return i.currentProgram = h, i.uniformsList = p, h;
  }

  function St(t, e) {
    var n = Y.get(t);
    n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas;
  }

  function Bt(t, e, n, i) {
    !0 !== e.isScene && (e = O), J.resetTextureUnits();
    var r = e.fog,
        s = n.isMeshStandardMaterial ? e.environment : null,
        a = null === y ? g.outputEncoding : y.texture.encoding,
        o = X.get(n.envMap || s),
        l = !0 === n.vertexColors && i.geometry && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize,
        c = Y.get(n),
        h = d.state.lights;

    if (!0 === F && (!0 === N || t !== x)) {
      var _e103 = t === x && n.id === E;

      rt.setState(n, t, _e103);
    }

    var u = !1;
    n.version === c.__version ? c.needsLights && c.lightsStateVersion !== h.state.version || c.outputEncoding !== a || i.isInstancedMesh && !1 === c.instancing ? u = !0 : i.isInstancedMesh || !0 !== c.instancing ? c.envMap !== o || n.fog && c.fog !== r ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === rt.numPlanes && c.numIntersection === rt.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : (u = !0, c.__version = n.version);
    var A = c.currentProgram;
    !0 === u && (A = Mt(n, e, i));
    var p = !1,
        m = !1,
        f = !1;
    var v = A.getUniforms(),
        w = c.uniforms;

    if (q.useProgram(A.program) && (p = !0, m = !0, f = !0), n.id !== E && (E = n.id, m = !0), p || x !== t) {
      if (v.setValue(dt, "projectionMatrix", t.projectionMatrix), W.logarithmicDepthBuffer && v.setValue(dt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), x !== t && (x = t, m = !0, f = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
        var _e104 = v.map.cameraPosition;
        void 0 !== _e104 && _e104.setValue(dt, k.setFromMatrixPosition(t.matrixWorld));
      }

      (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && v.setValue(dt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && v.setValue(dt, "viewMatrix", t.matrixWorldInverse);
    }

    if (n.skinning) {
      v.setOptional(dt, i, "bindMatrix"), v.setOptional(dt, i, "bindMatrixInverse");
      var _t147 = i.skeleton;

      if (_t147) {
        var _e105 = _t147.bones;

        if (W.floatVertexTextures) {
          if (null === _t147.boneTexture) {
            var _n96 = Math.sqrt(4 * _e105.length);

            _n96 = B(_n96), _n96 = Math.max(_n96, 4);

            var _i96 = new Float32Array(_n96 * _n96 * 4);

            _i96.set(_t147.boneMatrices);

            var _r79 = new on(_i96, _n96, _n96, 1023, 1015);

            _t147.boneMatrices = _i96, _t147.boneTexture = _r79, _t147.boneTextureSize = _n96;
          }

          v.setValue(dt, "boneTexture", _t147.boneTexture, J), v.setValue(dt, "boneTextureSize", _t147.boneTextureSize);
        } else v.setOptional(dt, _t147, "boneMatrices");
      }
    }

    var b, _;

    return (m || c.receiveShadow !== i.receiveShadow) && (c.receiveShadow = i.receiveShadow, v.setValue(dt, "receiveShadow", i.receiveShadow)), m && (v.setValue(dt, "toneMappingExposure", g.toneMappingExposure), c.needsLights && (_ = f, (b = w).ambientLightColor.needsUpdate = _, b.lightProbe.needsUpdate = _, b.directionalLights.needsUpdate = _, b.directionalLightShadows.needsUpdate = _, b.pointLights.needsUpdate = _, b.pointLightShadows.needsUpdate = _, b.spotLights.needsUpdate = _, b.spotLightShadows.needsUpdate = _, b.rectAreaLights.needsUpdate = _, b.hemisphereLights.needsUpdate = _), r && n.fog && et.refreshFogUniforms(w, r), et.refreshMaterialUniforms(w, n, M, C), Qi.upload(dt, c.uniformsList, w, J)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Qi.upload(dt, c.uniformsList, w, J), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && v.setValue(dt, "center", i.center), v.setValue(dt, "modelViewMatrix", i.modelViewMatrix), v.setValue(dt, "normalMatrix", i.normalMatrix), v.setValue(dt, "modelMatrix", i.matrixWorld), A;
  }

  bt.setAnimationLoop(function (t) {
    Et && Et(t);
  }), "undefined" != typeof window && bt.setContext(window), this.setAnimationLoop = function (t) {
    Et = t, gt.setAnimationLoop(t), null === t ? bt.stop() : bt.start();
  }, gt.addEventListener("sessionstart", xt), gt.addEventListener("sessionend", wt), this.render = function (t, e) {
    var n, i;
    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    if (!0 === m) return;
    !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === gt.enabled && !0 === gt.isPresenting && (e = gt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(g, t, e, n || y), d = it.get(t, p.length), d.init(), p.push(d), U.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), P.setFromProjectionMatrix(U), N = this.localClippingEnabled, F = rt.init(this.clippingPlanes, N, e), u = nt.get(t, A.length), u.init(), A.push(u), _t(t, e, 0, g.sortObjects), u.finish(), !0 === g.sortObjects && u.sort(S, T), !0 === F && rt.beginShadows();
    var r = d.state.shadowsArray;
    st.render(r, t, e), d.setupLights(), d.setupLightsView(e), !0 === F && rt.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), at.render(u, t, e, i);
    var s = u.opaque,
        a = u.transparent;
    s.length > 0 && It(s, t, e), a.length > 0 && It(a, t, e), null !== y && (J.updateRenderTargetMipmap(y), J.updateMultisampleRenderTarget(y)), !0 === t.isScene && t.onAfterRender(g, t, e), q.buffers.depth.setTest(!0), q.buffers.depth.setMask(!0), q.buffers.color.setMask(!0), q.setPolygonOffset(!1), ut.resetDefaultState(), E = -1, x = null, p.pop(), d = p.length > 0 ? p[p.length - 1] : null, A.pop(), u = A.length > 0 ? A[A.length - 1] : null;
  }, this.getActiveCubeFace = function () {
    return f;
  }, this.getActiveMipmapLevel = function () {
    return v;
  }, this.getRenderTarget = function () {
    return y;
  }, this.setRenderTarget = function (t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    y = t, f = e, v = n, t && void 0 === Y.get(t).__webglFramebuffer && J.setupRenderTarget(t);
    var i = null,
        r = !1,
        s = !1;

    if (t) {
      var _n97 = t.texture;
      (_n97.isDataTexture3D || _n97.isDataTexture2DArray) && (s = !0);

      var _a31 = Y.get(t).__webglFramebuffer;

      t.isWebGLCubeRenderTarget ? (i = _a31[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? Y.get(t).__webglMultisampledFramebuffer : _a31, w.copy(t.viewport), b.copy(t.scissor), _ = t.scissorTest;
    } else w.copy(L).multiplyScalar(M).floor(), b.copy(D).multiplyScalar(M).floor(), _ = Q;

    if (q.bindFramebuffer(36160, i), q.viewport(w), q.scissor(b), q.setScissorTest(_), r) {
      var _i97 = Y.get(t.texture);

      dt.framebufferTexture2D(36160, 36064, 34069 + e, _i97.__webglTexture, n);
    } else if (s) {
      var _i98 = Y.get(t.texture),
          _r80 = e || 0;

      dt.framebufferTextureLayer(36160, 36064, _i98.__webglTexture, n || 0, _r80);
    }
  }, this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");

    var o = Y.get(t).__webglFramebuffer;

    if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
      q.bindFramebuffer(36160, o);

      try {
        var _a32 = t.texture,
            _o20 = _a32.format,
            _l17 = _a32.type;
        if (1023 !== _o20 && ht.convert(_o20) !== dt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");

        var _c17 = 1016 === _l17 && (V.has("EXT_color_buffer_half_float") || W.isWebGL2 && V.has("EXT_color_buffer_float"));

        if (!(1009 === _l17 || ht.convert(_l17) === dt.getParameter(35738) || 1015 === _l17 && (W.isWebGL2 || V.has("OES_texture_float") || V.has("WEBGL_color_buffer_float")) || _c17)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
        36053 === dt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && dt.readPixels(e, n, i, r, ht.convert(_o20), ht.convert(_l17), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        var _t148 = null !== y ? Y.get(y).__webglFramebuffer : null;

        q.bindFramebuffer(36160, _t148);
      }
    }
  }, this.copyFramebufferToTexture = function (t, e) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = Math.pow(2, -n),
        r = Math.floor(e.image.width * i),
        s = Math.floor(e.image.height * i),
        a = ht.convert(e.format);
    J.setTexture2D(e, 0), dt.copyTexImage2D(3553, n, a, t.x, t.y, r, s, 0), q.unbindTexture();
  }, this.copyTextureToTexture = function (t, e, n) {
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = e.image.width,
        s = e.image.height,
        a = ht.convert(n.format),
        o = ht.convert(n.type);
    J.setTexture2D(n, 0), dt.pixelStorei(37440, n.flipY), dt.pixelStorei(37441, n.premultiplyAlpha), dt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? dt.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? dt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : dt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && dt.generateMipmap(3553), q.unbindTexture();
  }, this.copyTextureToTexture3D = function (t, e, n, i) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    if (g.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
    var _n$image = n.image,
        s = _n$image.width,
        a = _n$image.height,
        o = _n$image.data,
        l = ht.convert(i.format),
        c = ht.convert(i.type);
    var h;
    if (i.isDataTexture3D) J.setTexture3D(i, 0), h = 32879;else {
      if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      J.setTexture2DArray(i, 0), h = 35866;
    }
    dt.pixelStorei(37440, i.flipY), dt.pixelStorei(37441, i.premultiplyAlpha), dt.pixelStorei(3317, i.unpackAlignment);
    var u = dt.getParameter(3314),
        d = dt.getParameter(32878),
        A = dt.getParameter(3316),
        p = dt.getParameter(3315),
        m = dt.getParameter(32877);
    dt.pixelStorei(3314, s), dt.pixelStorei(32878, a), dt.pixelStorei(3316, t.min.x), dt.pixelStorei(3315, t.min.y), dt.pixelStorei(32877, t.min.z), dt.texSubImage3D(h, r, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, c, o), dt.pixelStorei(3314, u), dt.pixelStorei(32878, d), dt.pixelStorei(3316, A), dt.pixelStorei(3315, p), dt.pixelStorei(32877, m), 0 === r && i.generateMipmaps && dt.generateMipmap(h), q.unbindTexture();
  }, this.initTexture = function (t) {
    J.setTexture2D(t, 0), q.unbindTexture();
  }, this.resetState = function () {
    f = 0, v = 0, y = null, q.reset(), ut.reset();
  }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
    detail: this
  }));
}

var Cr = /*#__PURE__*/function (_Ir) {
  _inherits(Cr, _Ir);

  var _super27 = _createSuper(Cr);

  function Cr() {
    _classCallCheck(this, Cr);

    return _super27.apply(this, arguments);
  }

  return Cr;
}(Ir);

Cr.prototype.isWebGL1Renderer = !0;

var Mr = /*#__PURE__*/function (_Vt5) {
  _inherits(Mr, _Vt5);

  var _super28 = _createSuper(Mr);

  function Mr() {
    var _this30;

    _classCallCheck(this, Mr);

    _this30 = _super28.call(this), _this30.type = "Scene", _this30.background = null, _this30.environment = null, _this30.fog = null, _this30.overrideMaterial = null, _this30.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
      detail: _assertThisInitialized(_this30)
    }));
    return _this30;
  }

  _createClass(Mr, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Mr.prototype), "copy", this).call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(Mr.prototype), "toJSON", this).call(this, t);

      return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
    }
  }]);

  return Mr;
}(Vt);

Mr.prototype.isScene = !0;

var Sr = /*#__PURE__*/function () {
  function Sr(t, e) {
    _classCallCheck(this, Sr);

    this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = {
      offset: 0,
      count: -1
    }, this.version = 0, this.uuid = _(), this.onUploadCallback = function () {};
  }

  _createClass(Sr, [{
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }, {
    key: "setUsage",
    value: function setUsage(t) {
      return this.usage = t, this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(t, e, n) {
      t *= this.stride, n *= e.stride;

      for (var _i99 = 0, _r81 = this.stride; _i99 < _r81; _i99++) {
        this.array[t + _i99] = e.array[n + _i99];
      }

      return this;
    }
  }, {
    key: "set",
    value: function set(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.array.set(t, e), this;
    }
  }, {
    key: "clone",
    value: function clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = _()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      var e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
          n = new Sr(e, this.stride);
      return n.setUsage(this.usage), n;
    }
  }, {
    key: "onUpload",
    value: function onUpload(t) {
      return this.onUploadCallback = t, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = _()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }]);

  return Sr;
}();

Sr.prototype.isInterleavedBuffer = !0;
var Br = new H();

var Tr = /*#__PURE__*/function () {
  function Tr(t, e, n, i) {
    _classCallCheck(this, Tr);

    this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i;
  }

  _createClass(Tr, [{
    key: "count",
    get: function get() {
      return this.data.count;
    }
  }, {
    key: "array",
    get: function get() {
      return this.data.array;
    }
  }, {
    key: "needsUpdate",
    set: function set(t) {
      this.data.needsUpdate = t;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      for (var _e106 = 0, _n98 = this.data.count; _e106 < _n98; _e106++) {
        Br.x = this.getX(_e106), Br.y = this.getY(_e106), Br.z = this.getZ(_e106), Br.applyMatrix4(t), this.setXYZ(_e106, Br.x, Br.y, Br.z);
      }

      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(t) {
      for (var _e107 = 0, _n99 = this.count; _e107 < _n99; _e107++) {
        Br.x = this.getX(_e107), Br.y = this.getY(_e107), Br.z = this.getZ(_e107), Br.applyNormalMatrix(t), this.setXYZ(_e107, Br.x, Br.y, Br.z);
      }

      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(t) {
      for (var _e108 = 0, _n100 = this.count; _e108 < _n100; _e108++) {
        Br.x = this.getX(_e108), Br.y = this.getY(_e108), Br.z = this.getZ(_e108), Br.transformDirection(t), this.setXYZ(_e108, Br.x, Br.y, Br.z);
      }

      return this;
    }
  }, {
    key: "setX",
    value: function setX(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this;
    }
  }, {
    key: "setY",
    value: function setY(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    }
  }, {
    key: "setZ",
    value: function setZ(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    }
  }, {
    key: "setW",
    value: function setW(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    }
  }, {
    key: "getX",
    value: function getX(t) {
      return this.data.array[t * this.data.stride + this.offset];
    }
  }, {
    key: "getY",
    value: function getY(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    }
  }, {
    key: "getZ",
    value: function getZ(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    }
  }, {
    key: "getW",
    value: function getW(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    }
  }, {
    key: "setXY",
    value: function setXY(t, e, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(t, e, n, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(t, e, n, i, r) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this;
    }
  }, {
    key: "clone",
    value: function clone(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        var _t149 = [];

        for (var _e109 = 0; _e109 < this.count; _e109++) {
          var _n101 = _e109 * this.data.stride + this.offset;

          for (var _e110 = 0; _e110 < this.itemSize; _e110++) {
            _t149.push(this.data.array[_n101 + _e110]);
          }
        }

        return new ve(new this.array.constructor(_t149), this.itemSize, this.normalized);
      }

      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Tr(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        var _t150 = [];

        for (var _e111 = 0; _e111 < this.count; _e111++) {
          var _n102 = _e111 * this.data.stride + this.offset;

          for (var _e112 = 0; _e112 < this.itemSize; _e112++) {
            _t150.push(this.data.array[_n102 + _e112]);
          }
        }

        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: _t150,
          normalized: this.normalized
        };
      }

      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }]);

  return Tr;
}();

Tr.prototype.isInterleavedBufferAttribute = !0;
var Lr = new H(),
    Rr = new G(),
    Dr = new G(),
    Qr = new H(),
    Pr = new yt();

var Fr = /*#__PURE__*/function (_Ye) {
  _inherits(Fr, _Ye);

  var _super29 = _createSuper(Fr);

  function Fr(t, e) {
    var _this31;

    _classCallCheck(this, Fr);

    _this31 = _super29.call(this, t, e), _this31.type = "SkinnedMesh", _this31.bindMode = "attached", _this31.bindMatrix = new yt(), _this31.bindMatrixInverse = new yt();
    return _this31;
  }

  _createClass(Fr, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Fr.prototype), "copy", this).call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
    }
  }, {
    key: "bind",
    value: function bind(t, e) {
      this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
    }
  }, {
    key: "pose",
    value: function pose() {
      this.skeleton.pose();
    }
  }, {
    key: "normalizeSkinWeights",
    value: function normalizeSkinWeights() {
      var t = new G(),
          e = this.geometry.attributes.skinWeight;

      for (var _n103 = 0, _i100 = e.count; _n103 < _i100; _n103++) {
        t.x = e.getX(_n103), t.y = e.getY(_n103), t.z = e.getZ(_n103), t.w = e.getW(_n103);

        var _i101 = 1 / t.manhattanLength();

        _i101 !== 1 / 0 ? t.multiplyScalar(_i101) : t.set(1, 0, 0, 0), e.setXYZW(_n103, t.x, t.y, t.z, t.w);
      }
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      _get(_getPrototypeOf(Fr.prototype), "updateMatrixWorld", this).call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }, {
    key: "boneTransform",
    value: function boneTransform(t, e) {
      var n = this.skeleton,
          i = this.geometry;
      Rr.fromBufferAttribute(i.attributes.skinIndex, t), Dr.fromBufferAttribute(i.attributes.skinWeight, t), Lr.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);

      for (var _t151 = 0; _t151 < 4; _t151++) {
        var _i102 = Dr.getComponent(_t151);

        if (0 !== _i102) {
          var _r82 = Rr.getComponent(_t151);

          Pr.multiplyMatrices(n.bones[_r82].matrixWorld, n.boneInverses[_r82]), e.addScaledVector(Qr.copy(Lr).applyMatrix4(Pr), _i102);
        }
      }

      return e.applyMatrix4(this.bindMatrixInverse);
    }
  }]);

  return Fr;
}(Ye);

Fr.prototype.isSkinnedMesh = !0;

var Nr = /*#__PURE__*/function (_Vt6) {
  _inherits(Nr, _Vt6);

  var _super30 = _createSuper(Nr);

  function Nr() {
    var _this32;

    _classCallCheck(this, Nr);

    _this32 = _super30.call(this), _this32.type = "Bone";
    return _this32;
  }

  return Nr;
}(Vt);

Nr.prototype.isBone = !0;
var Ur = new yt(),
    Gr = new yt();

var kr = /*#__PURE__*/function () {
  function kr() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, kr);

    this.uuid = _(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }

  _createClass(kr, [{
    key: "init",
    value: function init() {
      var t = this.bones,
          e = this.boneInverses;
      if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();else if (t.length !== e.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];

        for (var _t152 = 0, _e113 = this.bones.length; _t152 < _e113; _t152++) {
          this.boneInverses.push(new yt());
        }
      }
    }
  }, {
    key: "calculateInverses",
    value: function calculateInverses() {
      this.boneInverses.length = 0;

      for (var _t153 = 0, _e114 = this.bones.length; _t153 < _e114; _t153++) {
        var _e115 = new yt();

        this.bones[_t153] && _e115.copy(this.bones[_t153].matrixWorld).invert(), this.boneInverses.push(_e115);
      }
    }
  }, {
    key: "pose",
    value: function pose() {
      for (var _t154 = 0, _e116 = this.bones.length; _t154 < _e116; _t154++) {
        var _e117 = this.bones[_t154];
        _e117 && _e117.matrixWorld.copy(this.boneInverses[_t154]).invert();
      }

      for (var _t155 = 0, _e118 = this.bones.length; _t155 < _e118; _t155++) {
        var _e119 = this.bones[_t155];
        _e119 && (_e119.parent && _e119.parent.isBone ? (_e119.matrix.copy(_e119.parent.matrixWorld).invert(), _e119.matrix.multiply(_e119.matrixWorld)) : _e119.matrix.copy(_e119.matrixWorld), _e119.matrix.decompose(_e119.position, _e119.quaternion, _e119.scale));
      }
    }
  }, {
    key: "update",
    value: function update() {
      var t = this.bones,
          e = this.boneInverses,
          n = this.boneMatrices,
          i = this.boneTexture;

      for (var _i103 = 0, _r83 = t.length; _i103 < _r83; _i103++) {
        var _r84 = t[_i103] ? t[_i103].matrixWorld : Gr;

        Ur.multiplyMatrices(_r84, e[_i103]), Ur.toArray(n, 16 * _i103);
      }

      null !== i && (i.needsUpdate = !0);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new kr(this.bones, this.boneInverses);
    }
  }, {
    key: "getBoneByName",
    value: function getBoneByName(t) {
      for (var _e120 = 0, _n104 = this.bones.length; _e120 < _n104; _e120++) {
        var _n105 = this.bones[_e120];
        if (_n105.name === t) return _n105;
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t, e) {
      this.uuid = t.uuid;

      for (var _n106 = 0, _i104 = t.bones.length; _n106 < _i104; _n106++) {
        var _i105 = t.bones[_n106];
        var _r85 = e[_i105];
        void 0 === _r85 && (console.warn("THREE.Skeleton: No bone found with UUID:", _i105), _r85 = new Nr()), this.bones.push(_r85), this.boneInverses.push(new yt().fromArray(t.boneInverses[_n106]));
      }

      return this.init(), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      t.uuid = this.uuid;
      var e = this.bones,
          n = this.boneInverses;

      for (var _i106 = 0, _r86 = e.length; _i106 < _r86; _i106++) {
        var _r87 = e[_i106];
        t.bones.push(_r87.uuid);
        var _s37 = n[_i106];
        t.boneInverses.push(_s37.toArray());
      }

      return t;
    }
  }]);

  return kr;
}();

var Or = /*#__PURE__*/function (_oe5) {
  _inherits(Or, _oe5);

  var _super31 = _createSuper(Or);

  function Or(t) {
    var _this33;

    _classCallCheck(this, Or);

    _this33 = _super31.call(this), _this33.type = "LineBasicMaterial", _this33.color = new pe(16777215), _this33.linewidth = 1, _this33.linecap = "round", _this33.linejoin = "round", _this33.morphTargets = !1, _this33.setValues(t);
    return _this33;
  }

  _createClass(Or, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Or.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this;
    }
  }]);

  return Or;
}(oe);

Or.prototype.isLineBasicMaterial = !0;
var Hr = new H(),
    zr = new H(),
    Vr = new yt(),
    Wr = new vt(),
    qr = new ht();

var jr = /*#__PURE__*/function (_Vt7) {
  _inherits(jr, _Vt7);

  var _super32 = _createSuper(jr);

  function jr() {
    var _this34;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Te();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Or();

    _classCallCheck(this, jr);

    _this34 = _super32.call(this), _this34.type = "Line", _this34.geometry = t, _this34.material = e, _this34.updateMorphTargets();
    return _this34;
  }

  _createClass(jr, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(jr.prototype), "copy", this).call(this, t), this.material = t.material, this.geometry = t.geometry, this;
    }
  }, {
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var t = this.geometry;
      if (t.isBufferGeometry) {
        if (null === t.index) {
          var _e121 = t.attributes.position,
              _n107 = [0];

          for (var _t156 = 1, _i107 = _e121.count; _t156 < _i107; _t156++) {
            Hr.fromBufferAttribute(_e121, _t156 - 1), zr.fromBufferAttribute(_e121, _t156), _n107[_t156] = _n107[_t156 - 1], _n107[_t156] += Hr.distanceTo(zr);
          }

          t.setAttribute("lineDistance", new xe(_n107, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      } else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Line.threshold,
          s = n.drawRange;
      if (null === n.boundingSphere && n.computeBoundingSphere(), qr.copy(n.boundingSphere), qr.applyMatrix4(i), qr.radius += r, !1 === t.ray.intersectsSphere(qr)) return;
      Vr.copy(i).invert(), Wr.copy(t.ray).applyMatrix4(Vr);
      var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a,
          l = new H(),
          c = new H(),
          h = new H(),
          u = new H(),
          d = this.isLineSegments ? 2 : 1;

      if (n.isBufferGeometry) {
        var _i108 = n.index,
            _r88 = n.attributes.position;

        if (null !== _i108) {
          for (var _n108 = Math.max(0, s.start), _a33 = Math.min(_i108.count, s.start + s.count) - 1; _n108 < _a33; _n108 += d) {
            var _s38 = _i108.getX(_n108),
                _a34 = _i108.getX(_n108 + 1);

            l.fromBufferAttribute(_r88, _s38), c.fromBufferAttribute(_r88, _a34);
            if (Wr.distanceSqToSegment(l, c, u, h) > o) continue;
            u.applyMatrix4(this.matrixWorld);

            var _d9 = t.ray.origin.distanceTo(u);

            _d9 < t.near || _d9 > t.far || e.push({
              distance: _d9,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: _n108,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          for (var _n109 = Math.max(0, s.start), _i109 = Math.min(_r88.count, s.start + s.count) - 1; _n109 < _i109; _n109 += d) {
            l.fromBufferAttribute(_r88, _n109), c.fromBufferAttribute(_r88, _n109 + 1);
            if (Wr.distanceSqToSegment(l, c, u, h) > o) continue;
            u.applyMatrix4(this.matrixWorld);

            var _i110 = t.ray.origin.distanceTo(u);

            _i110 < t.near || _i110 > t.far || e.push({
              distance: _i110,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: _n109,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var t = this.geometry;

      if (t.isBufferGeometry) {
        var _e122 = t.morphAttributes,
            _n110 = Object.keys(_e122);

        if (_n110.length > 0) {
          var _t157 = _e122[_n110[0]];

          if (void 0 !== _t157) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};

            for (var _e123 = 0, _n111 = _t157.length; _e123 < _n111; _e123++) {
              var _n112 = _t157[_e123].name || String(_e123);

              this.morphTargetInfluences.push(0), this.morphTargetDictionary[_n112] = _e123;
            }
          }
        }
      } else {
        var _e124 = t.morphTargets;
        void 0 !== _e124 && _e124.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }]);

  return jr;
}(Vt);

jr.prototype.isLine = !0;
var Yr = new H(),
    Jr = new H();

var Xr = /*#__PURE__*/function (_jr) {
  _inherits(Xr, _jr);

  var _super33 = _createSuper(Xr);

  function Xr(t, e) {
    var _this35;

    _classCallCheck(this, Xr);

    _this35 = _super33.call(this, t, e), _this35.type = "LineSegments";
    return _this35;
  }

  _createClass(Xr, [{
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var t = this.geometry;
      if (t.isBufferGeometry) {
        if (null === t.index) {
          var _e125 = t.attributes.position,
              _n113 = [];

          for (var _t158 = 0, _i111 = _e125.count; _t158 < _i111; _t158 += 2) {
            Yr.fromBufferAttribute(_e125, _t158), Jr.fromBufferAttribute(_e125, _t158 + 1), _n113[_t158] = 0 === _t158 ? 0 : _n113[_t158 - 1], _n113[_t158 + 1] = _n113[_t158] + Yr.distanceTo(Jr);
          }

          t.setAttribute("lineDistance", new xe(_n113, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      } else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
  }]);

  return Xr;
}(jr);

Xr.prototype.isLineSegments = !0;

var Kr = /*#__PURE__*/function (_jr2) {
  _inherits(Kr, _jr2);

  var _super34 = _createSuper(Kr);

  function Kr(t, e) {
    var _this36;

    _classCallCheck(this, Kr);

    _this36 = _super34.call(this, t, e), _this36.type = "LineLoop";
    return _this36;
  }

  return Kr;
}(jr);

Kr.prototype.isLineLoop = !0;

var Zr = /*#__PURE__*/function (_oe6) {
  _inherits(Zr, _oe6);

  var _super35 = _createSuper(Zr);

  function Zr(t) {
    var _this37;

    _classCallCheck(this, Zr);

    _this37 = _super35.call(this), _this37.type = "PointsMaterial", _this37.color = new pe(16777215), _this37.map = null, _this37.alphaMap = null, _this37.size = 1, _this37.sizeAttenuation = !0, _this37.morphTargets = !1, _this37.setValues(t);
    return _this37;
  }

  _createClass(Zr, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Zr.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
    }
  }]);

  return Zr;
}(oe);

Zr.prototype.isPointsMaterial = !0;
var $r = new yt(),
    ts = new vt(),
    es = new ht(),
    ns = new H();

var is = /*#__PURE__*/function (_Vt8) {
  _inherits(is, _Vt8);

  var _super36 = _createSuper(is);

  function is() {
    var _this38;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Te();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Zr();

    _classCallCheck(this, is);

    _this38 = _super36.call(this), _this38.type = "Points", _this38.geometry = t, _this38.material = e, _this38.updateMorphTargets();
    return _this38;
  }

  _createClass(is, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(is.prototype), "copy", this).call(this, t), this.material = t.material, this.geometry = t.geometry, this;
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Points.threshold,
          s = n.drawRange;
      if (null === n.boundingSphere && n.computeBoundingSphere(), es.copy(n.boundingSphere), es.applyMatrix4(i), es.radius += r, !1 === t.ray.intersectsSphere(es)) return;
      $r.copy(i).invert(), ts.copy(t.ray).applyMatrix4($r);
      var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a;

      if (n.isBufferGeometry) {
        var _r89 = n.index,
            _a35 = n.attributes.position;

        if (null !== _r89) {
          for (var _n114 = Math.max(0, s.start), _l18 = Math.min(_r89.count, s.start + s.count); _n114 < _l18; _n114++) {
            var _s39 = _r89.getX(_n114);

            ns.fromBufferAttribute(_a35, _s39), rs(ns, _s39, o, i, t, e, this);
          }
        } else {
          for (var _n115 = Math.max(0, s.start), _r90 = Math.min(_a35.count, s.start + s.count); _n115 < _r90; _n115++) {
            ns.fromBufferAttribute(_a35, _n115), rs(ns, _n115, o, i, t, e, this);
          }
        }
      } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var t = this.geometry;

      if (t.isBufferGeometry) {
        var _e126 = t.morphAttributes,
            _n116 = Object.keys(_e126);

        if (_n116.length > 0) {
          var _t159 = _e126[_n116[0]];

          if (void 0 !== _t159) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};

            for (var _e127 = 0, _n117 = _t159.length; _e127 < _n117; _e127++) {
              var _n118 = _t159[_e127].name || String(_e127);

              this.morphTargetInfluences.push(0), this.morphTargetDictionary[_n118] = _e127;
            }
          }
        }
      } else {
        var _e128 = t.morphTargets;
        void 0 !== _e128 && _e128.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }]);

  return is;
}(Vt);

function rs(t, e, n, i, r, s, a) {
  var o = ts.distanceSqToPoint(t);

  if (o < n) {
    var _n119 = new H();

    ts.closestPointToPoint(t, _n119), _n119.applyMatrix4(i);

    var _l19 = r.ray.origin.distanceTo(_n119);

    if (_l19 < r.near || _l19 > r.far) return;
    s.push({
      distance: _l19,
      distanceToRay: Math.sqrt(o),
      point: _n119,
      index: e,
      face: null,
      object: a
    });
  }
}

is.prototype.isPoints = !0;

var ss = /*#__PURE__*/function (_N5) {
  _inherits(ss, _N5);

  var _super37 = _createSuper(ss);

  function ss(t, e, n, i, r, s, a, o, l, c, h, u) {
    var _this39;

    _classCallCheck(this, ss);

    _this39 = _super37.call(this, null, s, a, o, l, c, i, r, h, u), _this39.image = {
      width: e,
      height: n
    }, _this39.mipmaps = t, _this39.flipY = !1, _this39.generateMipmaps = !1;
    return _this39;
  }

  return ss;
}(N);

ss.prototype.isCompressedTexture = !0;

var as = /*#__PURE__*/function (_N6) {
  _inherits(as, _N6);

  var _super38 = _createSuper(as);

  function as(t, e, n, i, r, s, a, o, l) {
    var _this40;

    _classCallCheck(this, as);

    _this40 = _super38.call(this, t, e, n, i, r, s, a, o, l), _this40.needsUpdate = !0;
    return _this40;
  }

  return as;
}(N);

as.prototype.isCanvasTexture = !0;

var os = /*#__PURE__*/function (_oe7) {
  _inherits(os, _oe7);

  var _super39 = _createSuper(os);

  function os(t) {
    var _this41;

    _classCallCheck(this, os);

    _this41 = _super39.call(this), _this41.type = "ShadowMaterial", _this41.color = new pe(0), _this41.transparent = !0, _this41.setValues(t);
    return _this41;
  }

  _createClass(os, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(os.prototype), "copy", this).call(this, t), this.color.copy(t.color), this;
    }
  }]);

  return os;
}(oe);

os.prototype.isShadowMaterial = !0;

var ls = /*#__PURE__*/function (_tn) {
  _inherits(ls, _tn);

  var _super40 = _createSuper(ls);

  function ls(t) {
    var _this42;

    _classCallCheck(this, ls);

    _this42 = _super40.call(this, t), _this42.type = "RawShaderMaterial";
    return _this42;
  }

  return ls;
}(tn);

ls.prototype.isRawShaderMaterial = !0;

var cs = /*#__PURE__*/function (_oe8) {
  _inherits(cs, _oe8);

  var _super41 = _createSuper(cs);

  function cs(t) {
    var _this43;

    _classCallCheck(this, cs);

    _this43 = _super41.call(this), _this43.defines = {
      STANDARD: ""
    }, _this43.type = "MeshStandardMaterial", _this43.color = new pe(16777215), _this43.roughness = 1, _this43.metalness = 0, _this43.map = null, _this43.lightMap = null, _this43.lightMapIntensity = 1, _this43.aoMap = null, _this43.aoMapIntensity = 1, _this43.emissive = new pe(0), _this43.emissiveIntensity = 1, _this43.emissiveMap = null, _this43.bumpMap = null, _this43.bumpScale = 1, _this43.normalMap = null, _this43.normalMapType = 0, _this43.normalScale = new R(1, 1), _this43.displacementMap = null, _this43.displacementScale = 1, _this43.displacementBias = 0, _this43.roughnessMap = null, _this43.metalnessMap = null, _this43.alphaMap = null, _this43.envMap = null, _this43.envMapIntensity = 1, _this43.refractionRatio = .98, _this43.wireframe = !1, _this43.wireframeLinewidth = 1, _this43.wireframeLinecap = "round", _this43.wireframeLinejoin = "round", _this43.skinning = !1, _this43.morphTargets = !1, _this43.morphNormals = !1, _this43.flatShading = !1, _this43.vertexTangents = !1, _this43.setValues(t);
    return _this43;
  }

  _createClass(cs, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(cs.prototype), "copy", this).call(this, t), this.defines = {
        STANDARD: ""
      }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this;
    }
  }]);

  return cs;
}(oe);

cs.prototype.isMeshStandardMaterial = !0;

var hs = /*#__PURE__*/function (_cs) {
  _inherits(hs, _cs);

  var _super42 = _createSuper(hs);

  function hs(t) {
    var _this44;

    _classCallCheck(this, hs);

    _this44 = _super42.call(this), _this44.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, _this44.type = "MeshPhysicalMaterial", _this44.clearcoat = 0, _this44.clearcoatMap = null, _this44.clearcoatRoughness = 0, _this44.clearcoatRoughnessMap = null, _this44.clearcoatNormalScale = new R(1, 1), _this44.clearcoatNormalMap = null, _this44.reflectivity = .5, Object.defineProperty(_assertThisInitialized(_this44), "ior", {
      get: function get() {
        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity);
      },
      set: function set(t) {
        this.reflectivity = I(2.5 * (t - 1) / (t + 1), 0, 1);
      }
    }), _this44.sheen = null, _this44.transmission = 0, _this44.transmissionMap = null, _this44.setValues(t);
    return _this44;
  }

  _createClass(hs, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(hs.prototype), "copy", this).call(this, t), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new pe()).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this;
    }
  }]);

  return hs;
}(cs);

hs.prototype.isMeshPhysicalMaterial = !0;
var us = {
  arraySlice: function arraySlice(t, e, n) {
    return us.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n);
  },
  convertArray: function convertArray(t, e, n) {
    return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
  },
  isTypedArray: function isTypedArray(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  },
  getKeyframeOrder: function getKeyframeOrder(t) {
    var e = t.length,
        n = new Array(e);

    for (var _t160 = 0; _t160 !== e; ++_t160) {
      n[_t160] = _t160;
    }

    return n.sort(function (e, n) {
      return t[e] - t[n];
    }), n;
  },
  sortedArray: function sortedArray(t, e, n) {
    var i = t.length,
        r = new t.constructor(i);

    for (var _s40 = 0, _a36 = 0; _a36 !== i; ++_s40) {
      var _i112 = n[_s40] * e;

      for (var _n120 = 0; _n120 !== e; ++_n120) {
        r[_a36++] = t[_i112 + _n120];
      }
    }

    return r;
  },
  flattenJSON: function flattenJSON(t, e, n, i) {
    var r = 1,
        s = t[0];

    for (; void 0 !== s && void 0 === s[i];) {
      s = t[r++];
    }

    if (void 0 === s) return;
    var a = s[i];
    if (void 0 !== a) if (Array.isArray(a)) do {
      a = s[i], void 0 !== a && (e.push(s.time), n.push.apply(n, a)), s = t[r++];
    } while (void 0 !== s);else if (void 0 !== a.toArray) do {
      a = s[i], void 0 !== a && (e.push(s.time), a.toArray(n, n.length)), s = t[r++];
    } while (void 0 !== s);else do {
      a = s[i], void 0 !== a && (e.push(s.time), n.push(a)), s = t[r++];
    } while (void 0 !== s);
  },
  subclip: function subclip(t, e, n, i) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;
    var s = t.clone();
    s.name = e;
    var a = [];

    for (var _t161 = 0; _t161 < s.tracks.length; ++_t161) {
      var _e129 = s.tracks[_t161],
          _o21 = _e129.getValueSize(),
          _l20 = [],
          _c18 = [];

      for (var _t162 = 0; _t162 < _e129.times.length; ++_t162) {
        var _s41 = _e129.times[_t162] * r;

        if (!(_s41 < n || _s41 >= i)) {
          _l20.push(_e129.times[_t162]);

          for (var _n121 = 0; _n121 < _o21; ++_n121) {
            _c18.push(_e129.values[_t162 * _o21 + _n121]);
          }
        }
      }

      0 !== _l20.length && (_e129.times = us.convertArray(_l20, _e129.times.constructor), _e129.values = us.convertArray(_c18, _e129.values.constructor), a.push(_e129));
    }

    s.tracks = a;
    var o = 1 / 0;

    for (var _t163 = 0; _t163 < s.tracks.length; ++_t163) {
      o > s.tracks[_t163].times[0] && (o = s.tracks[_t163].times[0]);
    }

    for (var _t164 = 0; _t164 < s.tracks.length; ++_t164) {
      s.tracks[_t164].shift(-1 * o);
    }

    return s.resetDuration(), s;
  },
  makeClipAdditive: function makeClipAdditive(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
    i <= 0 && (i = 30);
    var r = n.tracks.length,
        s = e / i;

    var _loop = function _loop(_e130) {
      var i = n.tracks[_e130],
          r = i.ValueTypeName;
      if ("bool" === r || "string" === r) return "continue";
      var a = t.tracks.find(function (t) {
        return t.name === i.name && t.ValueTypeName === r;
      });
      if (void 0 === a) return "continue";
      var o = 0;
      var l = i.getValueSize();
      i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
      var c = 0;
      var h = a.getValueSize();
      a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
      var u = i.times.length - 1;
      var d = void 0;

      if (s <= i.times[0]) {
        var _t165 = o,
            _e131 = l - o;

        d = us.arraySlice(i.values, _t165, _e131);
      } else if (s >= i.times[u]) {
        var _t166 = u * l + o,
            _e132 = _t166 + l - o;

        d = us.arraySlice(i.values, _t166, _e132);
      } else {
        var _t167 = i.createInterpolant(),
            _e133 = o,
            _n122 = l - o;

        _t167.evaluate(s), d = us.arraySlice(_t167.resultBuffer, _e133, _n122);
      }

      if ("quaternion" === r) {
        new O().fromArray(d).normalize().conjugate().toArray(d);
      }

      var A = a.times.length;

      for (var _t168 = 0; _t168 < A; ++_t168) {
        var _e134 = _t168 * h + c;

        if ("quaternion" === r) O.multiplyQuaternionsFlat(a.values, _e134, d, 0, a.values, _e134);else {
          var _t169 = h - 2 * c;

          for (var _n123 = 0; _n123 < _t169; ++_n123) {
            a.values[_e134 + _n123] -= d[_n123];
          }
        }
      }
    };

    for (var _e130 = 0; _e130 < r; ++_e130) {
      var _ret = _loop(_e130);

      if (_ret === "continue") continue;
    }

    return t.blendMode = 2501, t;
  }
};

var ds = /*#__PURE__*/function () {
  function ds(t, e, n, i) {
    _classCallCheck(this, ds);

    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }

  _createClass(ds, [{
    key: "evaluate",
    value: function evaluate(t) {
      var e = this.parameterPositions;
      var n = this._cachedIndex,
          i = e[n],
          r = e[n - 1];

      t: {
        e: {
          var _s42;

          n: {
            i: if (!(t < i)) {
              for (var _s43 = n + 2;;) {
                if (void 0 === i) {
                  if (t < r) break i;
                  return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r);
                }

                if (n === _s43) break;
                if (r = i, i = e[++n], t < i) break e;
              }

              _s42 = e.length;
              break n;
            }

            if (t >= r) break t;
            {
              var _a37 = e[1];
              t < _a37 && (n = 2, r = _a37);

              for (var _s44 = n - 2;;) {
                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                if (n === _s44) break;
                if (i = r, r = e[--n - 1], t >= r) break e;
              }

              _s42 = n, n = 0;
            }
          }

          for (; n < _s42;) {
            var _i113 = n + _s42 >>> 1;

            t < e[_i113] ? _s42 = _i113 : n = _i113 + 1;
          }

          if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
          if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t);
        }

        this._cachedIndex = n, this.intervalChanged_(n, r, i);
      }

      return this.interpolate_(n, r, t, i);
    }
  }, {
    key: "getSettings_",
    value: function getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
  }, {
    key: "copySampleValue_",
    value: function copySampleValue_(t) {
      var e = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = t * i;

      for (var _t170 = 0; _t170 !== i; ++_t170) {
        e[_t170] = n[r + _t170];
      }

      return e;
    }
  }, {
    key: "interpolate_",
    value: function interpolate_() {
      throw new Error("call to abstract method");
    }
  }, {
    key: "intervalChanged_",
    value: function intervalChanged_() {}
  }]);

  return ds;
}();

ds.prototype.beforeStart_ = ds.prototype.copySampleValue_, ds.prototype.afterEnd_ = ds.prototype.copySampleValue_;

var As = /*#__PURE__*/function (_ds) {
  _inherits(As, _ds);

  var _super43 = _createSuper(As);

  function As(t, e, n, i) {
    var _this45;

    _classCallCheck(this, As);

    _this45 = _super43.call(this, t, e, n, i), _this45._weightPrev = -0, _this45._offsetPrev = -0, _this45._weightNext = -0, _this45._offsetNext = -0, _this45.DefaultSettings_ = {
      endingStart: 2400,
      endingEnd: 2400
    };
    return _this45;
  }

  _createClass(As, [{
    key: "intervalChanged_",
    value: function intervalChanged_(t, e, n) {
      var i = this.parameterPositions;
      var r = t - 2,
          s = t + 1,
          a = i[r],
          o = i[s];
      if (void 0 === a) switch (this.getSettings_().endingStart) {
        case 2401:
          r = t, a = 2 * e - n;
          break;

        case 2402:
          r = i.length - 2, a = e + i[r] - i[r + 1];
          break;

        default:
          r = t, a = n;
      }
      if (void 0 === o) switch (this.getSettings_().endingEnd) {
        case 2401:
          s = t, o = 2 * n - e;
          break;

        case 2402:
          s = 1, o = n + i[1] - i[0];
          break;

        default:
          s = t - 1, o = e;
      }
      var l = .5 * (n - e),
          c = this.valueSize;
      this._weightPrev = l / (e - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c;
    }
  }, {
    key: "interpolate_",
    value: function interpolate_(t, e, n, i) {
      var r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = t * a,
          l = o - a,
          c = this._offsetPrev,
          h = this._offsetNext,
          u = this._weightPrev,
          d = this._weightNext,
          A = (n - e) / (i - e),
          p = A * A,
          g = p * A,
          m = -u * g + 2 * u * p - u * A,
          f = (1 + u) * g + (-1.5 - 2 * u) * p + (-.5 + u) * A + 1,
          v = (-1 - d) * g + (1.5 + d) * p + .5 * A,
          y = d * g - d * p;

      for (var _t171 = 0; _t171 !== a; ++_t171) {
        r[_t171] = m * s[c + _t171] + f * s[l + _t171] + v * s[o + _t171] + y * s[h + _t171];
      }

      return r;
    }
  }]);

  return As;
}(ds);

var ps = /*#__PURE__*/function (_ds2) {
  _inherits(ps, _ds2);

  var _super44 = _createSuper(ps);

  function ps(t, e, n, i) {
    _classCallCheck(this, ps);

    return _super44.call(this, t, e, n, i);
  }

  _createClass(ps, [{
    key: "interpolate_",
    value: function interpolate_(t, e, n, i) {
      var r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = t * a,
          l = o - a,
          c = (n - e) / (i - e),
          h = 1 - c;

      for (var _t172 = 0; _t172 !== a; ++_t172) {
        r[_t172] = s[l + _t172] * h + s[o + _t172] * c;
      }

      return r;
    }
  }]);

  return ps;
}(ds);

var gs = /*#__PURE__*/function (_ds3) {
  _inherits(gs, _ds3);

  var _super45 = _createSuper(gs);

  function gs(t, e, n, i) {
    _classCallCheck(this, gs);

    return _super45.call(this, t, e, n, i);
  }

  _createClass(gs, [{
    key: "interpolate_",
    value: function interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }]);

  return gs;
}(ds);

var ms = /*#__PURE__*/function () {
  function ms(t, e, n, i) {
    _classCallCheck(this, ms);

    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = us.convertArray(e, this.TimeBufferType), this.values = us.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }

  _createClass(ms, [{
    key: "InterpolantFactoryMethodDiscrete",
    value: function InterpolantFactoryMethodDiscrete(t) {
      return new gs(this.times, this.values, this.getValueSize(), t);
    }
  }, {
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(t) {
      return new ps(this.times, this.values, this.getValueSize(), t);
    }
  }, {
    key: "InterpolantFactoryMethodSmooth",
    value: function InterpolantFactoryMethodSmooth(t) {
      return new As(this.times, this.values, this.getValueSize(), t);
    }
  }, {
    key: "setInterpolation",
    value: function setInterpolation(t) {
      var e;

      switch (t) {
        case 2300:
          e = this.InterpolantFactoryMethodDiscrete;
          break;

        case 2301:
          e = this.InterpolantFactoryMethodLinear;
          break;

        case 2302:
          e = this.InterpolantFactoryMethodSmooth;
      }

      if (void 0 === e) {
        var _e135 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(_e135);
          this.setInterpolation(this.DefaultInterpolation);
        }

        return console.warn("THREE.KeyframeTrack:", _e135), this;
      }

      return this.createInterpolant = e, this;
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;

        case this.InterpolantFactoryMethodLinear:
          return 2301;

        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    }
  }, {
    key: "getValueSize",
    value: function getValueSize() {
      return this.values.length / this.times.length;
    }
  }, {
    key: "shift",
    value: function shift(t) {
      if (0 !== t) {
        var _e136 = this.times;

        for (var _n124 = 0, _i114 = _e136.length; _n124 !== _i114; ++_n124) {
          _e136[_n124] += t;
        }
      }

      return this;
    }
  }, {
    key: "scale",
    value: function scale(t) {
      if (1 !== t) {
        var _e137 = this.times;

        for (var _n125 = 0, _i115 = _e137.length; _n125 !== _i115; ++_n125) {
          _e137[_n125] *= t;
        }
      }

      return this;
    }
  }, {
    key: "trim",
    value: function trim(t, e) {
      var n = this.times,
          i = n.length;
      var r = 0,
          s = i - 1;

      for (; r !== i && n[r] < t;) {
        ++r;
      }

      for (; -1 !== s && n[s] > e;) {
        --s;
      }

      if (++s, 0 !== r || s !== i) {
        r >= s && (s = Math.max(s, 1), r = s - 1);

        var _t173 = this.getValueSize();

        this.times = us.arraySlice(n, r, s), this.values = us.arraySlice(this.values, r * _t173, s * _t173);
      }

      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var t = !0;
      var e = this.getValueSize();
      e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
      var n = this.times,
          i = this.values,
          r = n.length;
      0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      var s = null;

      for (var _e138 = 0; _e138 !== r; _e138++) {
        var _i116 = n[_e138];

        if ("number" == typeof _i116 && isNaN(_i116)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, _e138, _i116), t = !1;
          break;
        }

        if (null !== s && s > _i116) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, _e138, _i116, s), t = !1;
          break;
        }

        s = _i116;
      }

      if (void 0 !== i && us.isTypedArray(i)) for (var _e139 = 0, _n126 = i.length; _e139 !== _n126; ++_e139) {
        var _n127 = i[_e139];

        if (isNaN(_n127)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, _e139, _n127), t = !1;
          break;
        }
      }
      return t;
    }
  }, {
    key: "optimize",
    value: function optimize() {
      var t = us.arraySlice(this.times),
          e = us.arraySlice(this.values),
          n = this.getValueSize(),
          i = 2302 === this.getInterpolation(),
          r = t.length - 1;
      var s = 1;

      for (var _a38 = 1; _a38 < r; ++_a38) {
        var _r91 = !1;

        var _o22 = t[_a38];
        if (_o22 !== t[_a38 + 1] && (1 !== _a38 || _o22 !== t[0])) if (i) _r91 = !0;else {
          var _t174 = _a38 * n,
              _i117 = _t174 - n,
              _s45 = _t174 + n;

          for (var _a39 = 0; _a39 !== n; ++_a39) {
            var _n128 = e[_t174 + _a39];

            if (_n128 !== e[_i117 + _a39] || _n128 !== e[_s45 + _a39]) {
              _r91 = !0;
              break;
            }
          }
        }

        if (_r91) {
          if (_a38 !== s) {
            t[s] = t[_a38];

            var _i118 = _a38 * n,
                _r92 = s * n;

            for (var _t175 = 0; _t175 !== n; ++_t175) {
              e[_r92 + _t175] = e[_i118 + _t175];
            }
          }

          ++s;
        }
      }

      if (r > 0) {
        t[s] = t[r];

        for (var _t176 = r * n, _i119 = s * n, _a40 = 0; _a40 !== n; ++_a40) {
          e[_i119 + _a40] = e[_t176 + _a40];
        }

        ++s;
      }

      return s !== t.length ? (this.times = us.arraySlice(t, 0, s), this.values = us.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var t = us.arraySlice(this.times, 0),
          e = us.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, t, e);
      return n.createInterpolant = this.createInterpolant, n;
    }
  }], [{
    key: "toJSON",
    value: function toJSON(t) {
      var e = t.constructor;
      var n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);else {
        n = {
          name: t.name,
          times: us.convertArray(t.times, Array),
          values: us.convertArray(t.values, Array)
        };

        var _e140 = t.getInterpolation();

        _e140 !== t.DefaultInterpolation && (n.interpolation = _e140);
      }
      return n.type = t.ValueTypeName, n;
    }
  }]);

  return ms;
}();

ms.prototype.TimeBufferType = Float32Array, ms.prototype.ValueBufferType = Float32Array, ms.prototype.DefaultInterpolation = 2301;

var fs = /*#__PURE__*/function (_ms) {
  _inherits(fs, _ms);

  var _super46 = _createSuper(fs);

  function fs() {
    _classCallCheck(this, fs);

    return _super46.apply(this, arguments);
  }

  return fs;
}(ms);

fs.prototype.ValueTypeName = "bool", fs.prototype.ValueBufferType = Array, fs.prototype.DefaultInterpolation = 2300, fs.prototype.InterpolantFactoryMethodLinear = void 0, fs.prototype.InterpolantFactoryMethodSmooth = void 0;

var vs = /*#__PURE__*/function (_ms2) {
  _inherits(vs, _ms2);

  var _super47 = _createSuper(vs);

  function vs() {
    _classCallCheck(this, vs);

    return _super47.apply(this, arguments);
  }

  return vs;
}(ms);

vs.prototype.ValueTypeName = "color";

var ys = /*#__PURE__*/function (_ms3) {
  _inherits(ys, _ms3);

  var _super48 = _createSuper(ys);

  function ys() {
    _classCallCheck(this, ys);

    return _super48.apply(this, arguments);
  }

  return ys;
}(ms);

ys.prototype.ValueTypeName = "number";

var Es = /*#__PURE__*/function (_ds4) {
  _inherits(Es, _ds4);

  var _super49 = _createSuper(Es);

  function Es(t, e, n, i) {
    _classCallCheck(this, Es);

    return _super49.call(this, t, e, n, i);
  }

  _createClass(Es, [{
    key: "interpolate_",
    value: function interpolate_(t, e, n, i) {
      var r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = (n - e) / (i - e);
      var l = t * a;

      for (var _t177 = l + a; l !== _t177; l += 4) {
        O.slerpFlat(r, 0, s, l - a, s, l, o);
      }

      return r;
    }
  }]);

  return Es;
}(ds);

var xs = /*#__PURE__*/function (_ms4) {
  _inherits(xs, _ms4);

  var _super50 = _createSuper(xs);

  function xs() {
    _classCallCheck(this, xs);

    return _super50.apply(this, arguments);
  }

  _createClass(xs, [{
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(t) {
      return new Es(this.times, this.values, this.getValueSize(), t);
    }
  }]);

  return xs;
}(ms);

xs.prototype.ValueTypeName = "quaternion", xs.prototype.DefaultInterpolation = 2301, xs.prototype.InterpolantFactoryMethodSmooth = void 0;

var ws = /*#__PURE__*/function (_ms5) {
  _inherits(ws, _ms5);

  var _super51 = _createSuper(ws);

  function ws() {
    _classCallCheck(this, ws);

    return _super51.apply(this, arguments);
  }

  return ws;
}(ms);

ws.prototype.ValueTypeName = "string", ws.prototype.ValueBufferType = Array, ws.prototype.DefaultInterpolation = 2300, ws.prototype.InterpolantFactoryMethodLinear = void 0, ws.prototype.InterpolantFactoryMethodSmooth = void 0;

var bs = /*#__PURE__*/function (_ms6) {
  _inherits(bs, _ms6);

  var _super52 = _createSuper(bs);

  function bs() {
    _classCallCheck(this, bs);

    return _super52.apply(this, arguments);
  }

  return bs;
}(ms);

bs.prototype.ValueTypeName = "vector";

var _s = /*#__PURE__*/function () {
  function _s(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2500;

    _classCallCheck(this, _s);

    this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = _(), this.duration < 0 && this.resetDuration();
  }

  _createClass(_s, [{
    key: "resetDuration",
    value: function resetDuration() {
      var t = 0;

      for (var _e141 = 0, _n129 = this.tracks.length; _e141 !== _n129; ++_e141) {
        var _n130 = this.tracks[_e141];
        t = Math.max(t, _n130.times[_n130.times.length - 1]);
      }

      return this.duration = t, this;
    }
  }, {
    key: "trim",
    value: function trim() {
      for (var _t178 = 0; _t178 < this.tracks.length; _t178++) {
        this.tracks[_t178].trim(0, this.duration);
      }

      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var t = !0;

      for (var _e142 = 0; _e142 < this.tracks.length; _e142++) {
        t = t && this.tracks[_e142].validate();
      }

      return t;
    }
  }, {
    key: "optimize",
    value: function optimize() {
      for (var _t179 = 0; _t179 < this.tracks.length; _t179++) {
        this.tracks[_t179].optimize();
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var t = [];

      for (var _e143 = 0; _e143 < this.tracks.length; _e143++) {
        t.push(this.tracks[_e143].clone());
      }

      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.constructor.toJSON(this);
    }
  }], [{
    key: "parse",
    value: function parse(t) {
      var e = [],
          n = t.tracks,
          i = 1 / (t.fps || 1);

      for (var _t180 = 0, _r93 = n.length; _t180 !== _r93; ++_t180) {
        e.push(Is(n[_t180]).scale(i));
      }

      var r = new this(t.name, t.duration, e, t.blendMode);
      return r.uuid = t.uuid, r;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = [],
          n = t.tracks,
          i = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode
      };

      for (var _t181 = 0, _i120 = n.length; _t181 !== _i120; ++_t181) {
        e.push(ms.toJSON(n[_t181]));
      }

      return i;
    }
  }, {
    key: "CreateFromMorphTargetSequence",
    value: function CreateFromMorphTargetSequence(t, e, n, i) {
      var r = e.length,
          s = [];

      for (var _t182 = 0; _t182 < r; _t182++) {
        var _a41 = [],
            _o23 = [];
        _a41.push((_t182 + r - 1) % r, _t182, (_t182 + 1) % r), _o23.push(0, 1, 0);

        var _l21 = us.getKeyframeOrder(_a41);

        _a41 = us.sortedArray(_a41, 1, _l21), _o23 = us.sortedArray(_o23, 1, _l21), i || 0 !== _a41[0] || (_a41.push(r), _o23.push(_o23[0])), s.push(new ys(".morphTargetInfluences[" + e[_t182].name + "]", _a41, _o23).scale(1 / n));
      }

      return new this(t, -1, s);
    }
  }, {
    key: "findByName",
    value: function findByName(t, e) {
      var n = t;

      if (!Array.isArray(t)) {
        var _e144 = t;
        n = _e144.geometry && _e144.geometry.animations || _e144.animations;
      }

      for (var _t183 = 0; _t183 < n.length; _t183++) {
        if (n[_t183].name === e) return n[_t183];
      }

      return null;
    }
  }, {
    key: "CreateClipsFromMorphTargetSequences",
    value: function CreateClipsFromMorphTargetSequences(t, e, n) {
      var i = {},
          r = /^([\w-]*?)([\d]+)$/;

      for (var _e145 = 0, _n131 = t.length; _e145 < _n131; _e145++) {
        var _n132 = t[_e145],
            _s46 = _n132.name.match(r);

        if (_s46 && _s46.length > 1) {
          var _t184 = _s46[1];
          var _e146 = i[_t184];
          _e146 || (i[_t184] = _e146 = []), _e146.push(_n132);
        }
      }

      var s = [];

      for (var _t185 in i) {
        s.push(this.CreateFromMorphTargetSequence(_t185, i[_t185], e, n));
      }

      return s;
    }
  }, {
    key: "parseAnimation",
    value: function parseAnimation(t, e) {
      if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;

      var n = function n(t, e, _n133, i, r) {
        if (0 !== _n133.length) {
          var _s47 = [],
              _a42 = [];
          us.flattenJSON(_n133, _s47, _a42, i), 0 !== _s47.length && r.push(new t(e, _s47, _a42));
        }
      },
          i = [],
          r = t.name || "default",
          s = t.fps || 30,
          a = t.blendMode;

      var o = t.length || -1;
      var l = t.hierarchy || [];

      for (var _t186 = 0; _t186 < l.length; _t186++) {
        var _r94 = l[_t186].keys;
        if (_r94 && 0 !== _r94.length) if (_r94[0].morphTargets) {
          var _t187 = {};

          var _e147 = void 0;

          for (_e147 = 0; _e147 < _r94.length; _e147++) {
            if (_r94[_e147].morphTargets) for (var _n134 = 0; _n134 < _r94[_e147].morphTargets.length; _n134++) {
              _t187[_r94[_e147].morphTargets[_n134]] = -1;
            }
          }

          for (var _n135 in _t187) {
            var _t188 = [],
                _s48 = [];

            for (var _i121 = 0; _i121 !== _r94[_e147].morphTargets.length; ++_i121) {
              var _i122 = _r94[_e147];
              _t188.push(_i122.time), _s48.push(_i122.morphTarget === _n135 ? 1 : 0);
            }

            i.push(new ys(".morphTargetInfluence[" + _n135 + "]", _t188, _s48));
          }

          o = _t187.length * (s || 1);
        } else {
          var _s49 = ".bones[" + e[_t186].name + "]";

          n(bs, _s49 + ".position", _r94, "pos", i), n(xs, _s49 + ".quaternion", _r94, "rot", i), n(bs, _s49 + ".scale", _r94, "scl", i);
        }
      }

      if (0 === i.length) return null;
      return new this(r, o, i, a);
    }
  }]);

  return _s;
}();

function Is(t) {
  if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");

  var e = function (t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return ys;

      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return bs;

      case "color":
        return vs;

      case "quaternion":
        return xs;

      case "bool":
      case "boolean":
        return fs;

      case "string":
        return ws;
    }

    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }(t.type);

  if (void 0 === t.times) {
    var _e148 = [],
        _n136 = [];
    us.flattenJSON(t.keys, _e148, _n136, "value"), t.times = _e148, t.values = _n136;
  }

  return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
}

var Cs = {
  enabled: !1,
  files: {},
  add: function add(t, e) {
    !1 !== this.enabled && (this.files[t] = e);
  },
  get: function get(t) {
    if (!1 !== this.enabled) return this.files[t];
  },
  remove: function remove(t) {
    delete this.files[t];
  },
  clear: function clear() {
    this.files = {};
  }
};
var Ms = new ( /*#__PURE__*/function () {
  function _class(t, e, n) {
    _classCallCheck(this, _class);

    var i = this;
    var r,
        s = !1,
        a = 0,
        o = 0;
    var l = [];
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
      o++, !1 === s && void 0 !== i.onStart && i.onStart(t, a, o), s = !0;
    }, this.itemEnd = function (t) {
      a++, void 0 !== i.onProgress && i.onProgress(t, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad());
    }, this.itemError = function (t) {
      void 0 !== i.onError && i.onError(t);
    }, this.resolveURL = function (t) {
      return r ? r(t) : t;
    }, this.setURLModifier = function (t) {
      return r = t, this;
    }, this.addHandler = function (t, e) {
      return l.push(t, e), this;
    }, this.removeHandler = function (t) {
      var e = l.indexOf(t);
      return -1 !== e && l.splice(e, 2), this;
    }, this.getHandler = function (t) {
      for (var _e149 = 0, _n137 = l.length; _e149 < _n137; _e149 += 2) {
        var _n138 = l[_e149],
            _i123 = l[_e149 + 1];
        if (_n138.global && (_n138.lastIndex = 0), _n138.test(t)) return _i123;
      }

      return null;
    };
  }

  return _class;
}())();

var Ss = /*#__PURE__*/function () {
  function Ss(t) {
    _classCallCheck(this, Ss);

    this.manager = void 0 !== t ? t : Ms, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }

  _createClass(Ss, [{
    key: "load",
    value: function load() {}
  }, {
    key: "loadAsync",
    value: function loadAsync(t, e) {
      var n = this;
      return new Promise(function (i, r) {
        n.load(t, i, e, r);
      });
    }
  }, {
    key: "parse",
    value: function parse() {}
  }, {
    key: "setCrossOrigin",
    value: function setCrossOrigin(t) {
      return this.crossOrigin = t, this;
    }
  }, {
    key: "setWithCredentials",
    value: function setWithCredentials(t) {
      return this.withCredentials = t, this;
    }
  }, {
    key: "setPath",
    value: function setPath(t) {
      return this.path = t, this;
    }
  }, {
    key: "setResourcePath",
    value: function setResourcePath(t) {
      return this.resourcePath = t, this;
    }
  }, {
    key: "setRequestHeader",
    value: function setRequestHeader(t) {
      return this.requestHeader = t, this;
    }
  }]);

  return Ss;
}();

var Bs = {};

var Ts = /*#__PURE__*/function (_Ss) {
  _inherits(Ts, _Ss);

  var _super53 = _createSuper(Ts);

  function Ts(t) {
    _classCallCheck(this, Ts);

    return _super53.call(this, t);
  }

  _createClass(Ts, [{
    key: "load",
    value: function load(t, e, n, i) {
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      var r = this,
          s = Cs.get(t);
      if (void 0 !== s) return r.manager.itemStart(t), setTimeout(function () {
        e && e(s), r.manager.itemEnd(t);
      }, 0), s;
      if (void 0 !== Bs[t]) return void Bs[t].push({
        onLoad: e,
        onProgress: n,
        onError: i
      });
      var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
      var o;

      if (a) {
        var _n139 = a[1],
            _s50 = !!a[2];

        var _o24 = a[3];
        _o24 = decodeURIComponent(_o24), _s50 && (_o24 = atob(_o24));

        try {
          var _i124;

          var _s51 = (this.responseType || "").toLowerCase();

          switch (_s51) {
            case "arraybuffer":
            case "blob":
              var _t189 = new Uint8Array(_o24.length);

              for (var _e151 = 0; _e151 < _o24.length; _e151++) {
                _t189[_e151] = _o24.charCodeAt(_e151);
              }

              _i124 = "blob" === _s51 ? new Blob([_t189.buffer], {
                type: _n139
              }) : _t189.buffer;
              break;

            case "document":
              var _e150 = new DOMParser();

              _i124 = _e150.parseFromString(_o24, _n139);
              break;

            case "json":
              _i124 = JSON.parse(_o24);
              break;

            default:
              _i124 = _o24;
          }

          setTimeout(function () {
            e && e(_i124), r.manager.itemEnd(t);
          }, 0);
        } catch (e) {
          setTimeout(function () {
            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
          }, 0);
        }
      } else {
        Bs[t] = [], Bs[t].push({
          onLoad: e,
          onProgress: n,
          onError: i
        }), o = new XMLHttpRequest(), o.open("GET", t, !0), o.addEventListener("load", function (e) {
          var n = this.response,
              i = Bs[t];

          if (delete Bs[t], 200 === this.status || 0 === this.status) {
            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Cs.add(t, n);

            for (var _t190 = 0, _e152 = i.length; _t190 < _e152; _t190++) {
              var _e153 = i[_t190];
              _e153.onLoad && _e153.onLoad(n);
            }

            r.manager.itemEnd(t);
          } else {
            for (var _t191 = 0, _n140 = i.length; _t191 < _n140; _t191++) {
              var _n141 = i[_t191];
              _n141.onError && _n141.onError(e);
            }

            r.manager.itemError(t), r.manager.itemEnd(t);
          }
        }, !1), o.addEventListener("progress", function (e) {
          var n = Bs[t];

          for (var _t192 = 0, _i125 = n.length; _t192 < _i125; _t192++) {
            var _i126 = n[_t192];
            _i126.onProgress && _i126.onProgress(e);
          }
        }, !1), o.addEventListener("error", function (e) {
          var n = Bs[t];
          delete Bs[t];

          for (var _t193 = 0, _i127 = n.length; _t193 < _i127; _t193++) {
            var _i128 = n[_t193];
            _i128.onError && _i128.onError(e);
          }

          r.manager.itemError(t), r.manager.itemEnd(t);
        }, !1), o.addEventListener("abort", function (e) {
          var n = Bs[t];
          delete Bs[t];

          for (var _t194 = 0, _i129 = n.length; _t194 < _i129; _t194++) {
            var _i130 = n[_t194];
            _i130.onError && _i130.onError(e);
          }

          r.manager.itemError(t), r.manager.itemEnd(t);
        }, !1), void 0 !== this.responseType && (o.responseType = this.responseType), void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials), o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");

        for (var _t195 in this.requestHeader) {
          o.setRequestHeader(_t195, this.requestHeader[_t195]);
        }

        o.send(null);
      }

      return r.manager.itemStart(t), o;
    }
  }, {
    key: "setResponseType",
    value: function setResponseType(t) {
      return this.responseType = t, this;
    }
  }, {
    key: "setMimeType",
    value: function setMimeType(t) {
      return this.mimeType = t, this;
    }
  }]);

  return Ts;
}(Ss);

var Ls = /*#__PURE__*/function (_Ss2) {
  _inherits(Ls, _Ss2);

  var _super54 = _createSuper(Ls);

  function Ls(t) {
    _classCallCheck(this, Ls);

    return _super54.call(this, t);
  }

  _createClass(Ls, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
          s = [],
          a = new ss(),
          o = new Ts(this.manager);
      o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
      var l = 0;

      function c(c) {
        o.load(t[c], function (t) {
          var n = r.parse(t, !0);
          s[c] = {
            width: n.width,
            height: n.height,
            format: n.format,
            mipmaps: n.mipmaps
          }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = 1006), a.image = s, a.format = n.format, a.needsUpdate = !0, e && e(a));
        }, n, i);
      }

      if (Array.isArray(t)) for (var _e154 = 0, _n142 = t.length; _e154 < _n142; ++_e154) {
        c(_e154);
      } else o.load(t, function (t) {
        var n = r.parse(t, !0);

        if (n.isCubemap) {
          var _t196 = n.mipmaps.length / n.mipmapCount;

          for (var _e155 = 0; _e155 < _t196; _e155++) {
            s[_e155] = {
              mipmaps: []
            };

            for (var _t197 = 0; _t197 < n.mipmapCount; _t197++) {
              s[_e155].mipmaps.push(n.mipmaps[_e155 * n.mipmapCount + _t197]), s[_e155].format = n.format, s[_e155].width = n.width, s[_e155].height = n.height;
            }
          }

          a.image = s;
        } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;

        1 === n.mipmapCount && (a.minFilter = 1006), a.format = n.format, a.needsUpdate = !0, e && e(a);
      }, n, i);
      return a;
    }
  }]);

  return Ls;
}(Ss);

var Rs = /*#__PURE__*/function (_Ss3) {
  _inherits(Rs, _Ss3);

  var _super55 = _createSuper(Rs);

  function Rs(t) {
    _classCallCheck(this, Rs);

    return _super55.call(this, t);
  }

  _createClass(Rs, [{
    key: "load",
    value: function load(t, e, n, i) {
      void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      var r = this,
          s = Cs.get(t);
      if (void 0 !== s) return r.manager.itemStart(t), setTimeout(function () {
        e && e(s), r.manager.itemEnd(t);
      }, 0), s;
      var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

      function o() {
        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), Cs.add(t, this), e && e(this), r.manager.itemEnd(t);
      }

      function l(e) {
        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }

      return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a;
    }
  }]);

  return Rs;
}(Ss);

var Ds = /*#__PURE__*/function (_Ss4) {
  _inherits(Ds, _Ss4);

  var _super56 = _createSuper(Ds);

  function Ds(t) {
    _classCallCheck(this, Ds);

    return _super56.call(this, t);
  }

  _createClass(Ds, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = new sn(),
          s = new Rs(this.manager);
      s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
      var a = 0;

      function o(n) {
        s.load(t[n], function (t) {
          r.images[n] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r));
        }, void 0, i);
      }

      for (var _e156 = 0; _e156 < t.length; ++_e156) {
        o(_e156);
      }

      return r;
    }
  }]);

  return Ds;
}(Ss);

var Qs = /*#__PURE__*/function (_Ss5) {
  _inherits(Qs, _Ss5);

  var _super57 = _createSuper(Qs);

  function Qs(t) {
    _classCallCheck(this, Qs);

    return _super57.call(this, t);
  }

  _createClass(Qs, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
          s = new on(),
          a = new Ts(this.manager);
      return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(t, function (t) {
        var n = r.parse(t);
        n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001, s.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001, s.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006, s.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = 1008), 1 === n.mipmapCount && (s.minFilter = 1006), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n));
      }, n, i), s;
    }
  }]);

  return Qs;
}(Ss);

var Ps = /*#__PURE__*/function (_Ss6) {
  _inherits(Ps, _Ss6);

  var _super58 = _createSuper(Ps);

  function Ps(t) {
    _classCallCheck(this, Ps);

    return _super58.call(this, t);
  }

  _createClass(Ps, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = new N(),
          s = new Rs(this.manager);
      return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, function (n) {
        r.image = n;
        var i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
        r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== e && e(r);
      }, n, i), r;
    }
  }]);

  return Ps;
}(Ss);

var Fs = /*#__PURE__*/function (_Vt9) {
  _inherits(Fs, _Vt9);

  var _super59 = _createSuper(Fs);

  function Fs(t) {
    var _this46;

    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    _classCallCheck(this, Fs);

    _this46 = _super59.call(this), _this46.type = "Light", _this46.color = new pe(t), _this46.intensity = e;
    return _this46;
  }

  _createClass(Fs, [{
    key: "dispose",
    value: function dispose() {}
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Fs.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(Fs.prototype), "toJSON", this).call(this, t);

      return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
    }
  }]);

  return Fs;
}(Vt);

Fs.prototype.isLight = !0;
var Ns = new yt(),
    Us = new H(),
    Gs = new H();

var ks = /*#__PURE__*/function () {
  function ks(t) {
    _classCallCheck(this, ks);

    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new R(512, 512), this.map = null, this.mapPass = null, this.matrix = new yt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new hn(), this._frameExtents = new R(1, 1), this._viewportCount = 1, this._viewports = [new G(0, 0, 1, 1)];
  }

  _createClass(ks, [{
    key: "getViewportCount",
    value: function getViewportCount() {
      return this._viewportCount;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this._frustum;
    }
  }, {
    key: "updateMatrices",
    value: function updateMatrices(t) {
      var e = this.camera,
          n = this.matrix;
      Us.setFromMatrixPosition(t.matrixWorld), e.position.copy(Us), Gs.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Gs), e.updateMatrixWorld(), Ns.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ns), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
    }
  }, {
    key: "getViewport",
    value: function getViewport(t) {
      return this._viewports[t];
    }
  }, {
    key: "getFrameExtents",
    value: function getFrameExtents() {
      return this._frameExtents;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {};
      return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    }
  }]);

  return ks;
}();

var Os = /*#__PURE__*/function (_ks) {
  _inherits(Os, _ks);

  var _super60 = _createSuper(Os);

  function Os() {
    var _this47;

    _classCallCheck(this, Os);

    _this47 = _super60.call(this, new nn(50, 1, .5, 500)), _this47.focus = 1;
    return _this47;
  }

  _createClass(Os, [{
    key: "updateMatrices",
    value: function updateMatrices(t) {
      var e = this.camera,
          n = 2 * b * t.angle * this.focus,
          i = this.mapSize.width / this.mapSize.height,
          r = t.distance || e.far;
      n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), _get(_getPrototypeOf(Os.prototype), "updateMatrices", this).call(this, t);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Os.prototype), "copy", this).call(this, t), this.focus = t.focus, this;
    }
  }]);

  return Os;
}(ks);

Os.prototype.isSpotLightShadow = !0;

var Hs = /*#__PURE__*/function (_Fs) {
  _inherits(Hs, _Fs);

  var _super61 = _createSuper(Hs);

  function Hs(t, e) {
    var _this48;

    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI / 3;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

    _classCallCheck(this, Hs);

    _this48 = _super61.call(this, t, e), _this48.type = "SpotLight", _this48.position.copy(Vt.DefaultUp), _this48.updateMatrix(), _this48.target = new Vt(), _this48.distance = n, _this48.angle = i, _this48.penumbra = r, _this48.decay = s, _this48.shadow = new Os();
    return _this48;
  }

  _createClass(Hs, [{
    key: "power",
    get: function get() {
      return this.intensity * Math.PI;
    },
    set: function set(t) {
      this.intensity = t / Math.PI;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Hs.prototype), "copy", this).call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }]);

  return Hs;
}(Fs);

Hs.prototype.isSpotLight = !0;
var zs = new yt(),
    Vs = new H(),
    Ws = new H();

var qs = /*#__PURE__*/function (_ks2) {
  _inherits(qs, _ks2);

  var _super62 = _createSuper(qs);

  function qs() {
    var _this49;

    _classCallCheck(this, qs);

    _this49 = _super62.call(this, new nn(90, 1, .5, 500)), _this49._frameExtents = new R(4, 2), _this49._viewportCount = 6, _this49._viewports = [new G(2, 1, 1, 1), new G(0, 1, 1, 1), new G(3, 1, 1, 1), new G(1, 1, 1, 1), new G(3, 0, 1, 1), new G(1, 0, 1, 1)], _this49._cubeDirections = [new H(1, 0, 0), new H(-1, 0, 0), new H(0, 0, 1), new H(0, 0, -1), new H(0, 1, 0), new H(0, -1, 0)], _this49._cubeUps = [new H(0, 1, 0), new H(0, 1, 0), new H(0, 1, 0), new H(0, 1, 0), new H(0, 0, 1), new H(0, 0, -1)];
    return _this49;
  }

  _createClass(qs, [{
    key: "updateMatrices",
    value: function updateMatrices(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.camera,
          i = this.matrix,
          r = t.distance || n.far;
      r !== n.far && (n.far = r, n.updateProjectionMatrix()), Vs.setFromMatrixPosition(t.matrixWorld), n.position.copy(Vs), Ws.copy(n.position), Ws.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Ws), n.updateMatrixWorld(), i.makeTranslation(-Vs.x, -Vs.y, -Vs.z), zs.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(zs);
    }
  }]);

  return qs;
}(ks);

qs.prototype.isPointLightShadow = !0;

var js = /*#__PURE__*/function (_Fs2) {
  _inherits(js, _Fs2);

  var _super63 = _createSuper(js);

  function js(t, e) {
    var _this50;

    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, js);

    _this50 = _super63.call(this, t, e), _this50.type = "PointLight", _this50.distance = n, _this50.decay = i, _this50.shadow = new qs();
    return _this50;
  }

  _createClass(js, [{
    key: "power",
    get: function get() {
      return 4 * this.intensity * Math.PI;
    },
    set: function set(t) {
      this.intensity = t / (4 * Math.PI);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(js.prototype), "copy", this).call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  }]);

  return js;
}(Fs);

js.prototype.isPointLight = !0;

var Ys = /*#__PURE__*/function (_en2) {
  _inherits(Ys, _en2);

  var _super64 = _createSuper(Ys);

  function Ys() {
    var _this51;

    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .1;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2e3;

    _classCallCheck(this, Ys);

    _this51 = _super64.call(this), _this51.type = "OrthographicCamera", _this51.zoom = 1, _this51.view = null, _this51.left = t, _this51.right = e, _this51.top = n, _this51.bottom = i, _this51.near = r, _this51.far = s, _this51.updateProjectionMatrix();
    return _this51;
  }

  _createClass(Ys, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Ys.prototype), "copy", this).call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this;
    }
  }, {
    key: "setViewOffset",
    value: function setViewOffset(t, e, n, i, r, s) {
      null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2;
      var r = n - t,
          s = n + t,
          a = i + e,
          o = i - e;

      if (null !== this.view && this.view.enabled) {
        var _t198 = (this.right - this.left) / this.view.fullWidth / this.zoom,
            _e157 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;

        r += _t198 * this.view.offsetX, s = r + _t198 * this.view.width, a -= _e157 * this.view.offsetY, o = a - _e157 * this.view.height;
      }

      this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(Ys.prototype), "toJSON", this).call(this, t);

      return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e;
    }
  }]);

  return Ys;
}(en);

Ys.prototype.isOrthographicCamera = !0;

var Js = /*#__PURE__*/function (_ks3) {
  _inherits(Js, _ks3);

  var _super65 = _createSuper(Js);

  function Js() {
    _classCallCheck(this, Js);

    return _super65.call(this, new Ys(-5, 5, 5, -5, .5, 500));
  }

  return Js;
}(ks);

Js.prototype.isDirectionalLightShadow = !0;

var Xs = /*#__PURE__*/function (_Fs3) {
  _inherits(Xs, _Fs3);

  var _super66 = _createSuper(Xs);

  function Xs(t, e) {
    var _this52;

    _classCallCheck(this, Xs);

    _this52 = _super66.call(this, t, e), _this52.type = "DirectionalLight", _this52.position.copy(Vt.DefaultUp), _this52.updateMatrix(), _this52.target = new Vt(), _this52.shadow = new Js();
    return _this52;
  }

  _createClass(Xs, [{
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Xs.prototype), "copy", this).call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }]);

  return Xs;
}(Fs);

Xs.prototype.isDirectionalLight = !0;

var Ks = /*#__PURE__*/function () {
  function Ks() {
    _classCallCheck(this, Ks);
  }

  _createClass(Ks, null, [{
    key: "decodeText",
    value: function decodeText(t) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
      var e = "";

      for (var _n143 = 0, _i131 = t.length; _n143 < _i131; _n143++) {
        e += String.fromCharCode(t[_n143]);
      }

      try {
        return decodeURIComponent(escape(e));
      } catch (t) {
        return e;
      }
    }
  }, {
    key: "extractUrlBase",
    value: function extractUrlBase(t) {
      var e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.substr(0, e + 1);
    }
  }]);

  return Ks;
}();

var Zs = /*#__PURE__*/function (_Ss7) {
  _inherits(Zs, _Ss7);

  var _super67 = _createSuper(Zs);

  function Zs(t) {
    var _this53;

    _classCallCheck(this, Zs);

    _this53 = _super67.call(this, t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), _this53.options = {
      premultiplyAlpha: "none"
    };
    return _this53;
  }

  _createClass(Zs, [{
    key: "setOptions",
    value: function setOptions(t) {
      return this.options = t, this;
    }
  }, {
    key: "load",
    value: function load(t, e, n, i) {
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      var r = this,
          s = Cs.get(t);
      if (void 0 !== s) return r.manager.itemStart(t), setTimeout(function () {
        e && e(s), r.manager.itemEnd(t);
      }, 0), s;
      var a = {};
      a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then(function (t) {
        return t.blob();
      }).then(function (t) {
        return createImageBitmap(t, Object.assign(r.options, {
          colorSpaceConversion: "none"
        }));
      }).then(function (n) {
        Cs.add(t, n), e && e(n), r.manager.itemEnd(t);
      }).catch(function (e) {
        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }), r.manager.itemStart(t);
    }
  }]);

  return Zs;
}(Ss);

Zs.prototype.isImageBitmapLoader = !0;

var $s = /*#__PURE__*/function () {
  function $s(t, e, n) {
    _classCallCheck(this, $s);

    var i, r, s;

    switch (this.binding = t, this.valueSize = n, e) {
      case "quaternion":
        i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
        break;

      case "string":
      case "bool":
        i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
        break;

      default:
        i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
    }

    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }

  _createClass($s, [{
    key: "accumulate",
    value: function accumulate(t, e) {
      var n = this.buffer,
          i = this.valueSize,
          r = t * i + i;
      var s = this.cumulativeWeight;

      if (0 === s) {
        for (var _t199 = 0; _t199 !== i; ++_t199) {
          n[r + _t199] = n[_t199];
        }

        s = e;
      } else {
        s += e;

        var _t200 = e / s;

        this._mixBufferRegion(n, r, 0, _t200, i);
      }

      this.cumulativeWeight = s;
    }
  }, {
    key: "accumulateAdditive",
    value: function accumulateAdditive(t) {
      var e = this.buffer,
          n = this.valueSize,
          i = n * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t;
    }
  }, {
    key: "apply",
    value: function apply(t) {
      var e = this.valueSize,
          n = this.buffer,
          i = t * e + e,
          r = this.cumulativeWeight,
          s = this.cumulativeWeightAdditive,
          a = this.binding;

      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
        var _t201 = e * this._origIndex;

        this._mixBufferRegion(n, i, _t201, 1 - r, e);
      }

      s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);

      for (var _t202 = e, _r95 = e + e; _t202 !== _r95; ++_t202) {
        if (n[_t202] !== n[_t202 + e]) {
          a.setValue(n, i);
          break;
        }
      }
    }
  }, {
    key: "saveOriginalState",
    value: function saveOriginalState() {
      var t = this.binding,
          e = this.buffer,
          n = this.valueSize,
          i = n * this._origIndex;
      t.getValue(e, i);

      for (var _t203 = n, _r96 = i; _t203 !== _r96; ++_t203) {
        e[_t203] = e[i + _t203 % n];
      }

      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
  }, {
    key: "restoreOriginalState",
    value: function restoreOriginalState() {
      var t = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t);
    }
  }, {
    key: "_setAdditiveIdentityNumeric",
    value: function _setAdditiveIdentityNumeric() {
      var t = this._addIndex * this.valueSize,
          e = t + this.valueSize;

      for (var _n144 = t; _n144 < e; _n144++) {
        this.buffer[_n144] = 0;
      }
    }
  }, {
    key: "_setAdditiveIdentityQuaternion",
    value: function _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
  }, {
    key: "_setAdditiveIdentityOther",
    value: function _setAdditiveIdentityOther() {
      var t = this._origIndex * this.valueSize,
          e = this._addIndex * this.valueSize;

      for (var _n145 = 0; _n145 < this.valueSize; _n145++) {
        this.buffer[e + _n145] = this.buffer[t + _n145];
      }
    }
  }, {
    key: "_select",
    value: function _select(t, e, n, i, r) {
      if (i >= .5) for (var _i132 = 0; _i132 !== r; ++_i132) {
        t[e + _i132] = t[n + _i132];
      }
    }
  }, {
    key: "_slerp",
    value: function _slerp(t, e, n, i) {
      O.slerpFlat(t, e, t, e, t, n, i);
    }
  }, {
    key: "_slerpAdditive",
    value: function _slerpAdditive(t, e, n, i, r) {
      var s = this._workIndex * r;
      O.multiplyQuaternionsFlat(t, s, t, e, t, n), O.slerpFlat(t, e, t, e, t, s, i);
    }
  }, {
    key: "_lerp",
    value: function _lerp(t, e, n, i, r) {
      var s = 1 - i;

      for (var _a43 = 0; _a43 !== r; ++_a43) {
        var _r97 = e + _a43;

        t[_r97] = t[_r97] * s + t[n + _a43] * i;
      }
    }
  }, {
    key: "_lerpAdditive",
    value: function _lerpAdditive(t, e, n, i, r) {
      for (var _s52 = 0; _s52 !== r; ++_s52) {
        var _r98 = e + _s52;

        t[_r98] = t[_r98] + t[n + _s52] * i;
      }
    }
  }]);

  return $s;
}();

var ta = new RegExp("[\\[\\]\\.:\\/]", "g"),
    ea = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
    na = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    ia = /(WCOD+)?/.source.replace("WCOD", ea),
    ra = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    sa = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    aa = new RegExp("^" + na + ia + ra + sa + "$"),
    oa = ["material", "materials", "bones"];

var la = /*#__PURE__*/function () {
  function la(t, e, n) {
    _classCallCheck(this, la);

    this.path = e, this.parsedPath = n || la.parseTrackName(e), this.node = la.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }

  _createClass(la, [{
    key: "_getValue_unavailable",
    value: function _getValue_unavailable() {}
  }, {
    key: "_setValue_unavailable",
    value: function _setValue_unavailable() {}
  }, {
    key: "_getValue_direct",
    value: function _getValue_direct(t, e) {
      t[e] = this.node[this.propertyName];
    }
  }, {
    key: "_getValue_array",
    value: function _getValue_array(t, e) {
      var n = this.resolvedProperty;

      for (var _i133 = 0, _r99 = n.length; _i133 !== _r99; ++_i133) {
        t[e++] = n[_i133];
      }
    }
  }, {
    key: "_getValue_arrayElement",
    value: function _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
  }, {
    key: "_getValue_toArray",
    value: function _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
  }, {
    key: "_setValue_direct",
    value: function _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
  }, {
    key: "_setValue_direct_setNeedsUpdate",
    value: function _setValue_direct_setNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_direct_setMatrixWorldNeedsUpdate",
    value: function _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_setValue_array",
    value: function _setValue_array(t, e) {
      var n = this.resolvedProperty;

      for (var _i134 = 0, _r100 = n.length; _i134 !== _r100; ++_i134) {
        n[_i134] = t[e++];
      }
    }
  }, {
    key: "_setValue_array_setNeedsUpdate",
    value: function _setValue_array_setNeedsUpdate(t, e) {
      var n = this.resolvedProperty;

      for (var _i135 = 0, _r101 = n.length; _i135 !== _r101; ++_i135) {
        n[_i135] = t[e++];
      }

      this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_array_setMatrixWorldNeedsUpdate",
    value: function _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      var n = this.resolvedProperty;

      for (var _i136 = 0, _r102 = n.length; _i136 !== _r102; ++_i136) {
        n[_i136] = t[e++];
      }

      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_setValue_arrayElement",
    value: function _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
  }, {
    key: "_setValue_arrayElement_setNeedsUpdate",
    value: function _setValue_arrayElement_setNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
    value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_setValue_fromArray",
    value: function _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
  }, {
    key: "_setValue_fromArray_setNeedsUpdate",
    value: function _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
    value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_getValue_unbound",
    value: function _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
  }, {
    key: "_setValue_unbound",
    value: function _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
  }, {
    key: "bind",
    value: function bind() {
      var t = this.node;
      var e = this.parsedPath,
          n = e.objectName,
          i = e.propertyName;
      var r = e.propertyIndex;
      if (t || (t = la.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");

      if (n) {
        var _i137 = e.objectIndex;

        switch (n) {
          case "materials":
            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            t = t.material.materials;
            break;

          case "bones":
            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            t = t.skeleton.bones;

            for (var _e158 = 0; _e158 < t.length; _e158++) {
              if (t[_e158].name === _i137) {
                _i137 = _e158;
                break;
              }
            }

            break;

          default:
            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            t = t[n];
        }

        if (void 0 !== _i137) {
          if (void 0 === t[_i137]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          t = t[_i137];
        }
      }

      var s = t[i];

      if (void 0 === s) {
        var _n146 = e.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + _n146 + "." + i + " but it wasn't found.", t);
      }

      var a = this.Versioning.None;
      this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
      var o = this.BindingType.Direct;

      if (void 0 !== r) {
        if ("morphTargetInfluences" === i) {
          if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
        }

        o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r;
      } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;

      this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a];
    }
  }, {
    key: "unbind",
    value: function unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }], [{
    key: "create",
    value: function create(t, e, n) {
      return t && t.isAnimationObjectGroup ? new la.Composite(t, e, n) : new la(t, e, n);
    }
  }, {
    key: "sanitizeNodeName",
    value: function sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(ta, "");
    }
  }, {
    key: "parseTrackName",
    value: function parseTrackName(t) {
      var e = aa.exec(t);
      if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      var n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6]
      },
          i = n.nodeName && n.nodeName.lastIndexOf(".");

      if (void 0 !== i && -1 !== i) {
        var _t204 = n.nodeName.substring(i + 1);

        -1 !== oa.indexOf(_t204) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = _t204);
      }

      if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
      return n;
    }
  }, {
    key: "findNode",
    value: function findNode(t, e) {
      if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;

      if (t.skeleton) {
        var _n147 = t.skeleton.getBoneByName(e);

        if (void 0 !== _n147) return _n147;
      }

      if (t.children) {
        var _n148 = function _n148(t) {
          for (var _i139 = 0; _i139 < t.length; _i139++) {
            var _r103 = t[_i139];
            if (_r103.name === e || _r103.uuid === e) return _r103;

            var _s53 = _n148(_r103.children);

            if (_s53) return _s53;
          }

          return null;
        },
            _i138 = _n148(t.children);

        if (_i138) return _i138;
      }

      return null;
    }
  }]);

  return la;
}();

la.Composite = /*#__PURE__*/function () {
  function _class2(t, e, n) {
    _classCallCheck(this, _class2);

    var i = n || la.parseTrackName(e);
    this._targetGroup = t, this._bindings = t.subscribe_(e, i);
  }

  _createClass(_class2, [{
    key: "getValue",
    value: function getValue(t, e) {
      this.bind();
      var n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
      void 0 !== i && i.getValue(t, e);
    }
  }, {
    key: "setValue",
    value: function setValue(t, e) {
      var n = this._bindings;

      for (var _i140 = this._targetGroup.nCachedObjects_, _r104 = n.length; _i140 !== _r104; ++_i140) {
        n[_i140].setValue(t, e);
      }
    }
  }, {
    key: "bind",
    value: function bind() {
      var t = this._bindings;

      for (var _e159 = this._targetGroup.nCachedObjects_, _n149 = t.length; _e159 !== _n149; ++_e159) {
        t[_e159].bind();
      }
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var t = this._bindings;

      for (var _e160 = this._targetGroup.nCachedObjects_, _n150 = t.length; _e160 !== _n150; ++_e160) {
        t[_e160].unbind();
      }
    }
  }]);

  return _class2;
}(), la.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
}, la.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
}, la.prototype.GetterByBindingType = [la.prototype._getValue_direct, la.prototype._getValue_array, la.prototype._getValue_arrayElement, la.prototype._getValue_toArray], la.prototype.SetterByBindingTypeAndVersioning = [[la.prototype._setValue_direct, la.prototype._setValue_direct_setNeedsUpdate, la.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [la.prototype._setValue_array, la.prototype._setValue_array_setNeedsUpdate, la.prototype._setValue_array_setMatrixWorldNeedsUpdate], [la.prototype._setValue_arrayElement, la.prototype._setValue_arrayElement_setNeedsUpdate, la.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [la.prototype._setValue_fromArray, la.prototype._setValue_fromArray_setNeedsUpdate, la.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

var ca = /*#__PURE__*/function () {
  function ca(t, e) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.blendMode;

    _classCallCheck(this, ca);

    this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
    var r = e.tracks,
        s = r.length,
        a = new Array(s),
        o = {
      endingStart: 2400,
      endingEnd: 2400
    };

    for (var _t205 = 0; _t205 !== s; ++_t205) {
      var _e161 = r[_t205].createInterpolant(null);

      a[_t205] = _e161, _e161.settings = o;
    }

    this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }

  _createClass(ca, [{
    key: "play",
    value: function play() {
      return this._mixer._activateAction(this), this;
    }
  }, {
    key: "stop",
    value: function stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
  }, {
    key: "reset",
    value: function reset() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
  }, {
    key: "isRunning",
    value: function isRunning() {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    }
  }, {
    key: "isScheduled",
    value: function isScheduled() {
      return this._mixer._isActiveAction(this);
    }
  }, {
    key: "startAt",
    value: function startAt(t) {
      return this._startTime = t, this;
    }
  }, {
    key: "setLoop",
    value: function setLoop(t, e) {
      return this.loop = t, this.repetitions = e, this;
    }
  }, {
    key: "setEffectiveWeight",
    value: function setEffectiveWeight(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    }
  }, {
    key: "getEffectiveWeight",
    value: function getEffectiveWeight() {
      return this._effectiveWeight;
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(t) {
      return this._scheduleFading(t, 0, 1);
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(t) {
      return this._scheduleFading(t, 1, 0);
    }
  }, {
    key: "crossFadeFrom",
    value: function crossFadeFrom(t, e, n) {
      if (t.fadeOut(e), this.fadeIn(e), n) {
        var _n151 = this._clip.duration,
            _i141 = t._clip.duration,
            _r105 = _i141 / _n151,
            _s54 = _n151 / _i141;

        t.warp(1, _r105, e), this.warp(_s54, 1, e);
      }

      return this;
    }
  }, {
    key: "crossFadeTo",
    value: function crossFadeTo(t, e, n) {
      return t.crossFadeFrom(this, e, n);
    }
  }, {
    key: "stopFading",
    value: function stopFading() {
      var t = this._weightInterpolant;
      return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
  }, {
    key: "setEffectiveTimeScale",
    value: function setEffectiveTimeScale(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    }
  }, {
    key: "getEffectiveTimeScale",
    value: function getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
  }, {
    key: "setDuration",
    value: function setDuration(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    }
  }, {
    key: "syncWith",
    value: function syncWith(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    }
  }, {
    key: "halt",
    value: function halt(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    }
  }, {
    key: "warp",
    value: function warp(t, e, n) {
      var i = this._mixer,
          r = i.time,
          s = this.timeScale;
      var a = this._timeScaleInterpolant;
      null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
      var o = a.parameterPositions,
          l = a.sampleValues;
      return o[0] = r, o[1] = r + n, l[0] = t / s, l[1] = e / s, this;
    }
  }, {
    key: "stopWarping",
    value: function stopWarping() {
      var t = this._timeScaleInterpolant;
      return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
  }, {
    key: "getMixer",
    value: function getMixer() {
      return this._mixer;
    }
  }, {
    key: "getClip",
    value: function getClip() {
      return this._clip;
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._localRoot || this._mixer._root;
    }
  }, {
    key: "_update",
    value: function _update(t, e, n, i) {
      if (!this.enabled) return void this._updateWeight(t);
      var r = this._startTime;

      if (null !== r) {
        var _i142 = (t - r) * n;

        if (_i142 < 0 || 0 === n) return;
        this._startTime = null, e = n * _i142;
      }

      e *= this._updateTimeScale(t);

      var s = this._updateTime(e),
          a = this._updateWeight(t);

      if (a > 0) {
        var _t206 = this._interpolants,
            _e162 = this._propertyBindings;

        switch (this.blendMode) {
          case 2501:
            for (var _n152 = 0, _i143 = _t206.length; _n152 !== _i143; ++_n152) {
              _t206[_n152].evaluate(s), _e162[_n152].accumulateAdditive(a);
            }

            break;

          case 2500:
          default:
            for (var _n153 = 0, _r106 = _t206.length; _n153 !== _r106; ++_n153) {
              _t206[_n153].evaluate(s), _e162[_n153].accumulate(i, a);
            }

        }
      }
    }
  }, {
    key: "_updateWeight",
    value: function _updateWeight(t) {
      var e = 0;

      if (this.enabled) {
        e = this.weight;
        var _n154 = this._weightInterpolant;

        if (null !== _n154) {
          var _i144 = _n154.evaluate(t)[0];

          e *= _i144, t > _n154.parameterPositions[1] && (this.stopFading(), 0 === _i144 && (this.enabled = !1));
        }
      }

      return this._effectiveWeight = e, e;
    }
  }, {
    key: "_updateTimeScale",
    value: function _updateTimeScale(t) {
      var e = 0;

      if (!this.paused) {
        e = this.timeScale;
        var _n155 = this._timeScaleInterpolant;

        if (null !== _n155) {
          e *= _n155.evaluate(t)[0], t > _n155.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e);
        }
      }

      return this._effectiveTimeScale = e, e;
    }
  }, {
    key: "_updateTime",
    value: function _updateTime(t) {
      var e = this._clip.duration,
          n = this.loop;
      var i = this.time + t,
          r = this._loopCount;
      var s = 2202 === n;
      if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;

      if (2200 === n) {
        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));

        t: {
          if (i >= e) i = e;else {
            if (!(i < 0)) {
              this.time = i;
              break t;
            }

            i = 0;
          }
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1
          });
        }
      } else {
        if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
          var _n156 = Math.floor(i / e);

          i -= e * _n156, r += Math.abs(_n156);

          var _a44 = this.repetitions - r;

          if (_a44 <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t > 0 ? 1 : -1
          });else {
            if (1 === _a44) {
              var _e163 = t < 0;

              this._setEndings(_e163, !_e163, s);
            } else this._setEndings(!1, !1, s);

            this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: _n156
            });
          }
        } else this.time = i;

        if (s && 1 == (1 & r)) return e - i;
      }

      return i;
    }
  }, {
    key: "_setEndings",
    value: function _setEndings(t, e, n) {
      var i = this._interpolantSettings;
      n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    }
  }, {
    key: "_scheduleFading",
    value: function _scheduleFading(t, e, n) {
      var i = this._mixer,
          r = i.time;
      var s = this._weightInterpolant;
      null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
      var a = s.parameterPositions,
          o = s.sampleValues;
      return a[0] = r, o[0] = e, a[1] = r + t, o[1] = n, this;
    }
  }]);

  return ca;
}();

var ha = /*#__PURE__*/function (_y8) {
  _inherits(ha, _y8);

  var _super68 = _createSuper(ha);

  function ha(t) {
    var _this54;

    _classCallCheck(this, ha);

    _this54 = _super68.call(this), _this54._root = t, _this54._initMemoryManager(), _this54._accuIndex = 0, _this54.time = 0, _this54.timeScale = 1;
    return _this54;
  }

  _createClass(ha, [{
    key: "_bindAction",
    value: function _bindAction(t, e) {
      var n = t._localRoot || this._root,
          i = t._clip.tracks,
          r = i.length,
          s = t._propertyBindings,
          a = t._interpolants,
          o = n.uuid,
          l = this._bindingsByRootAndName;
      var c = l[o];
      void 0 === c && (c = {}, l[o] = c);

      for (var _t207 = 0; _t207 !== r; ++_t207) {
        var _r107 = i[_t207],
            _l22 = _r107.name;
        var _h8 = c[_l22];
        if (void 0 !== _h8) s[_t207] = _h8;else {
          if (_h8 = s[_t207], void 0 !== _h8) {
            null === _h8._cacheIndex && (++_h8.referenceCount, this._addInactiveBinding(_h8, o, _l22));
            continue;
          }

          var _i145 = e && e._propertyBindings[_t207].binding.parsedPath;

          _h8 = new $s(la.create(n, _l22, _i145), _r107.ValueTypeName, _r107.getValueSize()), ++_h8.referenceCount, this._addInactiveBinding(_h8, o, _l22), s[_t207] = _h8;
        }
        a[_t207].resultBuffer = _h8.buffer;
      }
    }
  }, {
    key: "_activateAction",
    value: function _activateAction(t) {
      if (!this._isActiveAction(t)) {
        if (null === t._cacheIndex) {
          var _e165 = (t._localRoot || this._root).uuid,
              _n157 = t._clip.uuid,
              _i146 = this._actionsByClip[_n157];
          this._bindAction(t, _i146 && _i146.knownActions[0]), this._addInactiveAction(t, _n157, _e165);
        }

        var _e164 = t._propertyBindings;

        for (var _t208 = 0, _n158 = _e164.length; _t208 !== _n158; ++_t208) {
          var _n159 = _e164[_t208];
          0 == _n159.useCount++ && (this._lendBinding(_n159), _n159.saveOriginalState());
        }

        this._lendAction(t);
      }
    }
  }, {
    key: "_deactivateAction",
    value: function _deactivateAction(t) {
      if (this._isActiveAction(t)) {
        var _e166 = t._propertyBindings;

        for (var _t209 = 0, _n160 = _e166.length; _t209 !== _n160; ++_t209) {
          var _n161 = _e166[_t209];
          0 == --_n161.useCount && (_n161.restoreOriginalState(), this._takeBackBinding(_n161));
        }

        this._takeBackAction(t);
      }
    }
  }, {
    key: "_initMemoryManager",
    value: function _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      var t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length;
          },

          get inUse() {
            return t._nActiveActions;
          }

        },
        bindings: {
          get total() {
            return t._bindings.length;
          },

          get inUse() {
            return t._nActiveBindings;
          }

        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length;
          },

          get inUse() {
            return t._nActiveControlInterpolants;
          }

        }
      };
    }
  }, {
    key: "_isActiveAction",
    value: function _isActiveAction(t) {
      var e = t._cacheIndex;
      return null !== e && e < this._nActiveActions;
    }
  }, {
    key: "_addInactiveAction",
    value: function _addInactiveAction(t, e, n) {
      var i = this._actions,
          r = this._actionsByClip;
      var s = r[e];
      if (void 0 === s) s = {
        knownActions: [t],
        actionByRoot: {}
      }, t._byClipCacheIndex = 0, r[e] = s;else {
        var _e167 = s.knownActions;
        t._byClipCacheIndex = _e167.length, _e167.push(t);
      }
      t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t;
    }
  }, {
    key: "_removeInactiveAction",
    value: function _removeInactiveAction(t) {
      var e = this._actions,
          n = e[e.length - 1],
          i = t._cacheIndex;
      n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
      var r = t._clip.uuid,
          s = this._actionsByClip,
          a = s[r],
          o = a.knownActions,
          l = o[o.length - 1],
          c = t._byClipCacheIndex;
      l._byClipCacheIndex = c, o[c] = l, o.pop(), t._byClipCacheIndex = null;
      delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(t);
    }
  }, {
    key: "_removeInactiveBindingsForAction",
    value: function _removeInactiveBindingsForAction(t) {
      var e = t._propertyBindings;

      for (var _t210 = 0, _n162 = e.length; _t210 !== _n162; ++_t210) {
        var _n163 = e[_t210];
        0 == --_n163.referenceCount && this._removeInactiveBinding(_n163);
      }
    }
  }, {
    key: "_lendAction",
    value: function _lendAction(t) {
      var e = this._actions,
          n = t._cacheIndex,
          i = this._nActiveActions++,
          r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_takeBackAction",
    value: function _takeBackAction(t) {
      var e = this._actions,
          n = t._cacheIndex,
          i = --this._nActiveActions,
          r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_addInactiveBinding",
    value: function _addInactiveBinding(t, e, n) {
      var i = this._bindingsByRootAndName,
          r = this._bindings;
      var s = i[e];
      void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t);
    }
  }, {
    key: "_removeInactiveBinding",
    value: function _removeInactiveBinding(t) {
      var e = this._bindings,
          n = t.binding,
          i = n.rootNode.uuid,
          r = n.path,
          s = this._bindingsByRootAndName,
          a = s[i],
          o = e[e.length - 1],
          l = t._cacheIndex;
      o._cacheIndex = l, e[l] = o, e.pop(), delete a[r], 0 === Object.keys(a).length && delete s[i];
    }
  }, {
    key: "_lendBinding",
    value: function _lendBinding(t) {
      var e = this._bindings,
          n = t._cacheIndex,
          i = this._nActiveBindings++,
          r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_takeBackBinding",
    value: function _takeBackBinding(t) {
      var e = this._bindings,
          n = t._cacheIndex,
          i = --this._nActiveBindings,
          r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_lendControlInterpolant",
    value: function _lendControlInterpolant() {
      var t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++;
      var n = t[e];
      return void 0 === n && (n = new ps(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n;
    }
  }, {
    key: "_takeBackControlInterpolant",
    value: function _takeBackControlInterpolant(t) {
      var e = this._controlInterpolants,
          n = t.__cacheIndex,
          i = --this._nActiveControlInterpolants,
          r = e[i];
      t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r;
    }
  }, {
    key: "clipAction",
    value: function clipAction(t, e, n) {
      var i = e || this._root,
          r = i.uuid;
      var s = "string" == typeof t ? _s.findByName(i, t) : t;
      var a = null !== s ? s.uuid : t,
          o = this._actionsByClip[a];
      var l = null;

      if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o) {
        var _t211 = o.actionByRoot[r];
        if (void 0 !== _t211 && _t211.blendMode === n) return _t211;
        l = o.knownActions[0], null === s && (s = l._clip);
      }

      if (null === s) return null;
      var c = new ca(this, s, e, n);
      return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
    }
  }, {
    key: "existingAction",
    value: function existingAction(t, e) {
      var n = e || this._root,
          i = n.uuid,
          r = "string" == typeof t ? _s.findByName(n, t) : t,
          s = r ? r.uuid : t,
          a = this._actionsByClip[s];
      return void 0 !== a && a.actionByRoot[i] || null;
    }
  }, {
    key: "stopAllAction",
    value: function stopAllAction() {
      var t = this._actions;

      for (var _e168 = this._nActiveActions - 1; _e168 >= 0; --_e168) {
        t[_e168].stop();
      }

      return this;
    }
  }, {
    key: "update",
    value: function update(t) {
      t *= this.timeScale;
      var e = this._actions,
          n = this._nActiveActions,
          i = this.time += t,
          r = Math.sign(t),
          s = this._accuIndex ^= 1;

      for (var _a45 = 0; _a45 !== n; ++_a45) {
        e[_a45]._update(i, t, r, s);
      }

      var a = this._bindings,
          o = this._nActiveBindings;

      for (var _t212 = 0; _t212 !== o; ++_t212) {
        a[_t212].apply(s);
      }

      return this;
    }
  }, {
    key: "setTime",
    value: function setTime(t) {
      this.time = 0;

      for (var _t213 = 0; _t213 < this._actions.length; _t213++) {
        this._actions[_t213].time = 0;
      }

      return this.update(t);
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._root;
    }
  }, {
    key: "uncacheClip",
    value: function uncacheClip(t) {
      var e = this._actions,
          n = t.uuid,
          i = this._actionsByClip,
          r = i[n];

      if (void 0 !== r) {
        var _t214 = r.knownActions;

        for (var _n164 = 0, _i147 = _t214.length; _n164 !== _i147; ++_n164) {
          var _i148 = _t214[_n164];

          this._deactivateAction(_i148);

          var _r108 = _i148._cacheIndex,
              _s55 = e[e.length - 1];
          _i148._cacheIndex = null, _i148._byClipCacheIndex = null, _s55._cacheIndex = _r108, e[_r108] = _s55, e.pop(), this._removeInactiveBindingsForAction(_i148);
        }

        delete i[n];
      }
    }
  }, {
    key: "uncacheRoot",
    value: function uncacheRoot(t) {
      var e = t.uuid,
          n = this._actionsByClip;

      for (var _t215 in n) {
        var _i149 = n[_t215].actionByRoot[e];
        void 0 !== _i149 && (this._deactivateAction(_i149), this._removeInactiveAction(_i149));
      }

      var i = this._bindingsByRootAndName[e];
      if (void 0 !== i) for (var _t216 in i) {
        var _e169 = i[_t216];
        _e169.restoreOriginalState(), this._removeInactiveBinding(_e169);
      }
    }
  }, {
    key: "uncacheAction",
    value: function uncacheAction(t, e) {
      var n = this.existingAction(t, e);
      null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
    }
  }]);

  return ha;
}(y);

ha.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

function ua(t, e) {
  return t.distance - e.distance;
}

function da(t, e, n, i) {
  if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
    var _i150 = t.children;

    for (var _t217 = 0, _r109 = _i150.length; _t217 < _r109; _t217++) {
      da(_i150[_t217], e, n, !0);
    }
  }
}

var Aa = /*#__PURE__*/function () {
  function Aa() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Aa);

    return this.radius = t, this.phi = e, this.theta = n, this;
  }

  _createClass(Aa, [{
    key: "set",
    value: function set(t, e, n) {
      return this.radius = t, this.phi = e, this.theta = n, this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      var t = 1e-6;
      return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(t, e, n) {
      return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(I(e / this.radius, -1, 1))), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Aa;
}();

var pa = new H(),
    ga = new yt(),
    ma = new yt();

var fa = /*#__PURE__*/function (_Xr) {
  _inherits(fa, _Xr);

  var _super69 = _createSuper(fa);

  function fa(t) {
    var _this55;

    _classCallCheck(this, fa);

    var e = va(t),
        n = new Te(),
        i = [],
        r = [],
        s = new pe(0, 0, 1),
        a = new pe(0, 1, 0);

    for (var _t218 = 0; _t218 < e.length; _t218++) {
      var _n165 = e[_t218];
      _n165.parent && _n165.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
    }

    n.setAttribute("position", new xe(i, 3)), n.setAttribute("color", new xe(r, 3));
    _this55 = _super69.call(this, n, new Or({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0
    })), _this55.type = "SkeletonHelper", _this55.isSkeletonHelper = !0, _this55.root = t, _this55.bones = e, _this55.matrix = t.matrixWorld, _this55.matrixAutoUpdate = !1;
    return _this55;
  }

  _createClass(fa, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      var e = this.bones,
          n = this.geometry,
          i = n.getAttribute("position");
      ma.copy(this.root.matrixWorld).invert();

      for (var _t219 = 0, _n166 = 0; _t219 < e.length; _t219++) {
        var _r110 = e[_t219];
        _r110.parent && _r110.parent.isBone && (ga.multiplyMatrices(ma, _r110.matrixWorld), pa.setFromMatrixPosition(ga), i.setXYZ(_n166, pa.x, pa.y, pa.z), ga.multiplyMatrices(ma, _r110.parent.matrixWorld), pa.setFromMatrixPosition(ga), i.setXYZ(_n166 + 1, pa.x, pa.y, pa.z), _n166 += 2);
      }

      n.getAttribute("position").needsUpdate = !0, _get(_getPrototypeOf(fa.prototype), "updateMatrixWorld", this).call(this, t);
    }
  }]);

  return fa;
}(Xr);

function va(t) {
  var e = [];
  t && t.isBone && e.push(t);

  for (var _n167 = 0; _n167 < t.children.length; _n167++) {
    e.push.apply(e, va(t.children[_n167]));
  }

  return e;
}

var ya = new Float32Array(1),
    Ea = new Int32Array(ya.buffer);

var xa = /*#__PURE__*/function () {
  function xa() {
    _classCallCheck(this, xa);
  }

  _createClass(xa, null, [{
    key: "toHalfFloat",
    value: function toHalfFloat(t) {
      ya[0] = t;
      var e = Ea[0];
      var n = e >> 16 & 32768,
          i = e >> 12 & 2047;
      var r = e >> 23 & 255;
      return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & e, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n);
    }
  }]);

  return xa;
}();

var wa = Math.pow(2, 8),
    ba = [.125, .215, .35, .446, .526, .582],
    _a = 5 + ba.length,
    Ia = {
  3e3: 0,
  3001: 1,
  3002: 2,
  3004: 3,
  3005: 4,
  3006: 5,
  3007: 6
},
    Ca = new ge({
  side: 1,
  depthWrite: !1,
  depthTest: !1
}),
    Ma = new Ye(new Xe(), Ca),
    Sa = new Ys(),
    _ka = ka(),
    Ba = _ka._lodPlanes,
    Ta = _ka._sizeLods,
    La = _ka._sigmas,
    Ra = new pe();

var Da = null;
var Qa = (1 + Math.sqrt(5)) / 2,
    Pa = 1 / Qa,
    Fa = [new H(1, 1, 1), new H(-1, 1, 1), new H(1, 1, -1), new H(-1, 1, -1), new H(0, Qa, Pa), new H(0, Qa, -Pa), new H(Pa, 0, Qa), new H(-Pa, 0, Qa), new H(Qa, Pa, 0), new H(-Qa, Pa, 0)];

function Na(t) {
  var e = Math.max(t.r, t.g, t.b),
      n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
  t.multiplyScalar(Math.pow(2, -n));
  return (n + 128) / 255;
}

var Ua = /*#__PURE__*/function () {
  function Ua(t) {
    _classCallCheck(this, Ua);

    this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function (t) {
      var e = new Float32Array(t),
          n = new H(0, 1, 0);
      return new ls({
        name: "SphericalGaussianBlur",
        defines: {
          n: t
        },
        uniforms: {
          envMap: {
            value: null
          },
          samples: {
            value: 1
          },
          weights: {
            value: e
          },
          latitudinal: {
            value: !1
          },
          dTheta: {
            value: 0
          },
          mipInt: {
            value: 0
          },
          poleAxis: {
            value: n
          },
          inputEncoding: {
            value: Ia[3e3]
          },
          outputEncoding: {
            value: Ia[3e3]
          }
        },
        vertexShader: Wa(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t".concat(qa(), "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
        blending: 0,
        depthTest: !1,
        depthWrite: !1
      });
    }(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
  }

  _createClass(Ua, [{
    key: "fromScene",
    value: function fromScene(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .1;
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
      Da = this._renderer.getRenderTarget();

      var r = this._allocateTargets();

      return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r;
    }
  }, {
    key: "fromEquirectangular",
    value: function fromEquirectangular(t) {
      return this._fromTexture(t);
    }
  }, {
    key: "fromCubemap",
    value: function fromCubemap(t) {
      return this._fromTexture(t);
    }
  }, {
    key: "compileCubemapShader",
    value: function compileCubemapShader() {
      null === this._cubemapShader && (this._cubemapShader = Va(), this._compileMaterial(this._cubemapShader));
    }
  }, {
    key: "compileEquirectangularShader",
    value: function compileEquirectangularShader() {
      null === this._equirectShader && (this._equirectShader = za(), this._compileMaterial(this._equirectShader));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();

      for (var _t220 = 0; _t220 < Ba.length; _t220++) {
        Ba[_t220].dispose();
      }
    }
  }, {
    key: "_cleanup",
    value: function _cleanup(t) {
      this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Da), t.scissorTest = !1, Ha(t, 0, 0, t.width, t.height);
    }
  }, {
    key: "_fromTexture",
    value: function _fromTexture(t) {
      Da = this._renderer.getRenderTarget();

      var e = this._allocateTargets(t);

      return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
    }
  }, {
    key: "_allocateTargets",
    value: function _allocateTargets(t) {
      var e = {
        magFilter: 1003,
        minFilter: 1003,
        generateMipmaps: !1,
        type: 1009,
        format: 1023,
        encoding: Ga(t) ? t.encoding : 3002,
        depthBuffer: !1
      },
          n = Oa(e);
      return n.depthBuffer = !t, this._pingPongRenderTarget = Oa(e), n;
    }
  }, {
    key: "_compileMaterial",
    value: function _compileMaterial(t) {
      var e = new Ye(Ba[0], t);

      this._renderer.compile(e, Sa);
    }
  }, {
    key: "_sceneToCubeUV",
    value: function _sceneToCubeUV(t, e, n, i) {
      var r = new nn(90, 1, e, n),
          s = [1, -1, 1, 1, 1, 1],
          a = [1, 1, 1, -1, -1, -1],
          o = this._renderer,
          l = o.autoClear,
          c = o.outputEncoding,
          h = o.toneMapping;
      o.getClearColor(Ra), o.toneMapping = 0, o.outputEncoding = 3e3, o.autoClear = !1;
      var u = !1;
      var d = t.background;

      if (d) {
        if (d.isColor) {
          Ca.color.copy(d).convertSRGBToLinear(), t.background = null;

          var _e170 = Na(Ca.color);

          Ca.opacity = _e170, u = !0;
        }
      } else {
        Ca.color.copy(Ra).convertSRGBToLinear();

        var _t221 = Na(Ca.color);

        Ca.opacity = _t221, u = !0;
      }

      for (var _e171 = 0; _e171 < 6; _e171++) {
        var _n168 = _e171 % 3;

        0 == _n168 ? (r.up.set(0, s[_e171], 0), r.lookAt(a[_e171], 0, 0)) : 1 == _n168 ? (r.up.set(0, 0, s[_e171]), r.lookAt(0, a[_e171], 0)) : (r.up.set(0, s[_e171], 0), r.lookAt(0, 0, a[_e171])), Ha(i, _n168 * wa, _e171 > 2 ? wa : 0, wa, wa), o.setRenderTarget(i), u && o.render(Ma, r), o.render(t, r);
      }

      o.toneMapping = h, o.outputEncoding = c, o.autoClear = l;
    }
  }, {
    key: "_textureToCubeUV",
    value: function _textureToCubeUV(t, e) {
      var n = this._renderer;
      t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Va()) : null == this._equirectShader && (this._equirectShader = za());
      var i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
          r = new Ye(Ba[0], i),
          s = i.uniforms;
      s.envMap.value = t, t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height), s.inputEncoding.value = Ia[t.encoding], s.outputEncoding.value = Ia[e.texture.encoding], Ha(e, 0, 0, 3 * wa, 2 * wa), n.setRenderTarget(e), n.render(r, Sa);
    }
  }, {
    key: "_applyPMREM",
    value: function _applyPMREM(t) {
      var e = this._renderer,
          n = e.autoClear;
      e.autoClear = !1;

      for (var _e172 = 1; _e172 < _a; _e172++) {
        var _n169 = Math.sqrt(La[_e172] * La[_e172] - La[_e172 - 1] * La[_e172 - 1]),
            _i151 = Fa[(_e172 - 1) % Fa.length];

        this._blur(t, _e172 - 1, _e172, _n169, _i151);
      }

      e.autoClear = n;
    }
  }, {
    key: "_blur",
    value: function _blur(t, e, n, i, r) {
      var s = this._pingPongRenderTarget;
      this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r);
    }
  }, {
    key: "_halfBlur",
    value: function _halfBlur(t, e, n, i, r, s, a) {
      var o = this._renderer,
          l = this._blurMaterial;
      "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
      var c = new Ye(Ba[i], l),
          h = l.uniforms,
          u = Ta[n] - 1,
          d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
          A = r / d,
          p = isFinite(r) ? 1 + Math.floor(3 * A) : 20;
      p > 20 && console.warn("sigmaRadians, ".concat(r, ", is too large and will clip, as it requested ").concat(p, " samples when the maximum is set to 20"));
      var g = [];
      var m = 0;

      for (var _t222 = 0; _t222 < 20; ++_t222) {
        var _e173 = _t222 / A,
            _n170 = Math.exp(-_e173 * _e173 / 2);

        g.push(_n170), 0 == _t222 ? m += _n170 : _t222 < p && (m += 2 * _n170);
      }

      for (var _t223 = 0; _t223 < g.length; _t223++) {
        g[_t223] = g[_t223] / m;
      }

      h.envMap.value = t.texture, h.samples.value = p, h.weights.value = g, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = 8 - n, h.inputEncoding.value = Ia[t.texture.encoding], h.outputEncoding.value = Ia[t.texture.encoding];
      var f = Ta[i];
      Ha(e, 3 * Math.max(0, wa - 2 * f), (0 === i ? 0 : 2 * wa) + 2 * f * (i > 4 ? i - 8 + 4 : 0), 3 * f, 2 * f), o.setRenderTarget(e), o.render(c, Sa);
    }
  }]);

  return Ua;
}();

function Ga(t) {
  return void 0 !== t && 1009 === t.type && (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding);
}

function ka() {
  var t = [],
      e = [],
      n = [];
  var i = 8;

  for (var _r111 = 0; _r111 < _a; _r111++) {
    var _s56 = Math.pow(2, i);

    e.push(_s56);

    var _a46 = 1 / _s56;

    _r111 > 4 ? _a46 = ba[_r111 - 8 + 4 - 1] : 0 == _r111 && (_a46 = 0), n.push(_a46);

    var _o25 = 1 / (_s56 - 1),
        _l23 = -_o25 / 2,
        _c19 = 1 + _o25 / 2,
        _h9 = [_l23, _l23, _c19, _l23, _c19, _c19, _l23, _l23, _c19, _c19, _l23, _c19],
        _u10 = 6,
        _d10 = 6,
        _A8 = 3,
        _p5 = 2,
        _g2 = 1,
        _m2 = new Float32Array(_A8 * _d10 * _u10),
        _f3 = new Float32Array(_p5 * _d10 * _u10),
        _v3 = new Float32Array(_g2 * _d10 * _u10);

    for (var _t224 = 0; _t224 < _u10; _t224++) {
      var _e174 = _t224 % 3 * 2 / 3 - 1,
          _n171 = _t224 > 2 ? 0 : -1,
          _i152 = [_e174, _n171, 0, _e174 + 2 / 3, _n171, 0, _e174 + 2 / 3, _n171 + 1, 0, _e174, _n171, 0, _e174 + 2 / 3, _n171 + 1, 0, _e174, _n171 + 1, 0];

      _m2.set(_i152, _A8 * _d10 * _t224), _f3.set(_h9, _p5 * _d10 * _t224);
      var _r112 = [_t224, _t224, _t224, _t224, _t224, _t224];

      _v3.set(_r112, _g2 * _d10 * _t224);
    }

    var _y9 = new Te();

    _y9.setAttribute("position", new ve(_m2, _A8)), _y9.setAttribute("uv", new ve(_f3, _p5)), _y9.setAttribute("faceIndex", new ve(_v3, _g2)), t.push(_y9), i > 4 && i--;
  }

  return {
    _lodPlanes: t,
    _sizeLods: e,
    _sigmas: n
  };
}

function Oa(t) {
  var e = new k(3 * wa, 3 * wa, t);
  return e.texture.mapping = 306, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e;
}

function Ha(t, e, n, i, r) {
  t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
}

function za() {
  var t = new R(1, 1);
  return new ls({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {
        value: null
      },
      texelSize: {
        value: t
      },
      inputEncoding: {
        value: Ia[3e3]
      },
      outputEncoding: {
        value: Ia[3e3]
      }
    },
    vertexShader: Wa(),
    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t".concat(qa(), "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}

function Va() {
  return new ls({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {
        value: null
      },
      inputEncoding: {
        value: Ia[3e3]
      },
      outputEncoding: {
        value: Ia[3e3]
      }
    },
    vertexShader: Wa(),
    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t".concat(qa(), "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}

function Wa() {
  return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
}

function qa() {
  return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
}

fa.prototype.update = function () {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
}, Ss.prototype.extractUrlBase = function (t) {
  return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ks.extractUrlBase(t);
}, Ss.Handlers = {
  add: function add() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function get() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
}, W.prototype.center = function (t) {
  return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
}, W.prototype.empty = function () {
  return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, W.prototype.isIntersectionBox = function (t) {
  return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
}, W.prototype.isIntersectionSphere = function (t) {
  return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
}, W.prototype.size = function (t) {
  return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
}, ht.prototype.empty = function () {
  return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, hn.prototype.setFromMatrix = function (t) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
}, D.prototype.flattenToArrayOffset = function (t, e) {
  return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
}, D.prototype.multiplyVector3 = function (t) {
  return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
}, D.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
}, D.prototype.applyToBufferAttribute = function (t) {
  return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
}, D.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
}, D.prototype.getInverse = function (t) {
  return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
}, yt.prototype.extractPosition = function (t) {
  return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
}, yt.prototype.flattenToArrayOffset = function (t, e) {
  return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
}, yt.prototype.getPosition = function () {
  return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new H().setFromMatrixColumn(this, 3);
}, yt.prototype.setRotationFromQuaternion = function (t) {
  return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
}, yt.prototype.multiplyToArray = function () {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
}, yt.prototype.multiplyVector3 = function (t) {
  return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, yt.prototype.multiplyVector4 = function (t) {
  return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, yt.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
}, yt.prototype.rotateAxis = function (t) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
}, yt.prototype.crossVector = function (t) {
  return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, yt.prototype.translate = function () {
  console.error("THREE.Matrix4: .translate() has been removed.");
}, yt.prototype.rotateX = function () {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
}, yt.prototype.rotateY = function () {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
}, yt.prototype.rotateZ = function () {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
}, yt.prototype.rotateByAxis = function () {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
}, yt.prototype.applyToBufferAttribute = function (t) {
  return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, yt.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
}, yt.prototype.makeFrustum = function (t, e, n, i, r, s) {
  return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s);
}, yt.prototype.getInverse = function (t) {
  return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
}, Yt.prototype.isIntersectionLine = function (t) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
}, O.prototype.multiplyVector3 = function (t) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
}, O.prototype.inverse = function () {
  return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
}, vt.prototype.isIntersectionBox = function (t) {
  return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
}, vt.prototype.isIntersectionPlane = function (t) {
  return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
}, vt.prototype.isIntersectionSphere = function (t) {
  return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
}, se.prototype.area = function () {
  return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
}, se.prototype.barycoordFromPoint = function (t, e) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
}, se.prototype.midpoint = function (t) {
  return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
}, se.prototypenormal = function (t) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
}, se.prototype.plane = function (t) {
  return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
}, se.barycoordFromPoint = function (t, e, n, i, r) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), se.getBarycoord(t, e, n, i, r);
}, se.normal = function (t, e, n, i) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), se.getNormal(t, e, n, i);
}, R.prototype.fromAttribute = function (t, e, n) {
  return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
}, R.prototype.distanceToManhattan = function (t) {
  return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
}, R.prototype.lengthManhattan = function () {
  return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, H.prototype.setEulerFromRotationMatrix = function () {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
}, H.prototype.setEulerFromQuaternion = function () {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
}, H.prototype.getPositionFromMatrix = function (t) {
  return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
}, H.prototype.getScaleFromMatrix = function (t) {
  return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
}, H.prototype.getColumnFromMatrix = function (t, e) {
  return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
}, H.prototype.applyProjection = function (t) {
  return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
}, H.prototype.fromAttribute = function (t, e, n) {
  return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
}, H.prototype.distanceToManhattan = function (t) {
  return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
}, H.prototype.lengthManhattan = function () {
  return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, G.prototype.fromAttribute = function (t, e, n) {
  return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
}, G.prototype.lengthManhattan = function () {
  return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, Vt.prototype.getChildByName = function (t) {
  return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
}, Vt.prototype.renderDepth = function () {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
}, Vt.prototype.translate = function (t, e) {
  return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
}, Vt.prototype.getWorldRotation = function () {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
}, Vt.prototype.applyMatrix = function (t) {
  return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
}, Object.defineProperties(Vt.prototype, {
  eulerOrder: {
    get: function get() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function set(t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
    }
  },
  useQuaternion: {
    get: function get() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function set() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
}), Ye.prototype.setDrawMode = function () {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
}, Object.defineProperties(Ye.prototype, {
  drawMode: {
    get: function get() {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
    },
    set: function set() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
}), Fr.prototype.initBones = function () {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
}, nn.prototype.setLens = function (t, e) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t);
}, Object.defineProperties(Fs.prototype, {
  onlyShadow: {
    set: function set() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
    }
  },
  shadowCameraLeft: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
    }
  },
  shadowCameraRight: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
    }
  },
  shadowCameraTop: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
    }
  },
  shadowCameraBottom: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
    }
  },
  shadowCameraNear: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
    }
  },
  shadowCameraFar: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
    }
  },
  shadowCameraVisible: {
    set: function set() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
    }
  },
  shadowDarkness: {
    set: function set() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
    }
  },
  shadowMapHeight: {
    set: function set(t) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
    }
  }
}), Object.defineProperties(ve.prototype, {
  length: {
    get: function get() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function get() {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage;
    },
    set: function set() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
    }
  }
}), ve.prototype.setDynamic = function (t) {
  return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this;
}, ve.prototype.copyIndicesArray = function () {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, ve.prototype.setArray = function () {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, Te.prototype.addIndex = function (t) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
}, Te.prototype.addAttribute = function (t, e) {
  return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new ve(arguments[1], arguments[2])));
}, Te.prototype.addDrawCall = function (t, e, n) {
  void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
}, Te.prototype.clearDrawCalls = function () {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
}, Te.prototype.computeOffsets = function () {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
}, Te.prototype.removeAttribute = function (t) {
  return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
}, Te.prototype.applyMatrix = function (t) {
  return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
}, Object.defineProperties(Te.prototype, {
  drawcalls: {
    get: function get() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function get() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
}), Sr.prototype.setDynamic = function (t) {
  return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this;
}, Sr.prototype.setArray = function () {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, Mr.prototype.dispose = function () {
  console.error("THREE.Scene: .dispose() has been removed.");
}, Object.defineProperties(oe.prototype, {
  wrapAround: {
    get: function get() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function set() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function get() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function set() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function get() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new pe();
    }
  },
  shading: {
    get: function get() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function set(t) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t;
    }
  },
  stencilMask: {
    get: function get() {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function set(t) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
    }
  }
}), Object.defineProperties(tn.prototype, {
  derivatives: {
    get: function get() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function set(t) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
    }
  }
}), Ir.prototype.clearTarget = function (t, e, n, i) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i);
}, Ir.prototype.animate = function (t) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
}, Ir.prototype.getCurrentRenderTarget = function () {
  return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
}, Ir.prototype.getMaxAnisotropy = function () {
  return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
}, Ir.prototype.getPrecision = function () {
  return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
}, Ir.prototype.resetGLState = function () {
  return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
}, Ir.prototype.supportsFloatTextures = function () {
  return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
}, Ir.prototype.supportsHalfFloatTextures = function () {
  return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
}, Ir.prototype.supportsStandardDerivatives = function () {
  return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
}, Ir.prototype.supportsCompressedTextureS3TC = function () {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
}, Ir.prototype.supportsCompressedTexturePVRTC = function () {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
}, Ir.prototype.supportsBlendMinMax = function () {
  return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
}, Ir.prototype.supportsVertexTextures = function () {
  return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
}, Ir.prototype.supportsInstancedArrays = function () {
  return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
}, Ir.prototype.enableScissorTest = function (t) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
}, Ir.prototype.initMaterial = function () {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
}, Ir.prototype.addPrePlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
}, Ir.prototype.addPostPlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
}, Ir.prototype.updateShadowMap = function () {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
}, Ir.prototype.setFaceCulling = function () {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
}, Ir.prototype.allocTextureUnit = function () {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
}, Ir.prototype.setTexture = function () {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
}, Ir.prototype.setTexture2D = function () {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
}, Ir.prototype.setTextureCube = function () {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
}, Ir.prototype.getActiveMipMapLevel = function () {
  return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
}, Object.defineProperties(Ir.prototype, {
  shadowMapEnabled: {
    get: function get() {
      return this.shadowMap.enabled;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
    }
  },
  shadowMapType: {
    get: function get() {
      return this.shadowMap.type;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
    }
  },
  shadowMapCullFace: {
    get: function get() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function set() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function get() {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function get() {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function get() {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function set() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function get() {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? 3001 : 3e3;
    }
  },
  toneMappingWhitePoint: {
    get: function get() {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    },
    set: function set() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
}), Object.defineProperties(gr.prototype, {
  cullFace: {
    get: function get() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function set() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function get() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function set() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function get() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function set() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
}), Object.defineProperties(k.prototype, {
  wrapS: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
    }
  },
  wrapT: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
    }
  },
  magFilter: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
    }
  },
  minFilter: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
    }
  },
  anisotropy: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
    }
  },
  offset: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
    }
  },
  repeat: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
    }
  },
  format: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
    }
  },
  type: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
    }
  },
  generateMipmaps: {
    get: function get() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
    }
  }
}), rn.prototype.updateCubeMap = function (t, e) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
}, rn.prototype.clear = function (t, e, n, i) {
  return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i);
}, P.crossOrigin = void 0, P.loadTexture = function (t, e, n, i) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  var r = new Ps();
  r.setCrossOrigin(this.crossOrigin);
  var s = r.load(t, n, void 0, i);
  return e && (s.mapping = e), s;
}, P.loadTextureCube = function (t, e, n, i) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  var r = new Ds();
  r.setCrossOrigin(this.crossOrigin);
  var s = r.load(t, n, void 0, i);
  return e && (s.mapping = e), s;
}, P.loadCompressedTexture = function () {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
}, P.loadCompressedTextureCube = function () {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
  detail: {
    revision: "128"
  }
})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "128");
var ja = new WeakMap();

function Ya() {
  var t, e;

  function n(t, e, n, i, r, s) {
    var a = s.num_components(),
        o = n.num_points() * a,
        l = o * r.BYTES_PER_ELEMENT,
        c = function (t, e) {
      switch (e) {
        case Float32Array:
          return t.DT_FLOAT32;

        case Int8Array:
          return t.DT_INT8;

        case Int16Array:
          return t.DT_INT16;

        case Int32Array:
          return t.DT_INT32;

        case Uint8Array:
          return t.DT_UINT8;

        case Uint16Array:
          return t.DT_UINT16;

        case Uint32Array:
          return t.DT_UINT32;
      }
    }(t, r),
        h = t._malloc(l);

    e.GetAttributeDataArrayForAllPoints(n, s, c, l, h);
    var u = new r(t.HEAPF32.buffer, h, o).slice();
    return t._free(h), {
      name: i,
      array: u,
      itemSize: a
    };
  }

  onmessage = function onmessage(i) {
    var r = i.data;

    switch (r.type) {
      case "init":
        t = r.decoderConfig, e = new Promise(function (e) {
          t.onModuleLoaded = function (t) {
            e({
              draco: t
            });
          }, DracoDecoderModule(t);
        });
        break;

      case "decode":
        var _i153 = r.buffer,
            _s57 = r.taskConfig;
        e.then(function (t) {
          var e = t.draco,
              a = new e.Decoder(),
              o = new e.DecoderBuffer();
          o.Init(new Int8Array(_i153), _i153.byteLength);

          try {
            var _t225 = function (t, e, i, r) {
              var s = r.attributeIDs,
                  a = r.attributeTypes;
              var o, l;
              var c = e.GetEncodedGeometryType(i);
              if (c === t.TRIANGULAR_MESH) o = new t.Mesh(), l = e.DecodeBufferToMesh(i, o);else {
                if (c !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                o = new t.PointCloud(), l = e.DecodeBufferToPointCloud(i, o);
              }
              if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
              var h = {
                index: null,
                attributes: []
              };

              for (var _i155 in s) {
                var _l24 = self[a[_i155]];

                var _c20 = void 0,
                    _u11 = void 0;

                if (r.useUniqueIDs) _u11 = s[_i155], _c20 = e.GetAttributeByUniqueId(o, _u11);else {
                  if (_u11 = e.GetAttributeId(o, t[s[_i155]]), -1 === _u11) continue;
                  _c20 = e.GetAttribute(o, _u11);
                }
                h.attributes.push(n(t, e, o, _i155, _l24, _c20));
              }

              c === t.TRIANGULAR_MESH && (h.index = function (t, e, n) {
                var i = 3 * n.num_faces(),
                    r = 4 * i,
                    s = t._malloc(r);

                e.GetTrianglesUInt32Array(n, r, s);
                var a = new Uint32Array(t.HEAPF32.buffer, s, i).slice();
                return t._free(s), {
                  array: a,
                  itemSize: 1
                };
              }(t, e, o));
              return t.destroy(o), h;
            }(e, a, o, _s57),
                _i154 = _t225.attributes.map(function (t) {
              return t.array.buffer;
            });

            _t225.index && _i154.push(_t225.index.array.buffer), self.postMessage({
              type: "decode",
              id: r.id,
              geometry: _t225
            }, _i154);
          } catch (t) {
            console.error(t), self.postMessage({
              type: "error",
              id: r.id,
              error: t.message
            });
          } finally {
            e.destroy(o), e.destroy(a);
          }
        });
    }
  };
}

var Ja = /*#__PURE__*/function (_Ss8) {
  _inherits(Ja, _Ss8);

  var _super70 = _createSuper(Ja);

  function Ja(t) {
    var _this56;

    _classCallCheck(this, Ja);

    _this56 = _super70.call(this, t), _this56.dracoLoader = null, _this56.ktx2Loader = null, _this56.meshoptDecoder = null, _this56.pluginCallbacks = [], _this56.register(function (t) {
      return new to(t);
    }), _this56.register(function (t) {
      return new no(t);
    }), _this56.register(function (t) {
      return new io(t);
    }), _this56.register(function (t) {
      return new eo(t);
    }), _this56.register(function (t) {
      return new Za(t);
    }), _this56.register(function (t) {
      return new ro(t);
    });
    return _this56;
  }

  _createClass(Ja, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this;
      var s;
      s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Ks.extractUrlBase(t), this.manager.itemStart(t);

      var a = function a(e) {
        i ? i(e) : console.error(e), r.manager.itemError(t), r.manager.itemEnd(t);
      },
          o = new Ts(this.manager);

      o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function (n) {
        try {
          r.parse(n, s, function (n) {
            e(n), r.manager.itemEnd(t);
          }, a);
        } catch (t) {
          a(t);
        }
      }, n, a);
    }
  }, {
    key: "setDRACOLoader",
    value: function setDRACOLoader(t) {
      return this.dracoLoader = t, this;
    }
  }, {
    key: "setDDSLoader",
    value: function setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
  }, {
    key: "setKTX2Loader",
    value: function setKTX2Loader(t) {
      return this.ktx2Loader = t, this;
    }
  }, {
    key: "setMeshoptDecoder",
    value: function setMeshoptDecoder(t) {
      return this.meshoptDecoder = t, this;
    }
  }, {
    key: "register",
    value: function register(t) {
      return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
    }
  }, {
    key: "unregister",
    value: function unregister(t) {
      return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
    }
  }, {
    key: "parse",
    value: function parse(t, e, n, i) {
      var r;
      var s = {},
          a = {};
      if ("string" == typeof t) r = t;else {
        if (Ks.decodeText(new Uint8Array(t, 0, 4)) === so) {
          try {
            s[Ka.KHR_BINARY_GLTF] = new lo(t);
          } catch (t) {
            return void (i && i(t));
          }

          r = s[Ka.KHR_BINARY_GLTF].content;
        } else r = Ks.decodeText(new Uint8Array(t));
      }
      var o = JSON.parse(r);
      if (void 0 === o.asset || o.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
      var l = new Oo(o, {
        path: e || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      l.fileLoader.setRequestHeader(this.requestHeader);

      for (var _t226 = 0; _t226 < this.pluginCallbacks.length; _t226++) {
        var _e175 = this.pluginCallbacks[_t226](l);

        a[_e175.name] = _e175, s[_e175.name] = !0;
      }

      if (o.extensionsUsed) for (var _t227 = 0; _t227 < o.extensionsUsed.length; ++_t227) {
        var _e176 = o.extensionsUsed[_t227],
            _n172 = o.extensionsRequired || [];

        switch (_e176) {
          case Ka.KHR_MATERIALS_UNLIT:
            s[_e176] = new $a();
            break;

          case Ka.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            s[_e176] = new Ao();
            break;

          case Ka.KHR_DRACO_MESH_COMPRESSION:
            s[_e176] = new co(o, this.dracoLoader);
            break;

          case Ka.KHR_TEXTURE_TRANSFORM:
            s[_e176] = new ho();
            break;

          case Ka.KHR_MESH_QUANTIZATION:
            s[_e176] = new po();
            break;

          default:
            _n172.indexOf(_e176) >= 0 && void 0 === a[_e176] && console.warn('THREE.GLTFLoader: Unknown extension "' + _e176 + '".');
        }
      }
      l.setExtensions(s), l.setPlugins(a), l.parse(n, i);
    }
  }]);

  return Ja;
}(Ss);

function Xa() {
  var t = {};
  return {
    get: function get(e) {
      return t[e];
    },
    add: function add(e, n) {
      t[e] = n;
    },
    remove: function remove(e) {
      delete t[e];
    },
    removeAll: function removeAll() {
      t = {};
    }
  };
}

var Ka = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};

var Za = /*#__PURE__*/function () {
  function Za(t) {
    _classCallCheck(this, Za);

    this.parser = t, this.name = Ka.KHR_LIGHTS_PUNCTUAL, this.cache = {
      refs: {},
      uses: {}
    };
  }

  _createClass(Za, [{
    key: "_markDefs",
    value: function _markDefs() {
      var t = this.parser,
          e = this.parser.json.nodes || [];

      for (var _n173 = 0, _i156 = e.length; _n173 < _i156; _n173++) {
        var _i157 = e[_n173];
        _i157.extensions && _i157.extensions[this.name] && void 0 !== _i157.extensions[this.name].light && t._addNodeRef(this.cache, _i157.extensions[this.name].light);
      }
    }
  }, {
    key: "_loadLight",
    value: function _loadLight(t) {
      var e = this.parser,
          n = "light:" + t;
      var i = e.cache.get(n);
      if (i) return i;
      var r = e.json,
          s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
      var a;
      var o = new pe(16777215);
      void 0 !== s.color && o.fromArray(s.color);
      var l = void 0 !== s.range ? s.range : 0;

      switch (s.type) {
        case "directional":
          a = new Xs(o), a.target.position.set(0, 0, -1), a.add(a.target);
          break;

        case "point":
          a = new js(o), a.distance = l;
          break;

        case "spot":
          a = new Hs(o), a.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
          break;

        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type);
      }

      return a.position.set(0, 0, 0), a.decay = 2, void 0 !== s.intensity && (a.intensity = s.intensity), a.name = e.createUniqueName(s.name || "light_" + t), i = Promise.resolve(a), e.cache.add(n, i), i;
    }
  }, {
    key: "createNodeAttachment",
    value: function createNodeAttachment(t) {
      var e = this,
          n = this.parser,
          i = n.json.nodes[t],
          r = (i.extensions && i.extensions[this.name] || {}).light;
      return void 0 === r ? null : this._loadLight(r).then(function (t) {
        return n._getNodeRef(e.cache, r, t);
      });
    }
  }]);

  return Za;
}();

var $a = /*#__PURE__*/function () {
  function $a() {
    _classCallCheck(this, $a);

    this.name = Ka.KHR_MATERIALS_UNLIT;
  }

  _createClass($a, [{
    key: "getMaterialType",
    value: function getMaterialType() {
      return ge;
    }
  }, {
    key: "extendParams",
    value: function extendParams(t, e, n) {
      var i = [];
      t.color = new pe(1, 1, 1), t.opacity = 1;
      var r = e.pbrMetallicRoughness;

      if (r) {
        if (Array.isArray(r.baseColorFactor)) {
          var _e177 = r.baseColorFactor;
          t.color.fromArray(_e177), t.opacity = _e177[3];
        }

        void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture));
      }

      return Promise.all(i);
    }
  }]);

  return $a;
}();

var to = /*#__PURE__*/function () {
  function to(t) {
    _classCallCheck(this, to);

    this.parser = t, this.name = Ka.KHR_MATERIALS_CLEARCOAT;
  }

  _createClass(to, [{
    key: "getMaterialType",
    value: function getMaterialType(t) {
      var e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? hs : null;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(t, e) {
      var n = this.parser,
          i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      var r = [],
          s = i.extensions[this.name];

      if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
        var _t228 = s.clearcoatNormalTexture.scale;
        e.clearcoatNormalScale = new R(_t228, -_t228);
      }

      return Promise.all(r);
    }
  }]);

  return to;
}();

var eo = /*#__PURE__*/function () {
  function eo(t) {
    _classCallCheck(this, eo);

    this.parser = t, this.name = Ka.KHR_MATERIALS_TRANSMISSION;
  }

  _createClass(eo, [{
    key: "getMaterialType",
    value: function getMaterialType(t) {
      var e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? hs : null;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(t, e) {
      var n = this.parser,
          i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      var r = [],
          s = i.extensions[this.name];
      return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(r);
    }
  }]);

  return eo;
}();

var no = /*#__PURE__*/function () {
  function no(t) {
    _classCallCheck(this, no);

    this.parser = t, this.name = Ka.KHR_TEXTURE_BASISU;
  }

  _createClass(no, [{
    key: "loadTexture",
    value: function loadTexture(t) {
      var e = this.parser,
          n = e.json,
          i = n.textures[t];
      if (!i.extensions || !i.extensions[this.name]) return null;
      var r = i.extensions[this.name],
          s = n.images[r.source],
          a = e.options.ktx2Loader;

      if (!a) {
        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }

      return e.loadTextureImage(t, s, a);
    }
  }]);

  return no;
}();

var io = /*#__PURE__*/function () {
  function io(t) {
    _classCallCheck(this, io);

    this.parser = t, this.name = Ka.EXT_TEXTURE_WEBP, this.isSupported = null;
  }

  _createClass(io, [{
    key: "loadTexture",
    value: function loadTexture(t) {
      var e = this.name,
          n = this.parser,
          i = n.json,
          r = i.textures[t];
      if (!r.extensions || !r.extensions[e]) return null;
      var s = r.extensions[e],
          a = i.images[s.source];
      var o = n.textureLoader;

      if (a.uri) {
        var _t229 = n.options.manager.getHandler(a.uri);

        null !== _t229 && (o = _t229);
      }

      return this.detectSupport().then(function (r) {
        if (r) return n.loadTextureImage(t, a, o);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n.loadTexture(t);
      });
    }
  }, {
    key: "detectSupport",
    value: function detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function (t) {
        var e = new Image();
        e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function () {
          t(1 === e.height);
        };
      })), this.isSupported;
    }
  }]);

  return io;
}();

var ro = /*#__PURE__*/function () {
  function ro(t) {
    _classCallCheck(this, ro);

    this.name = Ka.EXT_MESHOPT_COMPRESSION, this.parser = t;
  }

  _createClass(ro, [{
    key: "loadBufferView",
    value: function loadBufferView(t) {
      var e = this.parser.json,
          n = e.bufferViews[t];

      if (n.extensions && n.extensions[this.name]) {
        var _t230 = n.extensions[this.name],
            _i158 = this.parser.getDependency("buffer", _t230.buffer),
            _r113 = this.parser.options.meshoptDecoder;

        if (!_r113 || !_r113.supported) {
          if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }

        return Promise.all([_i158, _r113.ready]).then(function (e) {
          var n = _t230.byteOffset || 0,
              i = _t230.byteLength || 0,
              s = _t230.count,
              a = _t230.byteStride,
              o = new ArrayBuffer(s * a),
              l = new Uint8Array(e[0], n, i);
          return _r113.decodeGltfBuffer(new Uint8Array(o), s, a, l, _t230.mode, _t230.filter), o;
        });
      }

      return null;
    }
  }]);

  return ro;
}();

var so = "glTF",
    ao = 1313821514,
    oo = 5130562;

var lo = function lo(t) {
  _classCallCheck(this, lo);

  this.name = Ka.KHR_BINARY_GLTF, this.content = null, this.body = null;
  var e = new DataView(t, 0, 12);
  if (this.header = {
    magic: Ks.decodeText(new Uint8Array(t.slice(0, 4))),
    version: e.getUint32(4, !0),
    length: e.getUint32(8, !0)
  }, this.header.magic !== so) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
  if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
  var n = this.header.length - 12,
      i = new DataView(t, 12);
  var r = 0;

  for (; r < n;) {
    var _e178 = i.getUint32(r, !0);

    r += 4;

    var _n174 = i.getUint32(r, !0);

    if (r += 4, _n174 === ao) {
      var _n175 = new Uint8Array(t, 12 + r, _e178);

      this.content = Ks.decodeText(_n175);
    } else if (_n174 === oo) {
      var _n176 = 12 + r;

      this.body = t.slice(_n176, _n176 + _e178);
    }

    r += _e178;
  }

  if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
};

var co = /*#__PURE__*/function () {
  function co(t, e) {
    _classCallCheck(this, co);

    if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ka.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload();
  }

  _createClass(co, [{
    key: "decodePrimitive",
    value: function decodePrimitive(t, e) {
      var n = this.json,
          i = this.dracoLoader,
          r = t.extensions[this.name].bufferView,
          s = t.extensions[this.name].attributes,
          a = {},
          o = {},
          l = {};

      for (var _t231 in s) {
        var _e179 = Mo[_t231] || _t231.toLowerCase();

        a[_e179] = s[_t231];
      }

      for (var _e180 in t.attributes) {
        var _i159 = Mo[_e180] || _e180.toLowerCase();

        if (void 0 !== s[_e180]) {
          var _r114 = n.accessors[t.attributes[_e180]],
              _s58 = bo[_r114.componentType];
          l[_i159] = _s58, o[_i159] = !0 === _r114.normalized;
        }
      }

      return e.getDependency("bufferView", r).then(function (t) {
        return new Promise(function (e) {
          i.decodeDracoFile(t, function (t) {
            for (var _e181 in t.attributes) {
              var _n177 = t.attributes[_e181],
                  _i160 = o[_e181];
              void 0 !== _i160 && (_n177.normalized = _i160);
            }

            e(t);
          }, a, l);
        });
      });
    }
  }]);

  return co;
}();

var ho = /*#__PURE__*/function () {
  function ho() {
    _classCallCheck(this, ho);

    this.name = Ka.KHR_TEXTURE_TRANSFORM;
  }

  _createClass(ho, [{
    key: "extendTexture",
    value: function extendTexture(t, e) {
      return t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.needsUpdate = !0, t;
    }
  }]);

  return ho;
}();

var uo = /*#__PURE__*/function (_cs2) {
  _inherits(uo, _cs2);

  var _super71 = _createSuper(uo);

  function uo(t) {
    var _this57;

    _classCallCheck(this, uo);

    _this57 = _super71.call(this), _this57.isGLTFSpecularGlossinessMaterial = !0;
    var e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
        n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
        i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
        r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
        s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
        a = {
      specular: {
        value: new pe().setHex(16777215)
      },
      glossiness: {
        value: 1
      },
      specularMap: {
        value: null
      },
      glossinessMap: {
        value: null
      }
    };
    _this57._extraUniforms = a, _this57.onBeforeCompile = function (t) {
      for (var _e182 in a) {
        t.uniforms[_e182] = a[_e182];
      }

      t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s);
    }, Object.defineProperties(_assertThisInitialized(_this57), {
      specular: {
        get: function get() {
          return a.specular.value;
        },
        set: function set(t) {
          a.specular.value = t;
        }
      },
      specularMap: {
        get: function get() {
          return a.specularMap.value;
        },
        set: function set(t) {
          a.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
        }
      },
      glossiness: {
        get: function get() {
          return a.glossiness.value;
        },
        set: function set(t) {
          a.glossiness.value = t;
        }
      },
      glossinessMap: {
        get: function get() {
          return a.glossinessMap.value;
        },
        set: function set(t) {
          a.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
        }
      }
    }), delete _this57.metalness, delete _this57.roughness, delete _this57.metalnessMap, delete _this57.roughnessMap, _this57.setValues(t);
    return _this57;
  }

  _createClass(uo, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(uo.prototype), "copy", this).call(this, t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
    }
  }]);

  return uo;
}(cs);

var Ao = /*#__PURE__*/function () {
  function Ao() {
    _classCallCheck(this, Ao);

    this.name = Ka.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"];
  }

  _createClass(Ao, [{
    key: "getMaterialType",
    value: function getMaterialType() {
      return uo;
    }
  }, {
    key: "extendParams",
    value: function extendParams(t, e, n) {
      var i = e.extensions[this.name];
      t.color = new pe(1, 1, 1), t.opacity = 1;
      var r = [];

      if (Array.isArray(i.diffuseFactor)) {
        var _e183 = i.diffuseFactor;
        t.color.fromArray(_e183), t.opacity = _e183[3];
      }

      if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, "map", i.diffuseTexture)), t.emissive = new pe(0, 0, 0), t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, t.specular = new pe(1, 1, 1), Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
        var _e184 = i.specularGlossinessTexture;
        r.push(n.assignTexture(t, "glossinessMap", _e184)), r.push(n.assignTexture(t, "specularMap", _e184));
      }

      return Promise.all(r);
    }
  }, {
    key: "createMaterial",
    value: function createMaterial(t) {
      var e = new uo(t);
      return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = 0, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e;
    }
  }]);

  return Ao;
}();

var po = function po() {
  _classCallCheck(this, po);

  this.name = Ka.KHR_MESH_QUANTIZATION;
};

var go = /*#__PURE__*/function (_ds5) {
  _inherits(go, _ds5);

  var _super72 = _createSuper(go);

  function go(t, e, n, i) {
    _classCallCheck(this, go);

    return _super72.call(this, t, e, n, i);
  }

  _createClass(go, [{
    key: "copySampleValue_",
    value: function copySampleValue_(t) {
      var e = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = t * i * 3 + i;

      for (var _t232 = 0; _t232 !== i; _t232++) {
        e[_t232] = n[r + _t232];
      }

      return e;
    }
  }]);

  return go;
}(ds);

go.prototype.beforeStart_ = go.prototype.copySampleValue_, go.prototype.afterEnd_ = go.prototype.copySampleValue_, go.prototype.interpolate_ = function (t, e, n, i) {
  var r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = 2 * a,
      l = 3 * a,
      c = i - e,
      h = (n - e) / c,
      u = h * h,
      d = u * h,
      A = t * l,
      p = A - l,
      g = -2 * d + 3 * u,
      m = d - u,
      f = 1 - g,
      v = m - u + h;

  for (var _t233 = 0; _t233 !== a; _t233++) {
    var _e185 = s[p + _t233 + a],
        _n178 = s[p + _t233 + o] * c,
        _i161 = s[A + _t233 + a],
        _l25 = s[A + _t233] * c;

    r[_t233] = f * _e185 + v * _n178 + g * _i161 + m * _l25;
  }

  return r;
};
var mo = 0,
    fo = 1,
    vo = 2,
    yo = 3,
    Eo = 4,
    xo = 5,
    wo = 6,
    bo = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
},
    _o = {
  9728: 1003,
  9729: 1006,
  9984: 1004,
  9985: 1007,
  9986: 1005,
  9987: 1008
},
    Io = {
  33071: 1001,
  33648: 1002,
  10497: 1e3
},
    Co = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
},
    Mo = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
},
    So = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
},
    Bo = {
  CUBICSPLINE: void 0,
  LINEAR: 2301,
  STEP: 2300
},
    To = "OPAQUE",
    Lo = "MASK",
    Ro = "BLEND";

function Do(t, e) {
  return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
}

function Qo(t) {
  return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new cs({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: 0
  })), t.DefaultMaterial;
}

function Po(t, e, n) {
  for (var _i162 in n.extensions) {
    void 0 === t[_i162] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[_i162] = n.extensions[_i162]);
  }
}

function Fo(t, e) {
  void 0 !== e.extras && ("object" == _typeof(e.extras) ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}

function No(t, e) {
  if (t.updateMorphTargets(), void 0 !== e.weights) for (var _n179 = 0, _i163 = e.weights.length; _n179 < _i163; _n179++) {
    t.morphTargetInfluences[_n179] = e.weights[_n179];
  }

  if (e.extras && Array.isArray(e.extras.targetNames)) {
    var _n180 = e.extras.targetNames;

    if (t.morphTargetInfluences.length === _n180.length) {
      t.morphTargetDictionary = {};

      for (var _e186 = 0, _i164 = _n180.length; _e186 < _i164; _e186++) {
        t.morphTargetDictionary[_n180[_e186]] = _e186;
      }
    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}

function Uo(t) {
  var e = t.extensions && t.extensions[Ka.KHR_DRACO_MESH_COMPRESSION];
  var n;
  return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + Go(e.attributes) : t.indices + ":" + Go(t.attributes) + ":" + t.mode, n;
}

function Go(t) {
  var e = "";
  var n = Object.keys(t).sort();

  for (var _i165 = 0, _r115 = n.length; _i165 < _r115; _i165++) {
    e += n[_i165] + ":" + t[n[_i165]] + ";";
  }

  return e;
}

function ko(t) {
  switch (t) {
    case Int8Array:
      return 1 / 127;

    case Uint8Array:
      return 1 / 255;

    case Int16Array:
      return 1 / 32767;

    case Uint16Array:
      return 1 / 65535;

    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}

var Oo = /*#__PURE__*/function () {
  function Oo() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Oo);

    this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new Xa(), this.associations = new Map(), this.primitiveCache = {}, this.meshCache = {
      refs: {},
      uses: {}
    }, this.cameraCache = {
      refs: {},
      uses: {}
    }, this.lightCache = {
      refs: {},
      uses: {}
    }, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new Zs(this.options.manager) : this.textureLoader = new Ps(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Ts(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
  }

  _createClass(Oo, [{
    key: "setExtensions",
    value: function setExtensions(t) {
      this.extensions = t;
    }
  }, {
    key: "setPlugins",
    value: function setPlugins(t) {
      this.plugins = t;
    }
  }, {
    key: "parse",
    value: function parse(t, e) {
      var n = this,
          i = this.json,
          r = this.extensions;
      this.cache.removeAll(), this._invokeAll(function (t) {
        return t._markDefs && t._markDefs();
      }), Promise.all(this._invokeAll(function (t) {
        return t.beforeRoot && t.beforeRoot();
      })).then(function () {
        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]);
      }).then(function (e) {
        var s = {
          scene: e[0][i.scene || 0],
          scenes: e[0],
          animations: e[1],
          cameras: e[2],
          asset: i.asset,
          parser: n,
          userData: {}
        };
        Po(r, s, i), Fo(s, i), Promise.all(n._invokeAll(function (t) {
          return t.afterRoot && t.afterRoot(s);
        })).then(function () {
          t(s);
        });
      }).catch(e);
    }
  }, {
    key: "_markDefs",
    value: function _markDefs() {
      var t = this.json.nodes || [],
          e = this.json.skins || [],
          n = this.json.meshes || [];

      for (var _n181 = 0, _i166 = e.length; _n181 < _i166; _n181++) {
        var _i167 = e[_n181].joints;

        for (var _e187 = 0, _n182 = _i167.length; _e187 < _n182; _e187++) {
          t[_i167[_e187]].isBone = !0;
        }
      }

      for (var _e188 = 0, _i168 = t.length; _e188 < _i168; _e188++) {
        var _i169 = t[_e188];
        void 0 !== _i169.mesh && (this._addNodeRef(this.meshCache, _i169.mesh), void 0 !== _i169.skin && (n[_i169.mesh].isSkinnedMesh = !0)), void 0 !== _i169.camera && this._addNodeRef(this.cameraCache, _i169.camera);
      }
    }
  }, {
    key: "_addNodeRef",
    value: function _addNodeRef(t, e) {
      void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
    }
  }, {
    key: "_getNodeRef",
    value: function _getNodeRef(t, e, n) {
      if (t.refs[e] <= 1) return n;
      var i = n.clone();
      return i.name += "_instance_" + t.uses[e]++, i;
    }
  }, {
    key: "_invokeOne",
    value: function _invokeOne(t) {
      var e = Object.values(this.plugins);
      e.push(this);

      for (var _n183 = 0; _n183 < e.length; _n183++) {
        var _i170 = t(e[_n183]);

        if (_i170) return _i170;
      }

      return null;
    }
  }, {
    key: "_invokeAll",
    value: function _invokeAll(t) {
      var e = Object.values(this.plugins);
      e.unshift(this);
      var n = [];

      for (var _i171 = 0; _i171 < e.length; _i171++) {
        var _r116 = t(e[_i171]);

        _r116 && n.push(_r116);
      }

      return n;
    }
  }, {
    key: "getDependency",
    value: function getDependency(t, e) {
      var n = t + ":" + e;
      var i = this.cache.get(n);

      if (!i) {
        switch (t) {
          case "scene":
            i = this.loadScene(e);
            break;

          case "node":
            i = this.loadNode(e);
            break;

          case "mesh":
            i = this._invokeOne(function (t) {
              return t.loadMesh && t.loadMesh(e);
            });
            break;

          case "accessor":
            i = this.loadAccessor(e);
            break;

          case "bufferView":
            i = this._invokeOne(function (t) {
              return t.loadBufferView && t.loadBufferView(e);
            });
            break;

          case "buffer":
            i = this.loadBuffer(e);
            break;

          case "material":
            i = this._invokeOne(function (t) {
              return t.loadMaterial && t.loadMaterial(e);
            });
            break;

          case "texture":
            i = this._invokeOne(function (t) {
              return t.loadTexture && t.loadTexture(e);
            });
            break;

          case "skin":
            i = this.loadSkin(e);
            break;

          case "animation":
            i = this.loadAnimation(e);
            break;

          case "camera":
            i = this.loadCamera(e);
            break;

          default:
            throw new Error("Unknown type: " + t);
        }

        this.cache.add(n, i);
      }

      return i;
    }
  }, {
    key: "getDependencies",
    value: function getDependencies(t) {
      var e = this.cache.get(t);

      if (!e) {
        var _n184 = this,
            _i172 = this.json[t + ("mesh" === t ? "es" : "s")] || [];

        e = Promise.all(_i172.map(function (e, i) {
          return _n184.getDependency(t, i);
        })), this.cache.add(t, e);
      }

      return e;
    }
  }, {
    key: "loadBuffer",
    value: function loadBuffer(t) {
      var e = this.json.buffers[t],
          n = this.fileLoader;
      if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
      if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[Ka.KHR_BINARY_GLTF].body);
      var i = this.options;
      return new Promise(function (t, r) {
        n.load(Do(e.uri, i.path), t, void 0, function () {
          r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
        });
      });
    }
  }, {
    key: "loadBufferView",
    value: function loadBufferView(t) {
      var e = this.json.bufferViews[t];
      return this.getDependency("buffer", e.buffer).then(function (t) {
        var n = e.byteLength || 0,
            i = e.byteOffset || 0;
        return t.slice(i, i + n);
      });
    }
  }, {
    key: "loadAccessor",
    value: function loadAccessor(t) {
      var e = this,
          n = this.json,
          i = this.json.accessors[t];
      if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
      var r = [];
      return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then(function (t) {
        var r = t[0],
            s = Co[i.type],
            a = bo[i.componentType],
            o = a.BYTES_PER_ELEMENT,
            l = o * s,
            c = i.byteOffset || 0,
            h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
            u = !0 === i.normalized;
        var d, A;

        if (h && h !== l) {
          var _t234 = Math.floor(c / h),
              _n185 = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + _t234 + ":" + i.count;

          var _l26 = e.cache.get(_n185);

          _l26 || (d = new a(r, _t234 * h, i.count * h / o), _l26 = new Sr(d, h / o), e.cache.add(_n185, _l26)), A = new Tr(_l26, s, c % h / o, u);
        } else d = null === r ? new a(i.count * s) : new a(r, c, i.count * s), A = new ve(d, s, u);

        if (void 0 !== i.sparse) {
          var _e189 = Co.SCALAR,
              _n186 = bo[i.sparse.indices.componentType],
              _o26 = i.sparse.indices.byteOffset || 0,
              _l27 = i.sparse.values.byteOffset || 0,
              _c21 = new _n186(t[1], _o26, i.sparse.count * _e189),
              _h10 = new a(t[2], _l27, i.sparse.count * s);

          null !== r && (A = new ve(A.array.slice(), A.itemSize, A.normalized));

          for (var _t235 = 0, _e190 = _c21.length; _t235 < _e190; _t235++) {
            var _e191 = _c21[_t235];
            if (A.setX(_e191, _h10[_t235 * s]), s >= 2 && A.setY(_e191, _h10[_t235 * s + 1]), s >= 3 && A.setZ(_e191, _h10[_t235 * s + 2]), s >= 4 && A.setW(_e191, _h10[_t235 * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }

        return A;
      });
    }
  }, {
    key: "loadTexture",
    value: function loadTexture(t) {
      var e = this.json,
          n = this.options,
          i = e.textures[t],
          r = e.images[i.source];
      var s = this.textureLoader;

      if (r.uri) {
        var _t236 = n.manager.getHandler(r.uri);

        null !== _t236 && (s = _t236);
      }

      return this.loadTextureImage(t, r, s);
    }
  }, {
    key: "loadTextureImage",
    value: function loadTextureImage(t, e, n) {
      var i = this,
          r = this.json,
          s = this.options,
          a = r.textures[t],
          o = self.URL || self.webkitURL;
      var l = e.uri,
          c = !1,
          h = !0;
      if ("image/jpeg" === e.mimeType && (h = !1), void 0 !== e.bufferView) l = i.getDependency("bufferView", e.bufferView).then(function (t) {
        if ("image/png" === e.mimeType) {
          var _e192 = new DataView(t, 25, 1).getUint8(0, !1);

          h = 6 === _e192 || 4 === _e192 || 3 === _e192;
        }

        c = !0;
        var n = new Blob([t], {
          type: e.mimeType
        });
        return l = o.createObjectURL(n), l;
      });else if (void 0 === e.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
      return Promise.resolve(l).then(function (t) {
        return new Promise(function (e, i) {
          var r = e;
          !0 === n.isImageBitmapLoader && (r = function r(t) {
            e(new as(t));
          }), n.load(Do(t, s.path), r, void 0, i);
        });
      }).then(function (e) {
        !0 === c && o.revokeObjectURL(l), e.flipY = !1, a.name && (e.name = a.name), h || (e.format = 1022);
        var n = (r.samplers || {})[a.sampler] || {};
        return e.magFilter = _o[n.magFilter] || 1006, e.minFilter = _o[n.minFilter] || 1008, e.wrapS = Io[n.wrapS] || 1e3, e.wrapT = Io[n.wrapT] || 1e3, i.associations.set(e, {
          type: "textures",
          index: t
        }), e;
      });
    }
  }, {
    key: "assignTexture",
    value: function assignTexture(t, e, n) {
      var i = this;
      return this.getDependency("texture", n.index).then(function (r) {
        if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), i.extensions[Ka.KHR_TEXTURE_TRANSFORM]) {
          var _t237 = void 0 !== n.extensions ? n.extensions[Ka.KHR_TEXTURE_TRANSFORM] : void 0;

          if (_t237) {
            var _e193 = i.associations.get(r);

            r = i.extensions[Ka.KHR_TEXTURE_TRANSFORM].extendTexture(r, _t237), i.associations.set(r, _e193);
          }
        }

        t[e] = r;
      });
    }
  }, {
    key: "assignFinalMaterial",
    value: function assignFinalMaterial(t) {
      var e = t.geometry;
      var n = t.material;
      var i = void 0 !== e.attributes.tangent,
          r = void 0 !== e.attributes.color,
          s = void 0 === e.attributes.normal,
          a = !0 === t.isSkinnedMesh,
          o = Object.keys(e.morphAttributes).length > 0,
          l = o && void 0 !== e.morphAttributes.normal;

      if (t.isPoints) {
        var _t238 = "PointsMaterial:" + n.uuid;

        var _e194 = this.cache.get(_t238);

        _e194 || (_e194 = new Zr(), oe.prototype.copy.call(_e194, n), _e194.color.copy(n.color), _e194.map = n.map, _e194.sizeAttenuation = !1, this.cache.add(_t238, _e194)), n = _e194;
      } else if (t.isLine) {
        var _t239 = "LineBasicMaterial:" + n.uuid;

        var _e195 = this.cache.get(_t239);

        _e195 || (_e195 = new Or(), oe.prototype.copy.call(_e195, n), _e195.color.copy(n.color), this.cache.add(_t239, _e195)), n = _e195;
      }

      if (i || r || s || a || o) {
        var _t240 = "ClonedMaterial:" + n.uuid + ":";

        n.isGLTFSpecularGlossinessMaterial && (_t240 += "specular-glossiness:"), a && (_t240 += "skinning:"), i && (_t240 += "vertex-tangents:"), r && (_t240 += "vertex-colors:"), s && (_t240 += "flat-shading:"), o && (_t240 += "morph-targets:"), l && (_t240 += "morph-normals:");

        var _e196 = this.cache.get(_t240);

        _e196 || (_e196 = n.clone(), a && (_e196.skinning = !0), r && (_e196.vertexColors = !0), s && (_e196.flatShading = !0), o && (_e196.morphTargets = !0), l && (_e196.morphNormals = !0), i && (_e196.vertexTangents = !0, _e196.normalScale && (_e196.normalScale.y *= -1), _e196.clearcoatNormalScale && (_e196.clearcoatNormalScale.y *= -1)), this.cache.add(_t240, _e196), this.associations.set(_e196, this.associations.get(n))), n = _e196;
      }

      n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n;
    }
  }, {
    key: "getMaterialType",
    value: function getMaterialType() {
      return cs;
    }
  }, {
    key: "loadMaterial",
    value: function loadMaterial(t) {
      var e = this,
          n = this.json,
          i = this.extensions,
          r = n.materials[t];
      var s;
      var a = {},
          o = r.extensions || {},
          l = [];

      if (o[Ka.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        var _t241 = i[Ka.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        s = _t241.getMaterialType(), l.push(_t241.extendParams(a, r, e));
      } else if (o[Ka.KHR_MATERIALS_UNLIT]) {
        var _t242 = i[Ka.KHR_MATERIALS_UNLIT];
        s = _t242.getMaterialType(), l.push(_t242.extendParams(a, r, e));
      } else {
        var _n187 = r.pbrMetallicRoughness || {};

        if (a.color = new pe(1, 1, 1), a.opacity = 1, Array.isArray(_n187.baseColorFactor)) {
          var _t243 = _n187.baseColorFactor;
          a.color.fromArray(_t243), a.opacity = _t243[3];
        }

        void 0 !== _n187.baseColorTexture && l.push(e.assignTexture(a, "map", _n187.baseColorTexture)), a.metalness = void 0 !== _n187.metallicFactor ? _n187.metallicFactor : 1, a.roughness = void 0 !== _n187.roughnessFactor ? _n187.roughnessFactor : 1, void 0 !== _n187.metallicRoughnessTexture && (l.push(e.assignTexture(a, "metalnessMap", _n187.metallicRoughnessTexture)), l.push(e.assignTexture(a, "roughnessMap", _n187.metallicRoughnessTexture))), s = this._invokeOne(function (e) {
          return e.getMaterialType && e.getMaterialType(t);
        }), l.push(Promise.all(this._invokeAll(function (e) {
          return e.extendMaterialParams && e.extendMaterialParams(t, a);
        })));
      }

      !0 === r.doubleSided && (a.side = 2);
      var c = r.alphaMode || To;
      return c === Ro ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, c === Lo && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== ge && (l.push(e.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new R(1, -1), void 0 !== r.normalTexture.scale && a.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)), void 0 !== r.occlusionTexture && s !== ge && (l.push(e.assignTexture(a, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== ge && (a.emissive = new pe().fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== ge && l.push(e.assignTexture(a, "emissiveMap", r.emissiveTexture)), Promise.all(l).then(function () {
        var n;
        return n = s === uo ? i[Ka.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a), r.name && (n.name = r.name), n.map && (n.map.encoding = 3001), n.emissiveMap && (n.emissiveMap.encoding = 3001), Fo(n, r), e.associations.set(n, {
          type: "materials",
          index: t
        }), r.extensions && Po(i, n, r), n;
      });
    }
  }, {
    key: "createUniqueName",
    value: function createUniqueName(t) {
      var e = la.sanitizeNodeName(t || "");
      var n = e;

      for (var _t244 = 1; this.nodeNamesUsed[n]; ++_t244) {
        n = e + "_" + _t244;
      }

      return this.nodeNamesUsed[n] = !0, n;
    }
  }, {
    key: "loadGeometries",
    value: function loadGeometries(t) {
      var e = this,
          n = this.extensions,
          i = this.primitiveCache;

      function r(t) {
        return n[Ka.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (n) {
          return zo(n, t, e);
        });
      }

      var s = [];

      for (var _n188 = 0, _a47 = t.length; _n188 < _a47; _n188++) {
        var _a48 = t[_n188],
            _o27 = Uo(_a48),
            _l28 = i[_o27];

        if (_l28) s.push(_l28.promise);else {
          var _t245 = void 0;

          _t245 = _a48.extensions && _a48.extensions[Ka.KHR_DRACO_MESH_COMPRESSION] ? r(_a48) : zo(new Te(), _a48, e), i[_o27] = {
            primitive: _a48,
            promise: _t245
          }, s.push(_t245);
        }
      }

      return Promise.all(s);
    }
  }, {
    key: "loadMesh",
    value: function loadMesh(t) {
      var e = this,
          n = this.json,
          i = this.extensions,
          r = n.meshes[t],
          s = r.primitives,
          a = [];

      for (var _t246 = 0, _e197 = s.length; _t246 < _e197; _t246++) {
        var _e198 = void 0 === s[_t246].material ? Qo(this.cache) : this.getDependency("material", s[_t246].material);

        a.push(_e198);
      }

      return a.push(e.loadGeometries(s)), Promise.all(a).then(function (n) {
        var a = n.slice(0, n.length - 1),
            o = n[n.length - 1],
            l = [];

        for (var _n189 = 0, _c22 = o.length; _n189 < _c22; _n189++) {
          var _c23 = o[_n189],
              _h11 = s[_n189];

          var _u12 = void 0;

          var _d11 = a[_n189];
          if (_h11.mode === Eo || _h11.mode === xo || _h11.mode === wo || void 0 === _h11.mode) _u12 = !0 === r.isSkinnedMesh ? new Fr(_c23, _d11) : new Ye(_c23, _d11), !0 !== _u12.isSkinnedMesh || _u12.geometry.attributes.skinWeight.normalized || _u12.normalizeSkinWeights(), _h11.mode === xo ? _u12.geometry = Vo(_u12.geometry, 1) : _h11.mode === wo && (_u12.geometry = Vo(_u12.geometry, 2));else if (_h11.mode === fo) _u12 = new Xr(_c23, _d11);else if (_h11.mode === yo) _u12 = new jr(_c23, _d11);else if (_h11.mode === vo) _u12 = new Kr(_c23, _d11);else {
            if (_h11.mode !== mo) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + _h11.mode);
            _u12 = new is(_c23, _d11);
          }
          Object.keys(_u12.geometry.morphAttributes).length > 0 && No(_u12, r), _u12.name = e.createUniqueName(r.name || "mesh_" + t), Fo(_u12, r), _h11.extensions && Po(i, _u12, _h11), e.assignFinalMaterial(_u12), l.push(_u12);
        }

        if (1 === l.length) return l[0];
        var c = new Er();

        for (var _t247 = 0, _e199 = l.length; _t247 < _e199; _t247++) {
          c.add(l[_t247]);
        }

        return c;
      });
    }
  }, {
    key: "loadCamera",
    value: function loadCamera(t) {
      var e;
      var n = this.json.cameras[t],
          i = n[n.type];
      if (i) return "perspective" === n.type ? e = new nn(L.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new Ys(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), Fo(e, n), Promise.resolve(e);
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
  }, {
    key: "loadSkin",
    value: function loadSkin(t) {
      var e = this.json.skins[t],
          n = {
        joints: e.joints
      };
      return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then(function (t) {
        return n.inverseBindMatrices = t, n;
      });
    }
  }, {
    key: "loadAnimation",
    value: function loadAnimation(t) {
      var e = this.json.animations[t],
          n = [],
          i = [],
          r = [],
          s = [],
          a = [];

      for (var _t248 = 0, _o28 = e.channels.length; _t248 < _o28; _t248++) {
        var _o29 = e.channels[_t248],
            _l29 = e.samplers[_o29.sampler],
            _c24 = _o29.target,
            _h12 = void 0 !== _c24.node ? _c24.node : _c24.id,
            _u13 = void 0 !== e.parameters ? e.parameters[_l29.input] : _l29.input,
            _d12 = void 0 !== e.parameters ? e.parameters[_l29.output] : _l29.output;

        n.push(this.getDependency("node", _h12)), i.push(this.getDependency("accessor", _u13)), r.push(this.getDependency("accessor", _d12)), s.push(_l29), a.push(_c24);
      }

      return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a)]).then(function (n) {
        var i = n[0],
            r = n[1],
            s = n[2],
            a = n[3],
            o = n[4],
            l = [];

        var _loop2 = function _loop2(_t249, _e200) {
          var e = i[_t249],
              n = r[_t249],
              c = s[_t249],
              h = a[_t249],
              u = o[_t249];
          if (void 0 === e) return "continue";
          var d = void 0;

          switch (e.updateMatrix(), e.matrixAutoUpdate = !0, So[u.path]) {
            case So.weights:
              d = ys;
              break;

            case So.rotation:
              d = xs;
              break;

            case So.position:
            case So.scale:
            default:
              d = bs;
          }

          var A = e.name ? e.name : e.uuid,
              p = void 0 !== h.interpolation ? Bo[h.interpolation] : 2301,
              g = [];
          So[u.path] === So.weights ? e.traverse(function (t) {
            !0 === t.isMesh && t.morphTargetInfluences && g.push(t.name ? t.name : t.uuid);
          }) : g.push(A);
          var m = c.array;

          if (c.normalized) {
            var _t250 = ko(m.constructor),
                _e201 = new Float32Array(m.length);

            for (var _n190 = 0, _i173 = m.length; _n190 < _i173; _n190++) {
              _e201[_n190] = m[_n190] * _t250;
            }

            m = _e201;
          }

          for (var _t251 = 0, _e202 = g.length; _t251 < _e202; _t251++) {
            var _e203 = new d(g[_t251] + "." + So[u.path], n.array, m, p);

            "CUBICSPLINE" === h.interpolation && (_e203.createInterpolant = function (t) {
              return new go(this.times, this.values, this.getValueSize() / 3, t);
            }, _e203.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(_e203);
          }
        };

        for (var _t249 = 0, _e200 = i.length; _t249 < _e200; _t249++) {
          var _ret2 = _loop2(_t249, _e200);

          if (_ret2 === "continue") continue;
        }

        var c = e.name ? e.name : "animation_" + t;
        return new _s(c, void 0, l);
      });
    }
  }, {
    key: "createNodeMesh",
    value: function createNodeMesh(t) {
      var e = this.json,
          n = this,
          i = e.nodes[t];
      return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then(function (t) {
        var e = n._getNodeRef(n.meshCache, i.mesh, t);

        return void 0 !== i.weights && e.traverse(function (t) {
          if (t.isMesh) for (var _e204 = 0, _n191 = i.weights.length; _e204 < _n191; _e204++) {
            t.morphTargetInfluences[_e204] = i.weights[_e204];
          }
        }), e;
      });
    }
  }, {
    key: "loadNode",
    value: function loadNode(t) {
      var e = this.json,
          n = this.extensions,
          i = this,
          r = e.nodes[t],
          s = r.name ? i.createUniqueName(r.name) : "";
      return function () {
        var e = [],
            n = i._invokeOne(function (e) {
          return e.createNodeMesh && e.createNodeMesh(t);
        });

        return n && e.push(n), void 0 !== r.camera && e.push(i.getDependency("camera", r.camera).then(function (t) {
          return i._getNodeRef(i.cameraCache, r.camera, t);
        })), i._invokeAll(function (e) {
          return e.createNodeAttachment && e.createNodeAttachment(t);
        }).forEach(function (t) {
          e.push(t);
        }), Promise.all(e);
      }().then(function (e) {
        var a;
        if (a = !0 === r.isBone ? new Nr() : e.length > 1 ? new Er() : 1 === e.length ? e[0] : new Vt(), a !== e[0]) for (var _t252 = 0, _n192 = e.length; _t252 < _n192; _t252++) {
          a.add(e[_t252]);
        }

        if (r.name && (a.userData.name = r.name, a.name = s), Fo(a, r), r.extensions && Po(n, a, r), void 0 !== r.matrix) {
          var _t253 = new yt();

          _t253.fromArray(r.matrix), a.applyMatrix4(_t253);
        } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);

        return i.associations.set(a, {
          type: "nodes",
          index: t
        }), a;
      });
    }
  }, {
    key: "loadScene",
    value: function loadScene(t) {
      var e = this.json,
          n = this.extensions,
          i = this.json.scenes[t],
          r = this,
          s = new Er();
      i.name && (s.name = r.createUniqueName(i.name)), Fo(s, i), i.extensions && Po(n, s, i);
      var a = i.nodes || [],
          o = [];

      for (var _t254 = 0, _n193 = a.length; _t254 < _n193; _t254++) {
        o.push(Ho(a[_t254], s, e, r));
      }

      return Promise.all(o).then(function () {
        return s;
      });
    }
  }]);

  return Oo;
}();

function Ho(t, e, n, i) {
  var r = n.nodes[t];
  return i.getDependency("node", t).then(function (t) {
    if (void 0 === r.skin) return t;
    var e;
    return i.getDependency("skin", r.skin).then(function (t) {
      e = t;
      var n = [];

      for (var _t255 = 0, _r117 = e.joints.length; _t255 < _r117; _t255++) {
        n.push(i.getDependency("node", e.joints[_t255]));
      }

      return Promise.all(n);
    }).then(function (n) {
      return t.traverse(function (t) {
        if (!t.isMesh) return;
        var i = [],
            r = [];

        for (var _t256 = 0, _s59 = n.length; _t256 < _s59; _t256++) {
          var _s60 = n[_t256];

          if (_s60) {
            i.push(_s60);

            var _n194 = new yt();

            void 0 !== e.inverseBindMatrices && _n194.fromArray(e.inverseBindMatrices.array, 16 * _t256), r.push(_n194);
          } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[_t256]);
        }

        t.bind(new kr(i, r), t.matrixWorld);
      }), t;
    });
  }).then(function (t) {
    e.add(t);
    var s = [];

    if (r.children) {
      var _e205 = r.children;

      for (var _r118 = 0, _a49 = _e205.length; _r118 < _a49; _r118++) {
        var _a50 = _e205[_r118];
        s.push(Ho(_a50, t, n, i));
      }
    }

    return Promise.all(s);
  });
}

function zo(t, e, n) {
  var i = e.attributes,
      r = [];

  function s(e, i) {
    return n.getDependency("accessor", e).then(function (e) {
      t.setAttribute(i, e);
    });
  }

  for (var _e206 in i) {
    var _n195 = Mo[_e206] || _e206.toLowerCase();

    _n195 in t.attributes || r.push(s(i[_e206], _n195));
  }

  if (void 0 !== e.indices && !t.index) {
    var _i174 = n.getDependency("accessor", e.indices).then(function (e) {
      t.setIndex(e);
    });

    r.push(_i174);
  }

  return Fo(t, e), function (t, e, n) {
    var i = e.attributes,
        r = new W();
    if (void 0 === i.POSITION) return;
    {
      var _t257 = n.json.accessors[i.POSITION],
          _e207 = _t257.min,
          _s61 = _t257.max;
      if (void 0 === _e207 || void 0 === _s61) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");

      if (r.set(new H(_e207[0], _e207[1], _e207[2]), new H(_s61[0], _s61[1], _s61[2])), _t257.normalized) {
        var _e208 = ko(bo[_t257.componentType]);

        r.min.multiplyScalar(_e208), r.max.multiplyScalar(_e208);
      }
    }
    var s = e.targets;

    if (void 0 !== s) {
      var _t258 = new H(),
          _e209 = new H();

      for (var _i175 = 0, _r119 = s.length; _i175 < _r119; _i175++) {
        var _r120 = s[_i175];

        if (void 0 !== _r120.POSITION) {
          var _i176 = n.json.accessors[_r120.POSITION],
              _s62 = _i176.min,
              _a51 = _i176.max;

          if (void 0 !== _s62 && void 0 !== _a51) {
            if (_e209.setX(Math.max(Math.abs(_s62[0]), Math.abs(_a51[0]))), _e209.setY(Math.max(Math.abs(_s62[1]), Math.abs(_a51[1]))), _e209.setZ(Math.max(Math.abs(_s62[2]), Math.abs(_a51[2]))), _i176.normalized) {
              var _t259 = ko(bo[_i176.componentType]);

              _e209.multiplyScalar(_t259);
            }

            _t258.max(_e209);
          } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }

      r.expandByVector(_t258);
    }

    t.boundingBox = r;
    var a = new ht();
    r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, t.boundingSphere = a;
  }(t, e, n), Promise.all(r).then(function () {
    return void 0 !== e.targets ? function (t, e, n) {
      var i = !1,
          r = !1;

      for (var _t260 = 0, _n196 = e.length; _t260 < _n196; _t260++) {
        var _n197 = e[_t260];
        if (void 0 !== _n197.POSITION && (i = !0), void 0 !== _n197.NORMAL && (r = !0), i && r) break;
      }

      if (!i && !r) return Promise.resolve(t);
      var s = [],
          a = [];

      for (var _o30 = 0, _l30 = e.length; _o30 < _l30; _o30++) {
        var _l31 = e[_o30];

        if (i) {
          var _e210 = void 0 !== _l31.POSITION ? n.getDependency("accessor", _l31.POSITION) : t.attributes.position;

          s.push(_e210);
        }

        if (r) {
          var _e211 = void 0 !== _l31.NORMAL ? n.getDependency("accessor", _l31.NORMAL) : t.attributes.normal;

          a.push(_e211);
        }
      }

      return Promise.all([Promise.all(s), Promise.all(a)]).then(function (e) {
        var n = e[0],
            s = e[1];
        return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = s), t.morphTargetsRelative = !0, t;
      });
    }(t, e.targets, n) : t;
  });
}

function Vo(t, e) {
  var n = t.getIndex();

  if (null === n) {
    var _e212 = [],
        _i177 = t.getAttribute("position");

    if (void 0 === _i177) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;

    for (var _t261 = 0; _t261 < _i177.count; _t261++) {
      _e212.push(_t261);
    }

    t.setIndex(_e212), n = t.getIndex();
  }

  var i = n.count - 2,
      r = [];
  if (2 === e) for (var _t262 = 1; _t262 <= i; _t262++) {
    r.push(n.getX(0)), r.push(n.getX(_t262)), r.push(n.getX(_t262 + 1));
  } else for (var _t263 = 0; _t263 < i; _t263++) {
    _t263 % 2 == 0 ? (r.push(n.getX(_t263)), r.push(n.getX(_t263 + 1)), r.push(n.getX(_t263 + 2))) : (r.push(n.getX(_t263 + 2)), r.push(n.getX(_t263 + 1)), r.push(n.getX(_t263)));
  }
  r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  var s = t.clone();
  return s.setIndex(r), s;
}

var Wo = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
var qo, jo, Yo, Jo, Xo, Ko, Zo, $o, tl;
(tl = qo || (qo = {}))[tl.NONE = 0] = "NONE", tl[tl.BASISLZ = 1] = "BASISLZ", tl[tl.ZSTD = 2] = "ZSTD", tl[tl.ZLIB = 3] = "ZLIB", function (t) {
  t[t.BASICFORMAT = 0] = "BASICFORMAT";
}(jo || (jo = {})), function (t) {
  t[t.UNSPECIFIED = 0] = "UNSPECIFIED", t[t.ETC1S = 163] = "ETC1S", t[t.UASTC = 166] = "UASTC";
}(Yo || (Yo = {})), function (t) {
  t[t.UNSPECIFIED = 0] = "UNSPECIFIED", t[t.SRGB = 1] = "SRGB";
}(Jo || (Jo = {})), function (t) {
  t[t.UNSPECIFIED = 0] = "UNSPECIFIED", t[t.LINEAR = 1] = "LINEAR", t[t.SRGB = 2] = "SRGB", t[t.ITU = 3] = "ITU", t[t.NTSC = 4] = "NTSC", t[t.SLOG = 5] = "SLOG", t[t.SLOG2 = 6] = "SLOG2";
}(Xo || (Xo = {})), function (t) {
  t[t.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t[t.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
}(Ko || (Ko = {})), function (t) {
  t[t.RGB = 0] = "RGB", t[t.RRR = 3] = "RRR", t[t.GGG = 4] = "GGG", t[t.AAA = 15] = "AAA";
}(Zo || (Zo = {})), function (t) {
  t[t.RGB = 0] = "RGB", t[t.RGBA = 3] = "RGBA", t[t.RRR = 4] = "RRR", t[t.RRRG = 5] = "RRRG";
}($o || ($o = {}));

var el = function el() {
  _classCallCheck(this, el);

  this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = qo.NONE, this.levels = [], this.dataFormatDescriptor = [{
    vendorId: 0,
    descriptorType: jo.BASICFORMAT,
    versionNumber: 2,
    descriptorBlockSize: 40,
    colorModel: Yo.UNSPECIFIED,
    colorPrimaries: Jo.SRGB,
    transferFunction: Jo.SRGB,
    flags: Ko.ALPHA_STRAIGHT,
    texelBlockDimension: {
      x: 4,
      y: 4,
      z: 1,
      w: 1
    },
    bytesPlane: [],
    samples: []
  }], this.keyValue = {}, this.globalData = null;
};

var nl = /*#__PURE__*/function () {
  function nl(t, e, n, i) {
    _classCallCheck(this, nl);

    this._dataView = new DataView(t.buffer, t.byteOffset + e, n), this._littleEndian = i, this._offset = 0;
  }

  _createClass(nl, [{
    key: "_nextUint8",
    value: function _nextUint8() {
      var t = this._dataView.getUint8(this._offset);

      return this._offset += 1, t;
    }
  }, {
    key: "_nextUint16",
    value: function _nextUint16() {
      var t = this._dataView.getUint16(this._offset, this._littleEndian);

      return this._offset += 2, t;
    }
  }, {
    key: "_nextUint32",
    value: function _nextUint32() {
      var t = this._dataView.getUint32(this._offset, this._littleEndian);

      return this._offset += 4, t;
    }
  }, {
    key: "_nextUint64",
    value: function _nextUint64() {
      var t = this._dataView.getUint32(this._offset, this._littleEndian) + Math.pow(2, 32) * this._dataView.getUint32(this._offset + 4, this._littleEndian);

      return this._offset += 8, t;
    }
  }, {
    key: "_skip",
    value: function _skip(t) {
      return this._offset += t, this;
    }
  }, {
    key: "_scan",
    value: function _scan(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this._offset;
      var i = 0;

      for (; this._dataView.getUint8(this._offset) !== e && i < t;) {
        i++, this._offset++;
      }

      return i < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i);
    }
  }]);

  return nl;
}();

function il(t) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t) : Buffer.from(t).toString("utf8");
}

var rl = new WeakMap();

var sl = /*#__PURE__*/function (_Ss9) {
  _inherits(sl, _Ss9);

  var _super73 = _createSuper(sl);

  function sl(t) {
    var _this58;

    _classCallCheck(this, sl);

    _this58 = _super73.call(this, t), _this58.transcoderPath = "", _this58.transcoderBinary = null, _this58.transcoderPending = null, _this58.workerLimit = 4, _this58.workerPool = [], _this58.workerNextTaskID = 1, _this58.workerSourceURL = "", _this58.workerConfig = null;
    return _this58;
  }

  _createClass(sl, [{
    key: "setTranscoderPath",
    value: function setTranscoderPath(t) {
      return this.transcoderPath = t, this;
    }
  }, {
    key: "setWorkerLimit",
    value: function setWorkerLimit(t) {
      return this.workerLimit = t, this;
    }
  }, {
    key: "detectSupport",
    value: function detectSupport(t) {
      return this.workerConfig = {
        astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: t.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      }, this;
    }
  }, {
    key: "load",
    value: function load(t, e, n, i) {
      var _this59 = this;

      var r = new Ts(this.manager);
      r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials);
      var s = new ss();
      return r.load(t, function (t) {
        if (rl.has(t)) {
          return rl.get(t).promise.then(e).catch(i);
        }

        _this59._createTexture([t]).then(function (t) {
          s.copy(t), s.needsUpdate = !0, e && e(s);
        }).catch(i);
      }, n, i), s;
    }
  }, {
    key: "parseInternalAsync",
    value: function parseInternalAsync(t) {
      var e = t.levels,
          n = new Set();

      for (var _t264 = 0; _t264 < e.length; _t264++) {
        n.add(e[_t264].data.buffer);
      }

      return this._createTexture(Array.from(n), _objectSpread(_objectSpread({}, t), {}, {
        lowLevel: !0
      }));
    }
  }, {
    key: "_createTexture",
    value: function _createTexture(t) {
      var _this60 = this;

      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var n, i;
      var r = e;
      var s = 0;

      for (var _e213 = 0; _e213 < t.length; _e213++) {
        s += t[_e213].byteLength;
      }

      var a = this._allocateWorker(s).then(function (e) {
        return n = e, i = _this60.workerNextTaskID++, new Promise(function (e, s) {
          n._callbacks[i] = {
            resolve: e,
            reject: s
          }, n.postMessage({
            type: "transcode",
            id: i,
            buffers: t,
            taskConfig: r
          }, t);
        });
      }).then(function (t) {
        var e = t.mipmaps,
            n = t.width,
            i = t.height,
            r = t.format,
            s = new ss(e, n, i, r, 1009);
        return s.minFilter = 1 === e.length ? 1006 : 1008, s.magFilter = 1006, s.generateMipmaps = !1, s.needsUpdate = !0, s;
      });

      return a.catch(function () {
        return !0;
      }).then(function () {
        n && i && (n._taskLoad -= s, delete n._callbacks[i]);
      }), rl.set(t[0], {
        promise: a
      }), a;
    }
  }, {
    key: "_initTranscoder",
    value: function _initTranscoder() {
      var _this61 = this;

      if (!this.transcoderPending) {
        var _t265 = new Ts(this.manager);

        _t265.setPath(this.transcoderPath), _t265.setWithCredentials(this.withCredentials);

        var _e214 = new Promise(function (e, n) {
          _t265.load("basis_transcoder.js", e, void 0, n);
        }),
            _n198 = new Ts(this.manager);

        _n198.setPath(this.transcoderPath), _n198.setResponseType("arraybuffer"), _n198.setWithCredentials(this.withCredentials);

        var _i178 = new Promise(function (t, e) {
          _n198.load("basis_transcoder.wasm", t, void 0, e);
        });

        this.transcoderPending = Promise.all([_e214, _i178]).then(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
              t = _ref3[0],
              e = _ref3[1];

          var n = sl.BasisWorker.toString(),
              i = ["/* constants */", "let _EngineFormat = " + JSON.stringify(sl.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(sl.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(sl.BasisFormat), "/* basis_transcoder.js */", t, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
          _this61.workerSourceURL = URL.createObjectURL(new Blob([i])), _this61.transcoderBinary = e;
        });
      }

      return this.transcoderPending;
    }
  }, {
    key: "_allocateWorker",
    value: function _allocateWorker(t) {
      var _this62 = this;

      return this._initTranscoder().then(function () {
        if (_this62.workerPool.length < _this62.workerLimit) {
          var _t266 = new Worker(_this62.workerSourceURL);

          _t266._callbacks = {}, _t266._taskLoad = 0, _t266.postMessage({
            type: "init",
            config: _this62.workerConfig,
            transcoderBinary: _this62.transcoderBinary
          }), _t266.onmessage = function (e) {
            var n = e.data;

            switch (n.type) {
              case "transcode":
                _t266._callbacks[n.id].resolve(n);

                break;

              case "error":
                _t266._callbacks[n.id].reject(n);

                break;

              default:
                console.error('THREE.BasisTextureLoader: Unexpected message, "' + n.type + '"');
            }
          }, _this62.workerPool.push(_t266);
        } else _this62.workerPool.sort(function (t, e) {
          return t._taskLoad > e._taskLoad ? -1 : 1;
        });

        var e = _this62.workerPool[_this62.workerPool.length - 1];
        return e._taskLoad += t, e;
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var _t267 = 0; _t267 < this.workerPool.length; _t267++) {
        this.workerPool[_t267].terminate();
      }

      return this.workerPool.length = 0, this;
    }
  }]);

  return sl;
}(Ss);

var al, ol, ll;
sl.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
}, sl.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
}, sl.EngineFormat = {
  RGBAFormat: 1023,
  RGBA_ASTC_4x4_Format: 37808,
  RGBA_BPTC_Format: 36492,
  RGBA_ETC2_EAC_Format: 37496,
  RGBA_PVRTC_4BPPV1_Format: 35842,
  RGBA_S3TC_DXT5_Format: 33779,
  RGB_ETC1_Format: 36196,
  RGB_ETC2_Format: 37492,
  RGB_PVRTC_4BPPV1_Format: 35840,
  RGB_S3TC_DXT1_Format: 33776
}, sl.BasisWorker = function () {
  var t, e, n;
  var i = _EngineFormat,
      r = _TranscoderFormat,
      s = _BasisFormat;

  onmessage = function onmessage(i) {
    var r = i.data;

    switch (r.type) {
      case "init":
        t = r.config, a = r.transcoderBinary, e = new Promise(function (t) {
          n = {
            wasmBinary: a,
            onRuntimeInitialized: t
          }, BASIS(n);
        }).then(function () {
          n.initializeBasis();
        });
        break;

      case "transcode":
        e.then(function () {
          try {
            var _ref4 = r.taskConfig.lowLevel ? function (t) {
              var e = t.basisFormat,
                  i = t.width,
                  r = t.height,
                  a = t.hasAlpha,
                  _c25 = c(e, i, r, a),
                  o = _c25.transcoderFormat,
                  l = _c25.engineFormat,
                  p = n.getBytesPerBlockOrPixel(o);

              h(n.isFormatSupported(o), "THREE.BasisTextureLoader: Unsupported format.");
              var g = [];

              if (e === s.ETC1S) {
                var _e216 = new n.LowLevelETC1SImageTranscoder(),
                    _t$globalData = t.globalData,
                    _i180 = _t$globalData.endpointCount,
                    _r121 = _t$globalData.endpointsData,
                    _s63 = _t$globalData.selectorCount,
                    _l33 = _t$globalData.selectorsData,
                    _c26 = _t$globalData.tablesData;

                try {
                  var _n199;

                  _n199 = _e216.decodePalettes(_i180, _r121, _s63, _l33), h(_n199, "THREE.BasisTextureLoader: decodePalettes() failed."), _n199 = _e216.decodeTables(_c26), h(_n199, "THREE.BasisTextureLoader: decodeTables() failed.");

                  for (var _i181 = 0; _i181 < t.levels.length; _i181++) {
                    var _r122 = t.levels[_i181],
                        _s64 = t.globalData.imageDescs[_i181],
                        _l34 = A(o, _r122.width, _r122.height),
                        _c27 = new Uint8Array(_l34);

                    _n199 = _e216.transcodeImage(o, _c27, _l34 / p, _r122.data, u(o, _r122.width), d(o, _r122.height), _r122.width, _r122.height, _r122.index, _s64.rgbSliceByteOffset, _s64.rgbSliceByteLength, _s64.alphaSliceByteOffset, _s64.alphaSliceByteLength, _s64.imageFlags, a, !1, 0, 0), h(_n199, "THREE.BasisTextureLoader: transcodeImage() failed for level " + _r122.index + "."), g.push({
                      data: _c27,
                      width: _r122.width,
                      height: _r122.height
                    });
                  }
                } finally {
                  _e216.delete();
                }
              } else for (var _e217 = 0; _e217 < t.levels.length; _e217++) {
                var _i182 = t.levels[_e217],
                    _r123 = A(o, _i182.width, _i182.height),
                    _s65 = new Uint8Array(_r123);

                h(n.transcodeUASTCImage(o, _s65, _r123 / p, _i182.data, u(o, _i182.width), d(o, _i182.height), _i182.width, _i182.height, _i182.index, 0, _i182.data.byteLength, 0, a, !1, 0, 0, -1, -1), "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + _i182.index + "."), g.push({
                  data: _s65,
                  width: _i182.width,
                  height: _i182.height
                });
              }

              return {
                width: i,
                height: r,
                hasAlpha: a,
                mipmaps: g,
                format: l
              };
            }(r.taskConfig) : function (t) {
              var e = new n.BasisFile(new Uint8Array(t)),
                  i = e.isUASTC() ? s.UASTC_4x4 : s.ETC1S,
                  r = e.getImageWidth(0, 0),
                  a = e.getImageHeight(0, 0),
                  o = e.getNumLevels(0),
                  l = e.getHasAlpha();

              function h() {
                e.close(), e.delete();
              }

              var _c28 = c(i, r, a, l),
                  u = _c28.transcoderFormat,
                  d = _c28.engineFormat;

              if (!r || !a || !o) throw h(), new Error("THREE.BasisTextureLoader:\tInvalid texture");
              if (!e.startTranscoding()) throw h(), new Error("THREE.BasisTextureLoader: .startTranscoding failed");
              var A = [];

              for (var _t269 = 0; _t269 < o; _t269++) {
                var _n200 = e.getImageWidth(0, _t269),
                    _i183 = e.getImageHeight(0, _t269),
                    _r124 = new Uint8Array(e.getImageTranscodedSizeInBytes(0, _t269, u));

                if (!e.transcodeImage(_r124, 0, _t269, u, 0, l)) throw h(), new Error("THREE.BasisTextureLoader: .transcodeImage failed.");
                A.push({
                  data: _r124,
                  width: _n200,
                  height: _i183
                });
              }

              return h(), {
                width: r,
                height: a,
                hasAlpha: l,
                mipmaps: A,
                format: d
              };
            }(r.buffers[0]),
                _t268 = _ref4.width,
                _e215 = _ref4.height,
                _i179 = _ref4.hasAlpha,
                _a52 = _ref4.mipmaps,
                _o31 = _ref4.format,
                _l32 = [];

            for (var _t270 = 0; _t270 < _a52.length; ++_t270) {
              _l32.push(_a52[_t270].data.buffer);
            }

            self.postMessage({
              type: "transcode",
              id: r.id,
              width: _t268,
              height: _e215,
              hasAlpha: _i179,
              mipmaps: _a52,
              format: _o31
            }, _l32);
          } catch (t) {
            console.error(t), self.postMessage({
              type: "error",
              id: r.id,
              error: t.message
            });
          }
        });
    }

    var a;
  };

  var a = [{
    if: "astcSupported",
    basisFormat: [s.UASTC_4x4],
    transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4],
    engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
    priorityETC1S: 1 / 0,
    priorityUASTC: 1,
    needsPowerOfTwo: !1
  }, {
    if: "bptcSupported",
    basisFormat: [s.ETC1S, s.UASTC_4x4],
    transcoderFormat: [r.BC7_M5, r.BC7_M5],
    engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: !1
  }, {
    if: "dxtSupported",
    basisFormat: [s.ETC1S, s.UASTC_4x4],
    transcoderFormat: [r.BC1, r.BC3],
    engineFormat: [i.RGB_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: !1
  }, {
    if: "etc2Supported",
    basisFormat: [s.ETC1S, s.UASTC_4x4],
    transcoderFormat: [r.ETC1, r.ETC2],
    engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: !1
  }, {
    if: "etc1Supported",
    basisFormat: [s.ETC1S, s.UASTC_4x4],
    transcoderFormat: [r.ETC1, r.ETC1],
    engineFormat: [i.RGB_ETC1_Format, i.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: !1
  }, {
    if: "pvrtcSupported",
    basisFormat: [s.ETC1S, s.UASTC_4x4],
    transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA],
    engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: !0
  }],
      o = a.sort(function (t, e) {
    return t.priorityETC1S - e.priorityETC1S;
  }),
      l = a.sort(function (t, e) {
    return t.priorityUASTC - e.priorityUASTC;
  });

  function c(e, n, a, c) {
    var h, u;
    var d = e === s.ETC1S ? o : l;

    for (var _i184 = 0; _i184 < d.length; _i184++) {
      var _r125 = d[_i184];
      if (t[_r125.if] && _r125.basisFormat.includes(e) && (!_r125.needsPowerOfTwo || p(n) && p(a))) return h = _r125.transcoderFormat[c ? 1 : 0], u = _r125.engineFormat[c ? 1 : 0], {
        transcoderFormat: h,
        engineFormat: u
      };
    }

    return console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32."), h = r.RGBA32, u = i.RGBAFormat, {
      transcoderFormat: h,
      engineFormat: u
    };
  }

  function h(t, e) {
    if (!t) throw new Error(e);
  }

  function u(t, e) {
    return Math.ceil(e / n.getFormatBlockWidth(t));
  }

  function d(t, e) {
    return Math.ceil(e / n.getFormatBlockHeight(t));
  }

  function A(t, e, i) {
    var s = n.getBytesPerBlockOrPixel(t);
    if (n.formatIsUncompressed(t)) return e * i * s;

    if (t === r.PVRTC1_4_RGB || t === r.PVRTC1_4_RGBA) {
      var _t271 = e + 3 & -4,
          _n201 = i + 3 & -4;

      return (Math.max(8, _t271) * Math.max(8, _n201) * 4 + 7) / 8;
    }

    return u(t, e) * d(t, i) * s;
  }

  function p(t) {
    return t <= 2 || 0 == (t & t - 1) && 0 !== t;
  }
};
var cl = {
  env: {
    emscripten_notify_memory_growth: function emscripten_notify_memory_growth(t) {
      ll = new Uint8Array(ol.exports.memory.buffer);
    }
  }
};

var hl = /*#__PURE__*/function () {
  function hl() {
    _classCallCheck(this, hl);
  }

  _createClass(hl, [{
    key: "init",
    value: function init() {
      return al || (al = fetch("data:application/wasm;base64," + ul).then(function (t) {
        return t.arrayBuffer();
      }).then(function (t) {
        return WebAssembly.instantiate(t, cl);
      }).then(function (t) {
        ol = t.instance, cl.env.emscripten_notify_memory_growth(0);
      })), al;
    }
  }, {
    key: "decode",
    value: function decode(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = t.byteLength,
          i = ol.exports.malloc(n);
      ll.set(t, i), e = e || Number(ol.exports.ZSTD_findDecompressedSize(i, n));
      var r = ol.exports.malloc(e),
          s = ol.exports.ZSTD_decompress(r, e, i, n),
          a = ll.slice(r, r + s);
      return ol.exports.free(i), ol.exports.free(r), a;
    }
  }]);

  return hl;
}();

var ul = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
var dl,
    Al,
    pl = {
  createLevels: function () {
    var _createLevels = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(t, e) {
      var n, i, r, s, a, o, l;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.t0 = t.supercompressionScheme === qo.ZSTD;

              if (!_context3.t0) {
                _context3.next = 4;
                break;
              }

              _context3.next = 4;
              return e.init();

            case 4:
              for (n = [], i = t.pixelWidth, r = t.pixelHeight, s = 0; s < t.levels.length; s++) {
                a = Math.max(1, Math.floor(i / Math.pow(2, s))), o = Math.max(1, Math.floor(r / Math.pow(2, s))), l = t.levels[s].levelData;
                t.supercompressionScheme === qo.ZSTD && (l = e.decode(l, t.levels[s].uncompressedByteLength)), n.push({
                  index: s,
                  width: a,
                  height: o,
                  data: l
                });
              }

              return _context3.abrupt("return", n);

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function createLevels(_x2, _x3) {
      return _createLevels.apply(this, arguments);
    }

    return createLevels;
  }(),
  getBasicDFD: function getBasicDFD(t) {
    return t.dataFormatDescriptor[0];
  },
  getAlpha: function getAlpha(t) {
    var e = this.getBasicDFD(t);
    return e.colorModel === Yo.UASTC ? (15 & e.samples[0].channelID) === $o.RGBA : 2 === e.samples.length && (15 & e.samples[1].channelID) === Zo.AAA;
  },
  getPremultiplyAlpha: function getPremultiplyAlpha(t) {
    return !!(this.getBasicDFD(t).flags & Ko.ALPHA_PREMULTIPLIED);
  }
};
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var gl = Symbol("retainerCount"),
    ml = Symbol("recentlyUsed"),
    fl = Symbol("evict"),
    vl = Symbol("evictionThreshold"),
    yl = Symbol("cache");

var El = /*#__PURE__*/function () {
  function El(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

    _classCallCheck(this, El);

    this[dl] = new Map(), this[Al] = [], this[yl] = t, this[vl] = e;
  }

  _createClass(El, [{
    key: "evictionThreshold",
    get: function get() {
      return this[vl];
    },
    set: function set(t) {
      this[vl] = t, this[fl]();
    }
  }, {
    key: "cache",
    get: function get() {
      return this[yl];
    }
  }, {
    key: "retainerCount",
    value: function retainerCount(t) {
      return this[gl].get(t) || 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this[gl].clear(), this[ml] = [];
    }
  }, {
    key: "retain",
    value: function retain(t) {
      this[gl].has(t) || this[gl].set(t, 0), this[gl].set(t, this[gl].get(t) + 1);
      var e = this[ml].indexOf(t);
      -1 !== e && this[ml].splice(e, 1), this[ml].unshift(t), this[fl]();
    }
  }, {
    key: "release",
    value: function release(t) {
      this[gl].has(t) && this[gl].set(t, Math.max(this[gl].get(t) - 1, 0)), this[fl]();
    }
  }, {
    key: (dl = gl, Al = ml, fl),
    value: function value() {
      if (!(this[ml].length < this[vl])) for (var _t272 = this[ml].length - 1; _t272 >= this[vl]; --_t272) {
        var _e218 = this[ml][_t272];
        0 === this[gl].get(_e218) && (this[yl].delete(_e218), this[ml].splice(_t272, 1));
      }
    }
  }]);

  return El;
}();
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var xl, wl;

var bl = new Map(),
    _l = new Map();

var Il;
var Cl = new ( /*#__PURE__*/function (_Ss10) {
  _inherits(_class3, _Ss10);

  var _super74 = _createSuper(_class3);

  function _class3(t) {
    var _this63;

    _classCallCheck(this, _class3);

    _this63 = _super74.call(this, t), _this63.decoderPath = "", _this63.decoderConfig = {}, _this63.decoderBinary = null, _this63.decoderPending = null, _this63.workerLimit = 4, _this63.workerPool = [], _this63.workerNextTaskID = 1, _this63.workerSourceURL = "", _this63.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, _this63.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
    return _this63;
  }

  _createClass(_class3, [{
    key: "setDecoderPath",
    value: function setDecoderPath(t) {
      return this.decoderPath = t, this;
    }
  }, {
    key: "setDecoderConfig",
    value: function setDecoderConfig(t) {
      return this.decoderConfig = t, this;
    }
  }, {
    key: "setWorkerLimit",
    value: function setWorkerLimit(t) {
      return this.workerLimit = t, this;
    }
  }, {
    key: "load",
    value: function load(t, e, n, i) {
      var _this64 = this;

      var r = new Ts(this.manager);
      r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(t, function (t) {
        var n = {
          attributeIDs: _this64.defaultAttributeIDs,
          attributeTypes: _this64.defaultAttributeTypes,
          useUniqueIDs: !1
        };

        _this64.decodeGeometry(t, n).then(e).catch(i);
      }, n, i);
    }
  }, {
    key: "decodeDracoFile",
    value: function decodeDracoFile(t, e, n, i) {
      var r = {
        attributeIDs: n || this.defaultAttributeIDs,
        attributeTypes: i || this.defaultAttributeTypes,
        useUniqueIDs: !!n
      };
      this.decodeGeometry(t, r).then(e);
    }
  }, {
    key: "decodeGeometry",
    value: function decodeGeometry(t, e) {
      var _this65 = this;

      for (var _t273 in e.attributeTypes) {
        var _n202 = e.attributeTypes[_t273];
        void 0 !== _n202.BYTES_PER_ELEMENT && (e.attributeTypes[_t273] = _n202.name);
      }

      var n = JSON.stringify(e);

      if (ja.has(t)) {
        var _e219 = ja.get(t);

        if (_e219.key === n) return _e219.promise;
        if (0 === t.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }

      var i;

      var r = this.workerNextTaskID++,
          s = t.byteLength,
          a = this._getWorker(r, s).then(function (n) {
        return i = n, new Promise(function (n, s) {
          i._callbacks[r] = {
            resolve: n,
            reject: s
          }, i.postMessage({
            type: "decode",
            id: r,
            taskConfig: e,
            buffer: t
          }, [t]);
        });
      }).then(function (t) {
        return _this65._createGeometry(t.geometry);
      });

      return a.catch(function () {
        return !0;
      }).then(function () {
        i && r && _this65._releaseTask(i, r);
      }), ja.set(t, {
        key: n,
        promise: a
      }), a;
    }
  }, {
    key: "_createGeometry",
    value: function _createGeometry(t) {
      var e = new Te();
      t.index && e.setIndex(new ve(t.index.array, 1));

      for (var _n203 = 0; _n203 < t.attributes.length; _n203++) {
        var _i185 = t.attributes[_n203],
            _r126 = _i185.name,
            _s66 = _i185.array,
            _a53 = _i185.itemSize;
        e.setAttribute(_r126, new ve(_s66, _a53));
      }

      return e;
    }
  }, {
    key: "_loadLibrary",
    value: function _loadLibrary(t, e) {
      var n = new Ts(this.manager);
      return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise(function (e, i) {
        n.load(t, e, void 0, i);
      });
    }
  }, {
    key: "preload",
    value: function preload() {
      return this._initDecoder(), this;
    }
  }, {
    key: "_initDecoder",
    value: function _initDecoder() {
      var _this66 = this;

      if (this.decoderPending) return this.decoderPending;
      var t = "object" != (typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) || "js" === this.decoderConfig.type,
          e = [];
      return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then(function (e) {
        var n = e[0];
        t || (_this66.decoderConfig.wasmBinary = e[1]);
        var i = Ya.toString(),
            r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
        _this66.workerSourceURL = URL.createObjectURL(new Blob([r]));
      }), this.decoderPending;
    }
  }, {
    key: "_getWorker",
    value: function _getWorker(t, e) {
      var _this67 = this;

      return this._initDecoder().then(function () {
        if (_this67.workerPool.length < _this67.workerLimit) {
          var _t274 = new Worker(_this67.workerSourceURL);

          _t274._callbacks = {}, _t274._taskCosts = {}, _t274._taskLoad = 0, _t274.postMessage({
            type: "init",
            decoderConfig: _this67.decoderConfig
          }), _t274.onmessage = function (e) {
            var n = e.data;

            switch (n.type) {
              case "decode":
                _t274._callbacks[n.id].resolve(n);

                break;

              case "error":
                _t274._callbacks[n.id].reject(n);

                break;

              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"');
            }
          }, _this67.workerPool.push(_t274);
        } else _this67.workerPool.sort(function (t, e) {
          return t._taskLoad > e._taskLoad ? -1 : 1;
        });

        var n = _this67.workerPool[_this67.workerPool.length - 1];
        return n._taskCosts[t] = e, n._taskLoad += e, n;
      });
    }
  }, {
    key: "_releaseTask",
    value: function _releaseTask(t, e) {
      t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e];
    }
  }, {
    key: "debug",
    value: function debug() {
      console.log("Task load: ", this.workerPool.map(function (t) {
        return t._taskLoad;
      }));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var _t275 = 0; _t275 < this.workerPool.length; ++_t275) {
        this.workerPool[_t275].terminate();
      }

      return this.workerPool.length = 0, this;
    }
  }]);

  return _class3;
}(Ss))();
var Ml;
var Sl = new ( /*#__PURE__*/function (_Ls) {
  _inherits(_class4, _Ls);

  var _super75 = _createSuper(_class4);

  function _class4(t) {
    var _this68;

    _classCallCheck(this, _class4);

    _this68 = _super75.call(this, t), _this68.basisLoader = new sl(t), _this68.zstd = new hl(), _this68.zstd.init(), "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    return _this68;
  }

  _createClass(_class4, [{
    key: "setTranscoderPath",
    value: function setTranscoderPath(t) {
      return this.basisLoader.setTranscoderPath(t), this;
    }
  }, {
    key: "setWorkerLimit",
    value: function setWorkerLimit(t) {
      return this.basisLoader.setWorkerLimit(t), this;
    }
  }, {
    key: "detectSupport",
    value: function detectSupport(t) {
      return this.basisLoader.detectSupport(t), this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      return this.basisLoader.dispose(), this;
    }
  }, {
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
          s = new ss();
      return new Promise(function (e, i) {
        new Ts(r.manager).setPath(r.path).setResponseType("arraybuffer").load(t, e, n, i);
      }).then(function (t) {
        r.parse(t, function (t) {
          s.copy(t), s.needsUpdate = !0, e && e(s);
        }, i);
      }).catch(i), s;
    }
  }, {
    key: "parse",
    value: function parse(t, e, n) {
      var i = this,
          r = function (t) {
        var e = new Uint8Array(t.buffer, t.byteOffset, Wo.length);
        if (e[0] !== Wo[0] || e[1] !== Wo[1] || e[2] !== Wo[2] || e[3] !== Wo[3] || e[4] !== Wo[4] || e[5] !== Wo[5] || e[6] !== Wo[6] || e[7] !== Wo[7] || e[8] !== Wo[8] || e[9] !== Wo[9] || e[10] !== Wo[10] || e[11] !== Wo[11]) throw new Error("Missing KTX 2.0 identifier.");
        var n = new el(),
            i = 17 * Uint32Array.BYTES_PER_ELEMENT,
            r = new nl(t, Wo.length, i, !0);
        n.vkFormat = r._nextUint32(), n.typeSize = r._nextUint32(), n.pixelWidth = r._nextUint32(), n.pixelHeight = r._nextUint32(), n.pixelDepth = r._nextUint32(), n.layerCount = r._nextUint32(), n.faceCount = r._nextUint32();

        var s = r._nextUint32();

        n.supercompressionScheme = r._nextUint32();

        var a = r._nextUint32(),
            o = r._nextUint32(),
            l = r._nextUint32(),
            c = r._nextUint32(),
            h = r._nextUint64(),
            u = r._nextUint64(),
            d = new nl(t, Wo.length + i, 3 * s * 8, !0);

        for (var _e220 = 0; _e220 < s; _e220++) {
          n.levels.push({
            levelData: new Uint8Array(t.buffer, t.byteOffset + d._nextUint64(), d._nextUint64()),
            uncompressedByteLength: d._nextUint64()
          });
        }

        var A = new nl(t, a, o, !0),
            p = {
          vendorId: A._skip(4)._nextUint16(),
          descriptorType: A._nextUint16(),
          versionNumber: A._nextUint16(),
          descriptorBlockSize: A._nextUint16(),
          colorModel: A._nextUint8(),
          colorPrimaries: A._nextUint8(),
          transferFunction: A._nextUint8(),
          flags: A._nextUint8(),
          texelBlockDimension: {
            x: A._nextUint8() + 1,
            y: A._nextUint8() + 1,
            z: A._nextUint8() + 1,
            w: A._nextUint8() + 1
          },
          bytesPlane: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()],
          samples: []
        },
            g = (p.descriptorBlockSize / 4 - 6) / 4;

        for (var _t276 = 0; _t276 < g; _t276++) {
          p.samples[_t276] = {
            bitOffset: A._nextUint16(),
            bitLength: A._nextUint8(),
            channelID: A._nextUint8(),
            samplePosition: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()],
            sampleLower: A._nextUint32(),
            sampleUpper: A._nextUint32()
          };
        }

        n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(p);
        var m = new nl(t, l, c, !0);

        for (; m._offset < c;) {
          var _t277 = m._nextUint32(),
              _e221 = m._scan(_t277),
              _i186 = il(_e221),
              _r127 = m._scan(_t277 - _e221.byteLength);

          n.keyValue[_i186] = _i186.match(/^ktx/i) ? il(_r127) : _r127, m._offset % 4 && m._skip(4 - m._offset % 4);
        }

        if (u <= 0) return n;

        var f = new nl(t, h, u, !0),
            v = f._nextUint16(),
            y = f._nextUint16(),
            E = f._nextUint32(),
            x = f._nextUint32(),
            w = f._nextUint32(),
            b = f._nextUint32(),
            _ = [];

        for (var _t278 = 0; _t278 < s; _t278++) {
          _.push({
            imageFlags: f._nextUint32(),
            rgbSliceByteOffset: f._nextUint32(),
            rgbSliceByteLength: f._nextUint32(),
            alphaSliceByteOffset: f._nextUint32(),
            alphaSliceByteLength: f._nextUint32()
          });
        }

        var I = h + f._offset,
            C = I + E,
            M = C + x,
            S = M + w,
            B = new Uint8Array(t.buffer, t.byteOffset + I, E),
            T = new Uint8Array(t.buffer, t.byteOffset + C, x),
            L = new Uint8Array(t.buffer, t.byteOffset + M, w),
            R = new Uint8Array(t.buffer, t.byteOffset + S, b);
        return n.globalData = {
          endpointCount: v,
          selectorCount: y,
          imageDescs: _,
          endpointsData: B,
          selectorsData: T,
          tablesData: L,
          extendedData: R
        }, n;
      }(new Uint8Array(t));

      if (r.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Only 2D textures are currently supported.");
      if (r.layerCount > 1) throw new Error("THREE.KTX2Loader: Array textures are not currently supported.");
      if (r.faceCount > 1) throw new Error("THREE.KTX2Loader: Cube textures are not currently supported.");
      var s = pl.getBasicDFD(r);
      return pl.createLevels(r, this.zstd).then(function (t) {
        var e = s.colorModel === Yo.UASTC ? sl.BasisFormat.UASTC_4x4 : sl.BasisFormat.ETC1S,
            n = {
          levels: t,
          width: r.pixelWidth,
          height: r.pixelHeight,
          basisFormat: e,
          hasAlpha: pl.getAlpha(r)
        };
        return e === sl.BasisFormat.ETC1S && (n.globalData = r.globalData), i.basisLoader.parseInternalAsync(n);
      }).then(function (t) {
        t.encoding = s.transferFunction === Xo.SRGB ? 3001 : 3e3, t.premultiplyAlpha = pl.getPremultiplyAlpha(r), e(t);
      }).catch(n), this;
    }
  }]);

  return _class4;
}(Ls))(),
    Bl = Symbol("loader"),
    Tl = Symbol("evictionPolicy"),
    Ll = Symbol("GLTFInstance");

var Rl = /*#__PURE__*/function (_y10) {
  _inherits(Rl, _y10);

  var _super76 = _createSuper(Rl);

  function Rl(t) {
    var _this69;

    _classCallCheck(this, Rl);

    _this69 = _super76.call(this), _this69[wl] = new Ja(), _this69[Ll] = t, _this69[Bl].setDRACOLoader(Cl), _this69[Bl].setKTX2Loader(Sl);
    return _this69;
  }

  _createClass(Rl, [{
    key: (xl = Tl, wl = Bl, Tl),
    get: function get() {
      return this.constructor[Tl];
    }
  }, {
    key: "preload",
    value: function () {
      var _preload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(t, e) {
        var n,
            _e222,
            _i187,
            _r128,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                n = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : function () {};

                if (this.dispatchEvent({
                  type: "preload",
                  element: e,
                  src: t
                }), !bl.has(t)) {
                  _e222 = function (t, e) {
                    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

                    var i = function i(t) {
                      var e = t.loaded / t.total;
                      n(Math.max(0, Math.min(1, isFinite(e) ? e : 1)));
                    };

                    return new Promise(function (n, r) {
                      e.load(t, n, i, r);
                    });
                  }(t, this[Bl], function (t) {
                    n(.8 * t);
                  }), _i187 = this[Ll], _r128 = _e222.then(function (t) {
                    return _i187.prepare(t);
                  }).then(function (t) {
                    return n(.9), new _i187(t);
                  });
                  bl.set(t, _r128);
                }

                _context4.next = 4;
                return bl.get(t);

              case 4:
                _l.set(t, !0);

                n && n(1);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function preload(_x4, _x5) {
        return _preload.apply(this, arguments);
      }

      return preload;
    }()
  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(t, e) {
        var _this70 = this;

        var n,
            i,
            r,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                n = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : function () {};
                _context5.next = 3;
                return this.preload(t, e, n);

              case 3:
                _context5.next = 5;
                return bl.get(t);

              case 5:
                i = _context5.sent;
                _context5.next = 8;
                return i.clone();

              case 8:
                r = _context5.sent;
                return _context5.abrupt("return", (this[Tl].retain(t), r.dispose = function () {
                  var e = r.dispose;
                  var n = !1;
                  return function () {
                    n || (n = !0, e.apply(r), _this70[Tl].release(t));
                  };
                }(), r));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function load(_x6, _x7) {
        return _load.apply(this, arguments);
      }

      return load;
    }()
  }], [{
    key: "setDRACODecoderLocation",
    value: function setDRACODecoderLocation(t) {
      Il = t, Cl.setDecoderPath(t);
    }
  }, {
    key: "getDRACODecoderLocation",
    value: function getDRACODecoderLocation() {
      return Il;
    }
  }, {
    key: "setKTX2TranscoderLocation",
    value: function setKTX2TranscoderLocation(t) {
      Ml = t, Sl.setTranscoderPath(t);
    }
  }, {
    key: "getKTX2TranscoderLocation",
    value: function getKTX2TranscoderLocation() {
      return Ml;
    }
  }, {
    key: "initializeKTX2Loader",
    value: function initializeKTX2Loader(t) {
      Sl.detectSupport(t);
    }
  }, {
    key: "cache",
    get: function get() {
      return bl;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      var _this71 = this;

      bl.forEach(function (t, e) {
        _this71.delete(e);
      }), this[Tl].reset();
    }
  }, {
    key: "has",
    value: function has(t) {
      return bl.has(t);
    }
  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(t) {
        var e;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this.has(t)) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                e = bl.get(t);
                _l.delete(t), bl.delete(t);
                _context6.next = 6;
                return e;

              case 6:
                _context6.sent.dispose();

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _delete(_x8) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
  }, {
    key: "hasFinishedLoading",
    value: function hasFinishedLoading(t) {
      return !!_l.get(t);
    }
  }]);

  return Rl;
}(y);

Rl[xl] = new El(Rl);

var Dl = /*#__PURE__*/function (_Vt10) {
  _inherits(Dl, _Vt10);

  var _super77 = _createSuper(Dl);

  function Dl(t) {
    var _this72;

    _classCallCheck(this, Dl);

    _this72 = _super77.call(this), _this72.element = t || document.createElement("div"), _this72.element.style.position = "absolute", _this72.addEventListener("removed", function () {
      this.traverse(function (t) {
        t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element);
      });
    });
    return _this72;
  }

  _createClass(Dl, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Dl.prototype), "copy", this).call(this, t, e), this.element = t.element.cloneNode(!0), this;
    }
  }]);

  return Dl;
}(Vt);

Dl.prototype.isCSS2DObject = !0;
var Ql = new H(),
    Pl = new yt(),
    Fl = new yt(),
    Nl = new H(),
    Ul = new H();

var Gl = function Gl() {
  _classCallCheck(this, Gl);

  var t = this;
  var e, n, i, r;
  var s = {
    objects: new WeakMap()
  },
      a = document.createElement("div");

  function o(e, n, c) {
    if (e.isCSS2DObject) {
      e.onBeforeRender(t, n, c), Ql.setFromMatrixPosition(e.matrixWorld), Ql.applyMatrix4(Fl);
      var _o32 = e.element;
      /apple/i.test(navigator.vendor) ? _o32.style.transform = "translate(-50%,-50%) translate(" + Math.round(Ql.x * i + i) + "px," + Math.round(-Ql.y * r + r) + "px)" : _o32.style.transform = "translate(-50%,-50%) translate(" + (Ql.x * i + i) + "px," + (-Ql.y * r + r) + "px)", _o32.style.display = e.visible && Ql.z >= -1 && Ql.z <= 1 ? "" : "none";
      var _h13 = {
        distanceToCameraSquared: l(c, e)
      };
      s.objects.set(e, _h13), _o32.parentNode !== a && a.appendChild(_o32), e.onAfterRender(t, n, c);
    }

    for (var _t279 = 0, _i188 = e.children.length; _t279 < _i188; _t279++) {
      o(e.children[_t279], n, c);
    }
  }

  function l(t, e) {
    return Nl.setFromMatrixPosition(t.matrixWorld), Ul.setFromMatrixPosition(e.matrixWorld), Nl.distanceToSquared(Ul);
  }

  a.style.overflow = "hidden", this.domElement = a, this.getSize = function () {
    return {
      width: e,
      height: n
    };
  }, this.render = function (t, e) {
    !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Pl.copy(e.matrixWorldInverse), Fl.multiplyMatrices(e.projectionMatrix, Pl), o(t, t, e), function (t) {
      var e = function (t) {
        var e = [];
        return t.traverse(function (t) {
          t.isCSS2DObject && e.push(t);
        }), e;
      }(t).sort(function (t, e) {
        return s.objects.get(t).distanceToCameraSquared - s.objects.get(e).distanceToCameraSquared;
      }),
          n = e.length;

      for (var _t280 = 0, _i189 = e.length; _t280 < _i189; _t280++) {
        e[_t280].element.style.zIndex = n - _t280;
      }
    }(t);
  }, this.setSize = function (t, s) {
    e = t, n = s, i = e / 2, r = n / 2, a.style.width = t + "px", a.style.height = s + "px";
  };
};
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var kl = function kl(t) {
  return t && "null" !== t ? Hl(t) : null;
},
    Ol = function Ol() {
  if (u) return;
  var t = [];
  throw o || t.push("WebXR Device API"), l || t.push("WebXR Hit Test API"), new Error("The following APIs are required for AR, but are missing in this browser: ".concat(t.join(", ")));
},
    Hl = function Hl(t) {
  return new URL(t, window.location.toString()).toString();
},
    zl = function zl(t, e) {
  var n = null;
  return function () {
    for (var _len = arguments.length, i = new Array(_len), _key = 0; _key < _len; _key++) {
      i[_key] = arguments[_key];
    }

    null != n && self.clearTimeout(n), n = self.setTimeout(function () {
      n = null, t.apply(void 0, i);
    }, e);
  };
},
    Vl = function Vl(t, e, n) {
  return Math.max(e, Math.min(n, t));
},
    Wl = function () {
  var t = function () {
    var t = null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [];

    var _iterator3 = _createForOfIteratorHelper(t),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _e223 = _step3.value;
        if ("viewport" === _e223.name) return !0;
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return !1;
  }();

  return t || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), function () {
    return t ? window.devicePixelRatio : 1;
  };
}(),
    ql = function () {
  var t = new RegExp("[?&]model-viewer-debug-mode(&|$)");
  return function () {
    return self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(t);
  };
}();

var jl = /*#__PURE__*/function () {
  function jl() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

    _classCallCheck(this, jl);

    this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(t);
  }

  _createClass(jl, [{
    key: "setDecayTime",
    value: function setDecayTime(t) {
      this.naturalFrequency = 1 / Math.max(.001, t);
    }
  }, {
    key: "update",
    value: function update(t, e, n, i) {
      var r = 2e-4 * this.naturalFrequency;
      if (null == t || 0 === i) return e;
      if (t === e && 0 === this.velocity) return e;
      if (n < 0) return t;
      var s = t - e,
          a = this.velocity + this.naturalFrequency * s,
          o = s + n * a,
          l = Math.exp(-this.naturalFrequency * n),
          c = (a - this.naturalFrequency * o) * l,
          h = -this.naturalFrequency * (c + a * l);
      return Math.abs(c) < r * Math.abs(i) && h * s >= 0 ? (this.velocity = 0, e) : (this.velocity = c, e + o * l);
    }
  }]);

  return jl;
}();
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Yl = function Yl(t, e) {
  return {
    type: "number",
    number: t,
    unit: e
  };
},
    Jl = function () {
  var t = {};
  return function (e) {
    var n = e;
    if (n in t) return t[n];
    var i = [];
    var r = 0;

    for (; e;) {
      if (++r > 1e3) {
        e = "";
        break;
      }

      var _t281 = Xl(e),
          _n204 = _t281.nodes[0];

      if (null == _n204 || 0 === _n204.terms.length) break;
      i.push(_n204), e = _t281.remainingInput;
    }

    return t[n] = i;
  };
}(),
    Xl = function () {
  var t = /^(\-\-|[a-z\u0240-\uffff])/i,
      e = /^([\*\+\/]|[\-]\s)/i,
      n = /^[\),]/;
  return function (i) {
    var r = [];

    for (; i.length && (i = i.trim(), !n.test(i));) {
      if ("(" === i[0]) {
        var _tc = tc(i),
            _t282 = _tc.nodes,
            _e224 = _tc.remainingInput;

        i = _e224, r.push({
          type: "function",
          name: {
            type: "ident",
            value: "calc"
          },
          arguments: _t282
        });
      } else if (t.test(i)) {
        var _t283 = Kl(i),
            _e225 = _t283.nodes[0];

        if ("(" === (i = _t283.remainingInput)[0]) {
          var _tc2 = tc(i),
              _t284 = _tc2.nodes,
              _n205 = _tc2.remainingInput;

          r.push({
            type: "function",
            name: _e225,
            arguments: _t284
          }), i = _n205;
        } else r.push(_e225);
      } else if (e.test(i)) r.push({
        type: "operator",
        value: i[0]
      }), i = i.slice(1);else {
        var _ref5 = "#" === i[0] ? $l(i) : Zl(i),
            _t285 = _ref5.nodes,
            _e226 = _ref5.remainingInput;

        if (0 === _t285.length) break;
        r.push(_t285[0]), i = _e226;
      }
    }

    return {
      nodes: [{
        type: "expression",
        terms: r
      }],
      remainingInput: i
    };
  };
}(),
    Kl = function () {
  var t = /[^a-z^0-9^_^\-^\u0240-\uffff]/i;
  return function (e) {
    var n = e.match(t);
    return {
      nodes: [{
        type: "ident",
        value: null == n ? e : e.substr(0, n.index)
      }],
      remainingInput: null == n ? "" : e.substr(n.index)
    };
  };
}(),
    Zl = function () {
  var t = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,
      e = /^[a-z%]+/i,
      n = /^(m|mm|cm|rad|deg|[%])$/;
  return function (i) {
    var r = i.match(t),
        s = null == r ? "0" : r[0],
        a = (i = null == s ? i : i.slice(s.length)).match(e);
    var o = null != a && "" !== a[0] ? a[0] : null;
    var l = null == a ? i : i.slice(o.length);
    return null == o || n.test(o) || (o = null), {
      nodes: [{
        type: "number",
        number: parseFloat(s) || 0,
        unit: o
      }],
      remainingInput: l
    };
  };
}(),
    $l = function () {
  var t = /^[a-f0-9]*/i;
  return function (e) {
    var n = (e = e.slice(1).trim()).match(t);
    return {
      nodes: null == n ? [] : [{
        type: "hex",
        value: n[0]
      }],
      remainingInput: null == n ? e : e.slice(n[0].length)
    };
  };
}(),
    tc = function tc(t) {
  var e = [];

  for (t = t.slice(1).trim(); t.length;) {
    var _n206 = Xl(t);

    if (e.push(_n206.nodes[0]), "," === (t = _n206.remainingInput.trim())[0]) t = t.slice(1).trim();else if (")" === t[0]) {
      t = t.slice(1);
      break;
    }
  }

  return {
    nodes: e,
    remainingInput: t
  };
},
    ec = Symbol("visitedTypes");

var nc = /*#__PURE__*/function () {
  function nc(t) {
    _classCallCheck(this, nc);

    this[ec] = t;
  }

  _createClass(nc, [{
    key: "walk",
    value: function walk(t, e) {
      var n = t.slice();

      for (; n.length;) {
        var _t286 = n.shift();

        switch (this[ec].indexOf(_t286.type) > -1 && e(_t286), _t286.type) {
          case "expression":
            n.unshift.apply(n, _toConsumableArray(_t286.terms));
            break;

          case "function":
            n.unshift.apply(n, [_t286.name].concat(_toConsumableArray(_t286.arguments)));
        }
      }
    }
  }]);

  return nc;
}();

var ic = Object.freeze({
  type: "number",
  number: 0,
  unit: null
}),
    rc = function rc(t) {
  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var n = t.number,
      i = t.unit;

  if (isFinite(n)) {
    if ("rad" === t.unit || null == t.unit) return t;
  } else n = e, i = "rad";

  return {
    type: "number",
    number: ("deg" === i && null != n ? n : 0) * Math.PI / 180,
    unit: "rad"
  };
},
    sc = function sc(t) {
  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var n,
      i = t.number,
      r = t.unit;

  if (isFinite(i)) {
    if ("m" === t.unit) return t;
  } else i = e, r = "m";

  switch (r) {
    default:
      n = 1;
      break;

    case "cm":
      n = .01;
      break;

    case "mm":
      n = .001;
  }

  return {
    type: "number",
    number: n * i,
    unit: "m"
  };
},
    ac = function () {
  var t = function t(_t287) {
    return _t287;
  },
      e = {
    rad: t,
    deg: rc,
    m: t,
    mm: sc,
    cm: sc
  };

  return function (t) {
    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ic;
    var i = t.number,
        r = t.unit;
    if (isFinite(i) || (i = n.number, r = n.unit), null == r) return t;
    var s = e[r];
    return null == s ? n : s(t);
  };
}();
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var oc = /*#__PURE__*/function (_Dl) {
  _inherits(oc, _Dl);

  var _super78 = _createSuper(oc);

  function oc(t) {
    var _this73;

    _classCallCheck(this, oc);

    _this73 = _super78.call(this, document.createElement("div")), _this73.normal = new H(0, 1, 0), _this73.initialized = !1, _this73.referenceCount = 1, _this73.pivot = document.createElement("div"), _this73.slot = document.createElement("slot"), _this73.element.classList.add("annotation-wrapper"), _this73.slot.name = t.name, _this73.element.appendChild(_this73.pivot), _this73.pivot.appendChild(_this73.slot), _this73.updatePosition(t.position), _this73.updateNormal(t.normal);
    return _this73;
  }

  _createClass(oc, [{
    key: "facingCamera",
    get: function get() {
      return !this.element.classList.contains("hide");
    }
  }, {
    key: "show",
    value: function show() {
      this.facingCamera && this.initialized || this.updateVisibility(!0);
    }
  }, {
    key: "hide",
    value: function hide() {
      !this.facingCamera && this.initialized || this.updateVisibility(!1);
    }
  }, {
    key: "increment",
    value: function increment() {
      this.referenceCount++;
    }
  }, {
    key: "decrement",
    value: function decrement() {
      return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount;
    }
  }, {
    key: "updatePosition",
    value: function updatePosition(t) {
      if (null == t) return;
      var e = Jl(t)[0].terms;

      for (var _t288 = 0; _t288 < 3; ++_t288) {
        this.position.setComponent(_t288, ac(e[_t288]).number);
      }

      this.updateMatrixWorld();
    }
  }, {
    key: "updateNormal",
    value: function updateNormal(t) {
      if (null == t) return;
      var e = Jl(t)[0].terms;

      for (var _t289 = 0; _t289 < 3; ++_t289) {
        this.normal.setComponent(_t289, ac(e[_t289]).number);
      }
    }
  }, {
    key: "orient",
    value: function orient(t) {
      this.pivot.style.transform = "rotate(".concat(t, "rad)");
    }
  }, {
    key: "updateVisibility",
    value: function updateVisibility(t) {
      t ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach(function (e) {
        if (e.nodeType !== Node.ELEMENT_NODE) return;
        var n = e,
            i = n.dataset.visibilityAttribute;

        if (null != i) {
          var _e227 = "data-".concat(i);

          t ? n.setAttribute(_e227, "") : n.removeAttribute(_e227);
        }

        n.dispatchEvent(new CustomEvent("hotspot-visibility", {
          detail: {
            visible: t
          }
        }));
      }), this.initialized = !0;
    }
  }]);

  return oc;
}(Dl);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var lc = function lc(t, e, n) {
  var i = n;
  var r = new H();
  return t.traverse(function (t) {
    var n, s;
    t.updateWorldMatrix(!1, !1);
    var a = t.geometry;
    if (void 0 !== a) if (a.isGeometry) {
      var _o33 = a.vertices;

      for (n = 0, s = _o33.length; n < s; n++) {
        r.copy(_o33[n]), r.applyMatrix4(t.matrixWorld), i = e(i, r);
      }
    } else if (a.isBufferGeometry) {
      var _o34 = a.attributes.position;
      if (void 0 !== _o34) for (n = 0, s = _o34.count; n < s; n++) {
        r.fromBufferAttribute(_o34, n).applyMatrix4(t.matrixWorld), i = e(i, r);
      }
    }
  }), i;
};
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var cc = /*#__PURE__*/function (_Xs) {
  _inherits(cc, _Xs);

  var _super79 = _createSuper(cc);

  function cc(t, e, n) {
    var _this74;

    _classCallCheck(this, cc);

    _this74 = _super79.call(this), _this74.shadowMaterial = new os(), _this74.boundingBox = new W(), _this74.size = new H(), _this74.shadowScale = 1, _this74.isAnimated = !1, _this74.side = "bottom", _this74.needsUpdate = !1, _this74.intensity = 0, _this74.castShadow = !0, _this74.frustumCulled = !1, _this74.floor = new Ye(new An(), _this74.shadowMaterial), _this74.floor.rotateX(-Math.PI / 2), _this74.floor.receiveShadow = !0, _this74.floor.castShadow = !1, _this74.floor.frustumCulled = !1, _this74.add(_this74.floor), t.target.add(_assertThisInitialized(_this74)), _this74.target = t.target, _this74.setScene(t, e, n);
    return _this74;
  }

  _createClass(cc, [{
    key: "setScene",
    value: function setScene(t, e, n) {
      if (this.side = n, this.isAnimated = t.animationNames.length > 0, this.boundingBox.copy(t.boundingBox), this.size.copy(t.size), "back" === this.side) {
        var _ref6, _ref7, _ref8;

        var _this$boundingBox = this.boundingBox,
            _t290 = _this$boundingBox.min,
            _e228 = _this$boundingBox.max;
        (_ref6 = [_t290.z, _t290.y], _t290.y = _ref6[0], _t290.z = _ref6[1], _ref6), (_ref7 = [_e228.z, _e228.y], _e228.y = _ref7[0], _e228.z = _ref7[1], _ref7), (_ref8 = [this.size.z, this.size.y], this.size.y = _ref8[0], this.size.z = _ref8[1], _ref8), this.rotation.x = Math.PI / 2, this.rotation.y = Math.PI;
      }

      var i = this.boundingBox,
          r = this.size;

      if (this.isAnimated) {
        var _t291 = 2 * Math.max(r.x, r.y, r.z);

        r.y = _t291, i.expandByVector(r.subScalar(_t291).multiplyScalar(-.5)), i.max.y = i.min.y + _t291, r.set(_t291, _t291, _t291);
      }

      i.getCenter(this.floor.position);
      var s = i.max.y + .002 * r.y;
      "bottom" === n ? (this.position.y = s, this.shadow.camera.up.set(0, 0, 1)) : (this.position.y = 0, this.position.z = s, this.shadow.camera.up.set(0, 1, 0)), this.setSoftness(e);
    }
  }, {
    key: "setSoftness",
    value: function setSoftness(t) {
      var e = Math.pow(2, 9 - 3 * t);
      this.setMapSize(e);
    }
  }, {
    key: "setMapSize",
    value: function setMapSize(t) {
      var _this$shadow = this.shadow,
          e = _this$shadow.camera,
          n = _this$shadow.mapSize,
          i = _this$shadow.map,
          r = this.size,
          s = this.boundingBox;
      null != i && (i.dispose(), this.shadow.map = null), this.isAnimated && (t *= 2);
      var a = Math.floor(r.x > r.z ? t : t * r.x / r.z),
          o = Math.floor(r.x > r.z ? t * r.z / r.x : t);
      n.set(a, o);
      var l = 2.5 * r.x / a,
          c = 2.5 * r.z / o;
      e.left = -s.max.x - l, e.right = -s.min.x + l, e.bottom = s.min.z - c, e.top = s.max.z + c, this.setScaleAndOffset(this.shadowScale, 0), this.floor.scale.set(r.x + 2 * l, r.z + 2 * c, 1), this.needsUpdate = !0;
    }
  }, {
    key: "setIntensity",
    value: function setIntensity(t) {
      this.shadowMaterial.opacity = t, t > 0 ? (this.visible = !0, this.floor.visible = !0) : (this.visible = !1, this.floor.visible = !1);
    }
  }, {
    key: "getIntensity",
    value: function getIntensity() {
      return this.shadowMaterial.opacity;
    }
  }, {
    key: "setRotation",
    value: function setRotation(t) {
      "bottom" === this.side ? (this.shadow.camera.up.set(Math.sin(t), 0, Math.cos(t)), this.shadow.updateMatrices(this)) : this.shadow.updateMatrices(this);
    }
  }, {
    key: "setScaleAndOffset",
    value: function setScaleAndOffset(t, e) {
      var n = this.size.y,
          i = this.shadow.camera;
      this.shadowScale = t, i.near = 0, i.far = n - e / t, i.updateProjectionMatrix(), i.scale.setScalar(t);
      var r = .002 * n;
      this.floor.position.y = 2 * r - i.far;
    }
  }]);

  return cc;
}(Xs);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var hc = 22.5 * Math.PI / 180,
    uc = Math.sin(hc),
    dc = Math.tan(hc),
    Ac = new H(),
    pc = new H(),
    gc = new H(),
    mc = new ( /*#__PURE__*/function () {
  function _class5(t, e) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1 / 0;

    _classCallCheck(this, _class5);

    this.ray = new vt(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new Tt(), this.params = {
      Mesh: {},
      Line: {
        threshold: 1
      },
      LOD: {},
      Points: {
        threshold: 1
      },
      Sprite: {}
    };
  }

  _createClass(_class5, [{
    key: "set",
    value: function set(t, e) {
      this.ray.set(t, e);
    }
  }, {
    key: "setFromCamera",
    value: function setFromCamera(t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
    }
  }, {
    key: "intersectObject",
    value: function intersectObject(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return da(t, this, n, e), n.sort(ua), n;
    }
  }, {
    key: "intersectObjects",
    value: function intersectObjects(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      for (var _i190 = 0, _r129 = t.length; _i190 < _r129; _i190++) {
        da(t[_i190], this, n, e);
      }

      return n.sort(ua), n;
    }
  }]);

  return _class5;
}())(),
    fc = new H();

var vc = /*#__PURE__*/function (_Mr) {
  _inherits(vc, _Mr);

  var _super80 = _createSuper(vc);

  function vc(_ref9) {
    var _this75;

    var t = _ref9.canvas,
        e = _ref9.element,
        n = _ref9.width,
        i = _ref9.height;

    _classCallCheck(this, vc);

    _this75 = _super80.call(this), _this75.context = null, _this75.annotationRenderer = new Gl(), _this75.width = 1, _this75.height = 1, _this75.aspect = 1, _this75.isDirty = !1, _this75.renderCount = 0, _this75.externalRenderer = null, _this75.camera = new nn(45, 1, .1, 100), _this75.url = null, _this75.target = new Vt(), _this75.modelContainer = new Vt(), _this75.animationNames = [], _this75.boundingBox = new W(), _this75.size = new H(), _this75.idealCameraDistance = 0, _this75.fieldOfViewAspect = 0, _this75.framedFieldOfView = 45, _this75.shadow = null, _this75.shadowIntensity = 0, _this75.shadowSoftness = 1, _this75.exposure = 1, _this75.canScale = !0, _this75.tightBounds = !1, _this75.goalTarget = new H(), _this75.targetDamperX = new jl(), _this75.targetDamperY = new jl(), _this75.targetDamperZ = new jl(), _this75._currentGLTF = null, _this75.cancelPendingSourceChange = null, _this75.animationsByName = new Map(), _this75.currentAnimationAction = null, _this75.name = "ModelScene", _this75.element = e, _this75.canvas = t, _this75.camera = new nn(45, 1, .1, 100), _this75.camera.name = "MainCamera", _this75.add(_this75.target), _this75.setSize(n, i), _this75.target.name = "Target", _this75.modelContainer.name = "ModelContainer", _this75.target.add(_this75.modelContainer), _this75.mixer = new ha(_this75.modelContainer);
    var r = _this75.annotationRenderer.domElement,
        s = r.style;
    s.display = "none", s.pointerEvents = "none", s.position = "absolute", s.top = "0", _this75.element.shadowRoot.querySelector(".default").appendChild(r);
    return _this75;
  }

  _createClass(vc, [{
    key: "createContext",
    value: function createContext() {
      this.context = this.canvas.getContext("2d");
    }
  }, {
    key: "setObject",
    value: function () {
      var _setObject = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(t) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this.reset();
                this.modelContainer.add(t);
                _context7.next = 4;
                return this.setupScene();

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function setObject(_x9) {
        return _setObject.apply(this, arguments);
      }

      return setObject;
    }()
  }, {
    key: "setSource",
    value: function () {
      var _setSource = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(t) {
        var _this76 = this;

        var e,
            _t292,
            n,
            _n207,
            i,
            r,
            s,
            _iterator4,
            _step4,
            _t293,
            _args9 = arguments;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                e = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : function () {};

                if (!(!t || t === this.url)) {
                  _context9.next = 3;
                  break;
                }

                return _context9.abrupt("return", void e(1));

              case 3:
                if (!(this.reset(), this.url = t, null != this.externalRenderer)) {
                  _context9.next = 8;
                  break;
                }

                _context9.next = 6;
                return this.externalRenderer.load(e);

              case 6:
                _t292 = _context9.sent;
                return _context9.abrupt("return", (this.idealCameraDistance = _t292.framedRadius / uc, this.fieldOfViewAspect = _t292.fieldOfViewAspect, this.frameModel(), void this.dispatchEvent({
                  type: "model-load",
                  url: this.url
                })));

              case 8:
                null != this.cancelPendingSourceChange && (this.cancelPendingSourceChange(), this.cancelPendingSourceChange = null);
                _context9.prev = 9;
                _context9.next = 12;
                return new Promise( /*#__PURE__*/function () {
                  var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(n, i) {
                    return regeneratorRuntime.wrap(function _callee8$(_context8) {
                      while (1) {
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            _this76.cancelPendingSourceChange = function () {
                              return i();
                            };

                            _context8.prev = 1;
                            _context8.t0 = n;
                            _context8.next = 5;
                            return _this76.element[eu].loader.load(t, _this76.element, e);

                          case 5:
                            _context8.t1 = _context8.sent;
                            (0, _context8.t0)(_context8.t1);
                            _context8.next = 12;
                            break;

                          case 9:
                            _context8.prev = 9;
                            _context8.t2 = _context8["catch"](1);
                            i(_context8.t2);

                          case 12:
                          case "end":
                            return _context8.stop();
                        }
                      }
                    }, _callee8, null, [[1, 9]]);
                  }));

                  return function (_x11, _x12) {
                    return _ref10.apply(this, arguments);
                  };
                }());

              case 12:
                n = _context9.sent;
                _context9.next = 20;
                break;

              case 15:
                _context9.prev = 15;
                _context9.t0 = _context9["catch"](9);

                if (!(null == _context9.t0)) {
                  _context9.next = 19;
                  break;
                }

                return _context9.abrupt("return");

              case 19:
                throw _context9.t0;

              case 20:
                this.reset(), this.url = t, this._currentGLTF = n, null != n && this.modelContainer.add(n.scene);
                _n207 = n, i = _n207.animations, r = new Map(), s = [];
                _iterator4 = _createForOfIteratorHelper(i);

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    _t293 = _step4.value;
                    r.set(_t293.name, _t293), s.push(_t293.name);
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }

                this.animations = i;
                this.animationsByName = r;
                this.animationNames = s;
                _context9.next = 29;
                return this.setupScene();

              case 29:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[9, 15]]);
      }));

      function setSource(_x10) {
        return _setSource.apply(this, arguments);
      }

      return setSource;
    }()
  }, {
    key: "setupScene",
    value: function () {
      var _setupScene = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var t;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.updateBoundingBox();
                t = null;
                _context10.t0 = !0 === this.tightBounds;

                if (!_context10.t0) {
                  _context10.next = 7;
                  break;
                }

                _context10.next = 6;
                return this.element.requestUpdate("cameraTarget");

              case 6:
                t = this.getTarget();

              case 7:
                this.updateFraming(t);
                this.frameModel();
                this.setShadowIntensity(this.shadowIntensity);
                this.dispatchEvent({
                  type: "model-load",
                  url: this.url
                });

              case 11:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function setupScene() {
        return _setupScene.apply(this, arguments);
      }

      return setupScene;
    }()
  }, {
    key: "reset",
    value: function reset() {
      this.url = null, this.isDirty = !0, null != this.shadow && this.shadow.setIntensity(0);
      var t = this._currentGLTF;

      if (null != t) {
        var _iterator5 = _createForOfIteratorHelper(this.modelContainer.children),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _t294 = _step5.value;
            this.modelContainer.remove(_t294);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        t.dispose(), this._currentGLTF = null;
      }

      null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this);
    }
  }, {
    key: "currentGLTF",
    get: function get() {
      return this._currentGLTF;
    }
  }, {
    key: "setSize",
    value: function setSize(t, e) {
      if (this.width !== t || this.height !== e) {
        if (this.width = Math.max(t, 1), this.height = Math.max(e, 1), this.annotationRenderer.setSize(t, e), this.aspect = this.width / this.height, this.frameModel(), null != this.externalRenderer) {
          var n = Wl();
          this.externalRenderer.resize(t * n, e * n);
        }

        this.isDirty = !0;
      }
    }
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox() {
      if (this.target.remove(this.modelContainer), !0 === this.tightBounds) {
        var _t295 = function _t295(t, e) {
          return t.expandByPoint(e);
        };

        this.boundingBox = lc(this.modelContainer, _t295, new W());
      } else this.boundingBox.setFromObject(this.modelContainer);

      this.boundingBox.getSize(this.size), this.target.add(this.modelContainer);
    }
  }, {
    key: "updateFraming",
    value: function updateFraming() {
      var _this77 = this;

      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.target.remove(this.modelContainer), null == t && (t = this.boundingBox.getCenter(new H()));
      var e = Math.sqrt(lc(this.modelContainer, function (e, n) {
        return Math.max(e, t.distanceToSquared(n));
      }, 0));
      this.idealCameraDistance = e / uc;
      this.fieldOfViewAspect = lc(this.modelContainer, function (e, n) {
        n.sub(t);
        var i = Math.sqrt(n.x * n.x + n.z * n.z);
        return Math.max(e, i / (_this77.idealCameraDistance - Math.abs(n.y)));
      }, 0) / dc, this.target.add(this.modelContainer);
    }
  }, {
    key: "frameModel",
    value: function frameModel() {
      var t = dc * Math.max(1, this.fieldOfViewAspect / this.aspect);
      this.framedFieldOfView = 2 * Math.atan(t) * 180 / Math.PI;
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: this.width,
        height: this.height
      };
    }
  }, {
    key: "setTarget",
    value: function setTarget(t, e, n) {
      this.goalTarget.set(-t, -e, -n);
    }
  }, {
    key: "setTargetDamperDecayTime",
    value: function setTargetDamperDecayTime(t) {
      this.targetDamperX.setDecayTime(t), this.targetDamperY.setDecayTime(t), this.targetDamperZ.setDecayTime(t);
    }
  }, {
    key: "getTarget",
    value: function getTarget() {
      return fc.copy(this.goalTarget).multiplyScalar(-1);
    }
  }, {
    key: "jumpToGoal",
    value: function jumpToGoal() {
      this.updateTarget(1e4);
    }
  }, {
    key: "updateTarget",
    value: function updateTarget(t) {
      var e = this.goalTarget,
          n = this.target.position;

      if (!e.equals(n)) {
        var _i191 = this.idealCameraDistance;
        var _r130 = n.x,
            _s67 = n.y,
            _a54 = n.z;
        _r130 = this.targetDamperX.update(_r130, e.x, t, _i191), _s67 = this.targetDamperY.update(_s67, e.y, t, _i191), _a54 = this.targetDamperZ.update(_a54, e.z, t, _i191), this.target.position.set(_r130, _s67, _a54), this.target.updateMatrixWorld(), this.setShadowRotation(this.yaw), this.isDirty = !0;
      }
    }
  }, {
    key: "pointTowards",
    value: function pointTowards(t, e) {
      var _this$position = this.position,
          n = _this$position.x,
          i = _this$position.z;
      this.yaw = Math.atan2(t - n, e - i);
    }
  }, {
    key: "yaw",
    get: function get() {
      return this.rotation.y;
    },
    set: function set(t) {
      this.rotation.y = t, this.updateMatrixWorld(!0), this.setShadowRotation(t), this.isDirty = !0;
    }
  }, {
    key: "animationTime",
    get: function get() {
      return null != this.currentAnimationAction ? this.currentAnimationAction.time : 0;
    },
    set: function set(t) {
      this.mixer.setTime(t);
    }
  }, {
    key: "duration",
    get: function get() {
      return null != this.currentAnimationAction && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0;
    }
  }, {
    key: "hasActiveAnimation",
    get: function get() {
      return null != this.currentAnimationAction;
    }
  }, {
    key: "playAnimation",
    value: function playAnimation() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (null == this._currentGLTF) return;
      var n = this.animations;
      if (null == n || 0 === n.length) return void console.warn("Cannot play animation (model does not have any animations)");
      var i = null;
      null != t && (i = this.animationsByName.get(t)), null == i && (i = n[0]);

      try {
        var _t296 = this.currentAnimationAction;
        this.currentAnimationAction = this.mixer.clipAction(i, this).play(), this.currentAnimationAction.enabled = !0, null != _t296 && this.currentAnimationAction !== _t296 && this.currentAnimationAction.crossFadeFrom(_t296, e, !1);
      } catch (t) {
        console.error(t);
      }
    }
  }, {
    key: "stopAnimation",
    value: function stopAnimation() {
      null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction.reset(), this.currentAnimationAction = null), this.mixer.stopAllAction();
    }
  }, {
    key: "updateAnimation",
    value: function updateAnimation(t) {
      this.mixer.update(t);
    }
  }, {
    key: "updateShadow",
    value: function updateShadow() {
      var t = this.shadow;

      if (null != t) {
        var _e229 = "wall" === this.element.arPlacement ? "back" : "bottom";

        t.setScene(this, this.shadowSoftness, _e229);
      }
    }
  }, {
    key: "setShadowIntensity",
    value: function setShadowIntensity(t) {
      if (this.shadowIntensity = t, null == this._currentGLTF) return;
      var e = this.shadow;
      var n = "wall" === this.element.arPlacement ? "back" : "bottom";
      null != e ? (e.setIntensity(t), e.setScene(this, this.shadowSoftness, n)) : t > 0 && (e = new cc(this, this.shadowSoftness, n), e.setIntensity(t), this.shadow = e);
    }
  }, {
    key: "setShadowSoftness",
    value: function setShadowSoftness(t) {
      this.shadowSoftness = t;
      var e = this.shadow;
      null != e && e.setSoftness(t);
    }
  }, {
    key: "setShadowRotation",
    value: function setShadowRotation(t) {
      var e = this.shadow;
      null != e && e.setRotation(t);
    }
  }, {
    key: "isShadowDirty",
    value: function isShadowDirty() {
      var t = this.shadow;
      if (null == t) return !1;
      {
        var _e230 = t.needsUpdate;
        return t.needsUpdate = !1, _e230;
      }
    }
  }, {
    key: "setShadowScaleAndOffset",
    value: function setShadowScaleAndOffset(t, e) {
      var n = this.shadow;
      null != n && n.setScaleAndOffset(t, e);
    }
  }, {
    key: "positionAndNormalFromPoint",
    value: function positionAndNormalFromPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      mc.setFromCamera(t, this.camera);
      var n = mc.intersectObject(e, !0);
      if (0 === n.length) return null;
      var i = n[0];
      return null == i.face ? null : (i.face.normal.applyNormalMatrix(new D().getNormalMatrix(i.object.matrixWorld)), {
        position: i.point,
        normal: i.face.normal
      });
    }
  }, {
    key: "addHotspot",
    value: function addHotspot(t) {
      this.target.add(t), this.annotationRenderer.domElement.appendChild(t.element);
    }
  }, {
    key: "removeHotspot",
    value: function removeHotspot(t) {
      this.target.remove(t);
    }
  }, {
    key: "forHotspots",
    value: function forHotspots(t) {
      var e = this.target.children;

      for (var n = 0, _i192 = e.length; n < _i192; n++) {
        var _i193 = e[n];
        _i193 instanceof oc && t(_i193);
      }
    }
  }, {
    key: "updateHotspots",
    value: function updateHotspots(t) {
      var _this78 = this;

      this.forHotspots(function (e) {
        Ac.copy(t), pc.setFromMatrixPosition(e.matrixWorld), Ac.sub(pc), gc.copy(e.normal).transformDirection(_this78.target.matrixWorld), Ac.dot(gc) < 0 ? e.hide() : e.show();
      });
    }
  }, {
    key: "orientHotspots",
    value: function orientHotspots(t) {
      this.forHotspots(function (e) {
        e.orient(t);
      });
    }
  }, {
    key: "setHotspotsVisibility",
    value: function setHotspotsVisibility(t) {
      this.forHotspots(function (e) {
        e.visible = t;
      });
    }
  }, {
    key: "postRender",
    value: function postRender() {
      var t = this.camera;
      this.isDirty && (this.updateHotspots(t.position), this.annotationRenderer.domElement.style.display = "", this.annotationRenderer.render(this, t));
    }
  }]);

  return vc;
}(Mr);

var yc = function () {
  var t = new ls({
    uniforms: {
      roughnessMap: {
        value: null
      },
      normalMap: {
        value: null
      },
      texelSize: {
        value: new R(1, 1)
      }
    },
    vertexShader: "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t",
    fragmentShader: "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t",
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
  return t.type = "RoughnessMipmapper", t;
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(),
    Ec = new Ye(new An(2, 2), yc),
    xc = new Ys(0, 1, 0, 1, 0, 1);

var wc = null,
    bc = null;

var _c = /*#__PURE__*/function () {
  function _c(t) {
    _classCallCheck(this, _c);

    bc = t, bc.compile(Ec, xc);
  }

  _createClass(_c, [{
    key: "generateMipmaps",
    value: function generateMipmaps(t) {
      if ("roughnessMap" in t == !1) return;
      var e = t.roughnessMap,
          n = t.normalMap;
      if (null === e || null === n || !e.generateMipmaps || t.userData.roughnessUpdated) return;
      t.userData.roughnessUpdated = !0;
      var i = Math.max(e.image.width, n.image.width),
          r = Math.max(e.image.height, n.image.height);
      if (!L.isPowerOfTwo(i) || !L.isPowerOfTwo(r)) return;
      var s = bc.getRenderTarget(),
          a = bc.autoClear;

      if (bc.autoClear = !1, null !== wc && wc.width === i && wc.height === r || (null !== wc && wc.dispose(), wc = new k(i, r, {
        depthBuffer: !1
      }), wc.scissorTest = !0), i !== e.image.width || r !== e.image.height) {
        var _n208 = {
          wrapS: e.wrapS,
          wrapT: e.wrapT,
          magFilter: e.magFilter,
          minFilter: e.minFilter,
          depthBuffer: !1
        },
            _s68 = new k(i, r, _n208);

        _s68.texture.generateMipmaps = !0, bc.setRenderTarget(_s68), t.roughnessMap = _s68.texture, t.metalnessMap == e && (t.metalnessMap = t.roughnessMap), t.aoMap == e && (t.aoMap = t.roughnessMap), t.roughnessMap.offset.copy(e.offset), t.roughnessMap.repeat.copy(e.repeat), t.roughnessMap.center.copy(e.center), t.roughnessMap.rotation = e.rotation, t.roughnessMap.matrixAutoUpdate = e.matrixAutoUpdate, t.roughnessMap.matrix.copy(e.matrix);
      }

      yc.uniforms.roughnessMap.value = e, yc.uniforms.normalMap.value = n;
      var o = new R(0, 0),
          l = yc.uniforms.texelSize.value;

      for (var _e231 = 0; i >= 1 && r >= 1; ++_e231, i /= 2, r /= 2) {
        l.set(1 / i, 1 / r), 0 == _e231 && l.set(0, 0), wc.viewport.set(o.x, o.y, i, r), wc.scissor.set(o.x, o.y, i, r), bc.setRenderTarget(wc), bc.render(Ec, xc), bc.copyFramebufferToTexture(o, t.roughnessMap, _e231), yc.uniforms.roughnessMap.value = t.roughnessMap;
      }

      e !== t.roughnessMap && e.dispose(), bc.setRenderTarget(s), bc.autoClear = a;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      yc.dispose(), Ec.geometry.dispose(), null != wc && wc.dispose();
    }
  }]);

  return _c;
}();

var Ic = Math.PI / 24,
    Cc = new R(),
    Mc = function Mc(t, e, n) {
  var i = e > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI;

  for (var _r131 = 0; _r131 <= 12; ++_r131) {
    t.push(e + .17 * Math.cos(i), n + .17 * Math.sin(i), 0, e + .2 * Math.cos(i), n + .2 * Math.sin(i), 0), i += Ic;
  }
};

var Sc = /*#__PURE__*/function (_Ye2) {
  _inherits(Sc, _Ye2);

  var _super81 = _createSuper(Sc);

  function Sc(t, e) {
    var _this79;

    _classCallCheck(this, Sc);

    var n = new Te(),
        i = [],
        r = [],
        s = t.size,
        a = t.boundingBox,
        o = s.x / 2,
        l = ("back" === e ? s.y : s.z) / 2;
    Mc(r, o, l), Mc(r, -o, l), Mc(r, -o, -l), Mc(r, o, -l);
    var c = r.length / 3;

    for (var _t297 = 0; _t297 < c - 2; _t297 += 2) {
      i.push(_t297, _t297 + 1, _t297 + 3, _t297, _t297 + 3, _t297 + 2);
    }

    var h = c - 2;
    i.push(h, h + 1, 1, h, 1, 0), n.setAttribute("position", new xe(r, 3)), n.setIndex(i), _this79 = _super81.call(this, n), _this79.side = e;
    var u = _this79.material;

    switch (u.side = 2, u.transparent = !0, u.opacity = 0, _this79.goalOpacity = 0, _this79.opacityDamper = new jl(), _this79.hitPlane = new Ye(new An(2 * (o + .2), 2 * (l + .2))), _this79.hitPlane.visible = !1, _this79.add(_this79.hitPlane), a.getCenter(_this79.position), e) {
      case "bottom":
        _this79.rotateX(-Math.PI / 2), _this79.shadowHeight = a.min.y, _this79.position.y = _this79.shadowHeight;
        break;

      case "back":
        _this79.shadowHeight = a.min.z, _this79.position.z = _this79.shadowHeight;
    }

    t.target.add(_assertThisInitialized(_this79));
    return _this79;
  }

  _createClass(Sc, [{
    key: "getHit",
    value: function getHit(t, e, n) {
      Cc.set(e, -n), this.hitPlane.visible = !0;
      var i = t.positionAndNormalFromPoint(Cc, this.hitPlane);
      return this.hitPlane.visible = !1, null == i ? null : i.position;
    }
  }, {
    key: "offsetHeight",
    get: function get() {
      return "back" === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    },
    set: function set(t) {
      "back" === this.side ? this.position.z = this.shadowHeight + t : this.position.y = this.shadowHeight + t;
    }
  }, {
    key: "show",
    set: function set(t) {
      this.goalOpacity = t ? .75 : 0;
    }
  }, {
    key: "updateOpacity",
    value: function updateOpacity(t) {
      var e = this.material;
      e.opacity = this.opacityDamper.update(e.opacity, this.goalOpacity, t, 1), this.visible = e.opacity > 0;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var t;
      var _this$hitPlane = this.hitPlane,
          e = _this$hitPlane.geometry,
          n = _this$hitPlane.material;
      e.dispose(), n.dispose(), this.geometry.dispose(), this.material.dispose(), null === (t = this.parent) || void 0 === t || t.remove(this);
    }
  }]);

  return Sc;
}(Ye);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Bc = "not-presenting",
    Tc = "session-started",
    Lc = "object-placed",
    Rc = "failed",
    Dc = "tracking",
    Qc = "not-tracking",
    Pc = new H(),
    Fc = new yt(),
    Nc = new H();

var Uc = /*#__PURE__*/function (_y11) {
  _inherits(Uc, _y11);

  var _super82 = _createSuper(Uc);

  function Uc(t) {
    var _this80;

    _classCallCheck(this, Uc);

    _this80 = _super82.call(this), _this80.renderer = t, _this80.currentSession = null, _this80.placeOnWall = !1, _this80.cameraPosition = new H(), _this80.placementBox = null, _this80.lastTick = null, _this80.turntableRotation = null, _this80.oldShadowIntensity = null, _this80.oldBackground = null, _this80.frame = null, _this80.initialHitSource = null, _this80.transientHitTestSource = null, _this80.inputSource = null, _this80._presentedScene = null, _this80.resolveCleanup = null, _this80.exitWebXRButtonContainer = null, _this80.overlay = null, _this80.tracking = !0, _this80.frames = 0, _this80.initialized = !1, _this80.projectionMatrix = new yt(), _this80.projectionMatrixInverse = new yt(), _this80.oldTarget = new H(), _this80.placementComplete = !1, _this80.isTranslating = !1, _this80.isRotating = !1, _this80.isTwoFingering = !1, _this80.lastDragPosition = new H(), _this80.firstRatio = 0, _this80.lastAngle = 0, _this80.goalPosition = new H(), _this80.goalYaw = 0, _this80.goalScale = 1, _this80.xDamper = new jl(), _this80.yDamper = new jl(), _this80.zDamper = new jl(), _this80.yawDamper = new jl(), _this80.scaleDamper = new jl(), _this80.onExitWebXRButtonContainerClick = function () {
      return _this80.stopPresenting();
    }, _this80.onUpdateScene = function () {
      null != _this80.placementBox && _this80.isPresenting && (_this80.placementBox.dispose(), _this80.placementBox = new Sc(_this80.presentedScene, _this80.placeOnWall ? "back" : "bottom"));
    }, _this80.onSelectStart = function (t) {
      var e = _this80.transientHitTestSource;
      if (null == e) return;

      var n = _this80.frame.getHitTestResultsForTransientInput(e),
          i = _this80.presentedScene,
          r = _this80.placementBox;

      if (1 === n.length) {
        _this80.inputSource = t.inputSource;

        var _e232 = _this80.inputSource.gamepad.axes,
            _n209 = r.getHit(_this80.presentedScene, _e232[0], _e232[1]);

        r.show = !0, null != _n209 ? (_this80.isTranslating = !0, _this80.lastDragPosition.copy(_n209)) : !1 === _this80.placeOnWall && (_this80.isRotating = !0, _this80.lastAngle = 1.5 * _e232[0]);
      } else if (2 === n.length) {
        r.show = !0, _this80.isTwoFingering = !0;

        var _this80$fingerPolar = _this80.fingerPolar(n),
            _t298 = _this80$fingerPolar.separation;

        _this80.firstRatio = _t298 / i.scale.x;
      }
    }, _this80.onSelectEnd = function () {
      _this80.isTranslating = !1, _this80.isRotating = !1, _this80.isTwoFingering = !1, _this80.inputSource = null, _this80.goalPosition.y += _this80.placementBox.offsetHeight * _this80.presentedScene.scale.x, _this80.placementBox.show = !1;
    }, _this80.threeRenderer = t.threeRenderer, _this80.threeRenderer.xr.enabled = !0;
    return _this80;
  }

  _createClass(Uc, [{
    key: "resolveARSession",
    value: function () {
      var _resolveARSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var t;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                Ol();
                _context11.next = 3;
                return navigator.xr.requestSession("immersive-ar", {
                  requiredFeatures: ["hit-test"],
                  optionalFeatures: ["dom-overlay"],
                  domOverlay: {
                    root: this.overlay
                  }
                });

              case 3:
                t = _context11.sent;
                this.threeRenderer.xr.setReferenceSpaceType("local");
                _context11.next = 7;
                return this.threeRenderer.xr.setSession(t);

              case 7:
                return _context11.abrupt("return", t);

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function resolveARSession() {
        return _resolveARSession.apply(this, arguments);
      }

      return resolveARSession;
    }()
  }, {
    key: "presentedScene",
    get: function get() {
      return this._presentedScene;
    }
  }, {
    key: "supportsPresentation",
    value: function () {
      var _supportsPresentation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.prev = 0;
                Ol();
                _context12.next = 4;
                return navigator.xr.isSessionSupported("immersive-ar");

              case 4:
                return _context12.abrupt("return", _context12.sent);

              case 7:
                _context12.prev = 7;
                _context12.t0 = _context12["catch"](0);
                return _context12.abrupt("return", (console.warn("Request to present in WebXR denied:"), console.warn(_context12.t0), console.warn("Falling back to next ar-mode"), !1));

              case 10:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, null, [[0, 7]]);
      }));

      function supportsPresentation() {
        return _supportsPresentation.apply(this, arguments);
      }

      return supportsPresentation;
    }()
  }, {
    key: "present",
    value: function () {
      var _present = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(t) {
        var _this81 = this;

        var e, n, i, r, s, a;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.isPresenting && console.warn("Cannot present while a model is already presenting");
                e = new Promise(function (t, e) {
                  requestAnimationFrame(function () {
                    return t();
                  });
                });
                t.setHotspotsVisibility(!1);
                t.isDirty = !0;
                _context13.next = 6;
                return e;

              case 6:
                this._presentedScene = t;
                this.overlay = t.element.shadowRoot.querySelector("div.default");
                _context13.next = 10;
                return this.resolveARSession();

              case 10:
                n = _context13.sent;
                n.addEventListener("end", function () {
                  _this81.postSessionCleanup();
                }, {
                  once: !0
                });
                i = t.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
                i.classList.add("enabled"), i.addEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = i;
                _context13.next = 16;
                return n.requestReferenceSpace("viewer");

              case 16:
                r = _context13.sent;
                this.tracking = !0, this.frames = 0, this.initialized = !1, this.turntableRotation = t.yaw, this.goalYaw = t.yaw, this.goalScale = 1, this.oldBackground = t.background, t.background = null, this.oldShadowIntensity = t.shadowIntensity, t.setShadowIntensity(0), this.oldTarget.copy(t.getTarget()), t.addEventListener("model-load", this.onUpdateScene);
                s = 20 * Math.PI / 180, a = !0 === this.placeOnWall ? void 0 : new XRRay(new DOMPoint(0, 0, 0), {
                  x: 0,
                  y: -Math.sin(s),
                  z: -Math.cos(s)
                });
                n.requestHitTestSource({
                  space: r,
                  offsetRay: a
                }).then(function (t) {
                  _this81.initialHitSource = t;
                }), this.currentSession = n, this.placementBox = new Sc(t, this.placeOnWall ? "back" : "bottom"), this.placementComplete = !1, this.xDamper.setDecayTime(120), this.yDamper.setDecayTime(120), this.zDamper.setDecayTime(120), this.lastTick = performance.now(), this.dispatchEvent({
                  type: "status",
                  status: Tc
                });

              case 20:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function present(_x13) {
        return _present.apply(this, arguments);
      }

      return present;
    }()
  }, {
    key: "stopPresenting",
    value: function () {
      var _stopPresenting = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var _this82 = this;

        var t;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (this.isPresenting) {
                  _context14.next = 2;
                  break;
                }

                return _context14.abrupt("return");

              case 2:
                t = new Promise(function (t) {
                  _this82.resolveCleanup = t;
                });
                _context14.prev = 3;
                _context14.next = 6;
                return this.currentSession.end();

              case 6:
                _context14.next = 8;
                return t;

              case 8:
                _context14.next = 13;
                break;

              case 10:
                _context14.prev = 10;
                _context14.t0 = _context14["catch"](3);
                console.warn("Error while trying to end WebXR AR session"), console.warn(_context14.t0), this.postSessionCleanup();

              case 13:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[3, 10]]);
      }));

      function stopPresenting() {
        return _stopPresenting.apply(this, arguments);
      }

      return stopPresenting;
    }()
  }, {
    key: "isPresenting",
    get: function get() {
      return null != this.presentedScene;
    }
  }, {
    key: "target",
    get: function get() {
      return this.oldTarget;
    }
  }, {
    key: "updateTarget",
    value: function updateTarget() {
      var t = this.presentedScene;

      if (null != t) {
        var _e233 = t.getTarget();

        this.oldTarget.copy(_e233), this.placeOnWall ? t.setTarget(_e233.x, _e233.y, t.boundingBox.min.z) : t.setTarget(_e233.x, t.boundingBox.min.y, _e233.z);
      }
    }
  }, {
    key: "postSessionCleanup",
    value: function postSessionCleanup() {
      var t = this.currentSession;
      null != t && (t.removeEventListener("selectstart", this.onSelectStart), t.removeEventListener("selectend", this.onSelectEnd), this.currentSession = null);
      var e = this.presentedScene;

      if (null != e) {
        var _t299 = e.element;
        e.position.set(0, 0, 0), e.scale.set(1, 1, 1), e.setShadowScaleAndOffset(1, 0);
        var _n210 = this.turntableRotation;
        null != _n210 && (e.yaw = _n210);
        var _i194 = this.oldShadowIntensity;
        null != _i194 && e.setShadowIntensity(_i194);
        var _r132 = this.oldBackground;
        null != _r132 && (e.background = _r132);
        var _s69 = this.oldTarget;
        e.setTarget(_s69.x, _s69.y, _s69.z), e.removeEventListener("model-load", this.onUpdateScene), e.orientHotspots(0), _t299.requestUpdate("cameraTarget"), _t299.requestUpdate("maxCameraOrbit"), _t299[tu](_t299.getBoundingClientRect());
      }

      this.renderer.height = 0;
      var n = this.exitWebXRButtonContainer;
      null != n && (n.classList.remove("enabled"), n.removeEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = null);
      var i = this.transientHitTestSource;
      null != i && (i.cancel(), this.transientHitTestSource = null);
      var r = this.initialHitSource;
      null != r && (r.cancel(), this.initialHitSource = null), null != this.placementBox && (this.placementBox.dispose(), this.placementBox = null), this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this._presentedScene = null, this.frame = null, this.inputSource = null, this.overlay = null, null != this.resolveCleanup && this.resolveCleanup(), this.dispatchEvent({
        type: "status",
        status: Bc
      });
    }
  }, {
    key: "updateView",
    value: function updateView(t) {
      var e = t.transform.matrix,
          n = this.presentedScene,
          i = n.camera;

      if (i.near = .1, i.far = 100, this.presentedScene.orientHotspots(Math.atan2(e[1], e[5])), this.cameraPosition.set(e[12], e[13], e[14]), !this.initialized) {
        var _t300 = n.position,
            _r133 = n.element,
            _this$overlay$getBoun = this.overlay.getBoundingClientRect(),
            _s70 = _this$overlay$getBoun.width,
            _a55 = _this$overlay$getBoun.height;

        n.setSize(_s70, _a55), null != this.threeRenderer.xr.getSession() && (this.projectionMatrix.copy(this.threeRenderer.xr.getCamera(i).projectionMatrix), this.projectionMatrixInverse.copy(this.projectionMatrix).invert());

        var _r133$getCameraOrbit = _r133.getCameraOrbit(),
            _o35 = _r133$getCameraOrbit.theta,
            _l35 = _r133$getCameraOrbit.radius,
            _c29 = Pc.set(e[8], e[9], e[10]);

        n.yaw = Math.atan2(_c29.x, _c29.z) - _o35, this.goalYaw = n.yaw, _t300.copy(this.cameraPosition).add(_c29.multiplyScalar(-1 * _l35)), this.goalPosition.copy(_t300), n.setHotspotsVisibility(!0), this.initialized = !0;
      }

      if (i.projectionMatrix.copy(this.projectionMatrix), i.projectionMatrixInverse.copy(this.projectionMatrixInverse), t.requestViewportScale && t.recommendedViewportScale) {
        var _e234 = t.recommendedViewportScale;
        t.requestViewportScale(Math.max(_e234, .25));
      }

      var r = this.currentSession.renderState.baseLayer.getViewport(t);
      this.threeRenderer.setViewport(r.x, r.y, r.width, r.height);
    }
  }, {
    key: "placeInitially",
    value: function placeInitially(t) {
      var _this83 = this;

      var e = this.initialHitSource;
      if (null == e) return;
      var n = t.getHitTestResults(e);
      if (0 == n.length) return;
      var i = n[0],
          r = this.getHitPoint(i);
      if (null == r) return;
      this.placeModel(r), e.cancel(), this.initialHitSource = null;
      var s = t.session;
      s.addEventListener("selectstart", this.onSelectStart), s.addEventListener("selectend", this.onSelectEnd), s.requestHitTestSourceForTransientInput({
        profile: "generic-touchscreen"
      }).then(function (t) {
        _this83.transientHitTestSource = t;
      });
    }
  }, {
    key: "getHitPoint",
    value: function getHitPoint(t) {
      var e = this.threeRenderer.xr.getReferenceSpace(),
          n = t.getPose(e);
      if (null == n) return null;
      var i = Fc.fromArray(n.transform.matrix);
      return !0 === this.placeOnWall && (this.goalYaw = Math.atan2(i.elements[4], i.elements[6])), i.elements[5] > .75 !== this.placeOnWall ? Nc.setFromMatrixPosition(i) : null;
    }
  }, {
    key: "placeModel",
    value: function placeModel(t) {
      this.placementBox.show = !0, this.placeOnWall ? this.goalPosition.copy(t) : this.goalPosition.y = t.y, this.updateTarget(), this.dispatchEvent({
        type: "status",
        status: Lc
      });
    }
  }, {
    key: "fingerPolar",
    value: function fingerPolar(t) {
      var e = t[0].inputSource.gamepad.axes,
          n = t[1].inputSource.gamepad.axes,
          i = n[0] - e[0],
          r = n[1] - e[1],
          s = Math.atan2(r, i);
      var a = this.lastAngle - s;
      return a > Math.PI ? a -= 2 * Math.PI : a < -Math.PI && (a += 2 * Math.PI), this.lastAngle = s, {
        separation: Math.sqrt(i * i + r * r),
        deltaYaw: a
      };
    }
  }, {
    key: "processInput",
    value: function processInput(t) {
      var _this84 = this;

      var e = this.transientHitTestSource;
      if (null == e) return;
      if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
      var n = t.getHitTestResultsForTransientInput(e),
          i = this.presentedScene,
          r = i.scale.x;
      if (this.isTwoFingering) {
        if (n.length < 2) this.isTwoFingering = !1;else {
          var _this$fingerPolar = this.fingerPolar(n),
              _t301 = _this$fingerPolar.separation,
              _e235 = _this$fingerPolar.deltaYaw;

          if (!1 === this.placeOnWall && (this.goalYaw += _e235), i.canScale) {
            var _e236 = _t301 / this.firstRatio;

            this.goalScale = _e236 < 1.2 && _e236 > .8333333333333334 ? 1 : _e236;
          }
        }
      } else if (2 !== n.length) {
        if (this.isRotating) {
          var _t302 = 1.5 * this.inputSource.gamepad.axes[0];

          this.goalYaw += _t302 - this.lastAngle, this.lastAngle = _t302;
        } else this.isTranslating && n.forEach(function (t) {
          if (t.inputSource !== _this84.inputSource || t.results.length < 1) return;

          var e = _this84.getHitPoint(t.results[0]);

          if (null != e) {
            if (_this84.goalPosition.sub(_this84.lastDragPosition), !1 === _this84.placeOnWall) {
              var _t303 = e.y - _this84.lastDragPosition.y;

              if (_t303 < 0) {
                _this84.placementBox.offsetHeight = _t303 / r, _this84.presentedScene.setShadowScaleAndOffset(r, _t303);

                var _n211 = Pc.copy(_this84.cameraPosition),
                    _i195 = -_t303 / (_n211.y - e.y);

                _n211.multiplyScalar(_i195), e.multiplyScalar(1 - _i195).add(_n211);
              }
            }

            _this84.goalPosition.add(e), _this84.lastDragPosition.copy(e);
          }
        });
      } else {
        this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;

        var _this$fingerPolar2 = this.fingerPolar(n),
            _t304 = _this$fingerPolar2.separation;

        this.firstRatio = _t304 / r;
      }
    }
  }, {
    key: "moveScene",
    value: function moveScene(t) {
      var e = this.presentedScene,
          n = e.position,
          i = e.yaw,
          r = e.idealCameraDistance,
          s = this.goalPosition,
          a = e.scale.x,
          o = this.placementBox;

      if (null == this.initialHitSource && (!s.equals(n) || this.goalScale !== a)) {
        var _i196 = n.x,
            _l36 = n.y,
            _c30 = n.z;
        _i196 = this.xDamper.update(_i196, s.x, t, r), _l36 = this.yDamper.update(_l36, s.y, t, r), _c30 = this.zDamper.update(_c30, s.z, t, r), n.set(_i196, _l36, _c30);

        var _h14 = this.scaleDamper.update(a, this.goalScale, t, 1);

        if (e.scale.set(_h14, _h14, _h14), !this.isTranslating) {
          var _t305 = s.y - _l36;

          this.placementComplete && !1 === this.placeOnWall ? (o.offsetHeight = _t305 / _h14, e.setShadowScaleAndOffset(_h14, _t305)) : 0 === _t305 && (this.placementComplete = !0, o.show = !1, e.setShadowIntensity(.3), this.xDamper.setDecayTime(50), this.yDamper.setDecayTime(50), this.zDamper.setDecayTime(50));
        }
      }

      o.updateOpacity(t), e.updateTarget(t), e.yaw = this.yawDamper.update(i, this.goalYaw, t, Math.PI);
    }
  }, {
    key: "onWebXRFrame",
    value: function onWebXRFrame(t, e) {
      this.frame = e, ++this.frames;
      var n = this.threeRenderer.xr.getReferenceSpace(),
          i = e.getViewerPose(n);
      null == i && !0 === this.tracking && this.frames > 30 && (this.tracking = !1, this.dispatchEvent({
        type: "tracking",
        status: Qc
      }));
      var r = this.presentedScene;
      if (null == i || null == r || !r.element[au]()) return void this.threeRenderer.clear();
      !1 === this.tracking && (this.tracking = !0, this.dispatchEvent({
        type: "tracking",
        status: Dc
      }));
      var s = !0;

      var _iterator6 = _createForOfIteratorHelper(i.views),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _n212 = _step6.value;

          if (this.updateView(_n212), s) {
            this.placeInitially(e), this.processInput(e);

            var _n213 = t - this.lastTick;

            this.moveScene(_n213), this.renderer.preRender(r, t, _n213), this.lastTick = t;
          }

          var _i197 = this.threeRenderer.getContext();

          _i197.depthMask(!1), _i197.clear(_i197.DEPTH_BUFFER_BIT), _i197.depthMask(!0), this.threeRenderer.render(r, r.camera), s = !1;
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }]);

  return Uc;
}(y);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Gc = /*#__PURE__*/function () {
  function Gc(t) {
    _classCallCheck(this, Gc);

    t.threeRenderer.debug = {
      checkShaderErrors: !0
    }, Promise.resolve().then(function () {
      self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", {
        detail: {
          renderer: t,
          THREE: {
            ShaderMaterial: tn,
            Texture: N,
            Mesh: Ye,
            Scene: Mr,
            PlaneBufferGeometry: An,
            OrthographicCamera: Ys,
            WebGLRenderTarget: k
          }
        }
      }));
    });
  }

  _createClass(Gc, [{
    key: "addScene",
    value: function addScene(t) {
      self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", {
        detail: {
          scene: t
        }
      }));
    }
  }, {
    key: "removeScene",
    value: function removeScene(t) {
      self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", {
        detail: {
          scene: t
        }
      }));
    }
  }]);

  return Gc;
}();

function kc(t, e, n) {
  n(t, e);

  for (var _i198 = 0; _i198 < t.children.length; _i198++) {
    kc(t.children[_i198], e.children[_i198], n);
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Oc = Symbol("prepared"),
    Hc = Symbol("prepare"),
    zc = Symbol("preparedGLTF"),
    Vc = Symbol("clone");

var Wc = /*#__PURE__*/function () {
  function Wc(t) {
    _classCallCheck(this, Wc);

    this[zc] = t;
  }

  _createClass(Wc, [{
    key: "parser",
    get: function get() {
      return this[zc].parser;
    }
  }, {
    key: "animations",
    get: function get() {
      return this[zc].animations;
    }
  }, {
    key: "scene",
    get: function get() {
      return this[zc].scene;
    }
  }, {
    key: "scenes",
    get: function get() {
      return this[zc].scenes;
    }
  }, {
    key: "cameras",
    get: function get() {
      return this[zc].cameras;
    }
  }, {
    key: "asset",
    get: function get() {
      return this[zc].asset;
    }
  }, {
    key: "userData",
    get: function get() {
      return this[zc].userData;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new (0, this.constructor)(this[Vc]());
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.scenes.forEach(function (t) {
        t.traverse(function (t) {
          if (!t.isMesh) return;
          var e = t;
          (Array.isArray(e.material) ? e.material : [e.material]).forEach(function (t) {
            t.dispose();
          }), e.geometry.dispose();
        });
      });
    }
  }, {
    key: Vc,
    value: function value() {
      var t = this[zc],
          e = /*#__PURE__*/function () {
        function _class6() {
          _classCallCheck(this, _class6);
        }

        _createClass(_class6, null, [{
          key: "retarget",
          value: function retarget(t, e) {
            var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var i = new H(),
                r = new O(),
                s = new H(),
                a = new yt(),
                o = new yt(),
                l = new yt();
            n.preserveMatrix = void 0 === n.preserveMatrix || n.preserveMatrix, n.preservePosition = void 0 === n.preservePosition || n.preservePosition, n.preserveHipPosition = void 0 !== n.preserveHipPosition && n.preserveHipPosition, n.useTargetMatrix = void 0 !== n.useTargetMatrix && n.useTargetMatrix, n.hip = void 0 !== n.hip ? n.hip : "hip", n.names = n.names || {};
            var c = e.isObject3D ? e.skeleton.bones : this.getBones(e),
                h = t.isObject3D ? t.skeleton.bones : this.getBones(t);
            var u, d, A, p, g;

            if (t.isObject3D ? t.skeleton.pose() : (n.useTargetMatrix = !0, n.preserveMatrix = !1), n.preservePosition) {
              g = [];

              for (var _t306 = 0; _t306 < h.length; _t306++) {
                g.push(h[_t306].position.clone());
              }
            }

            if (n.preserveMatrix) {
              t.updateMatrixWorld(), t.matrixWorld.identity();

              for (var _e237 = 0; _e237 < t.children.length; ++_e237) {
                t.children[_e237].updateMatrixWorld(!0);
              }
            }

            if (n.offsets) {
              u = [];

              for (var _t307 = 0; _t307 < h.length; ++_t307) {
                d = h[_t307], A = n.names[d.name] || d.name, n.offsets && n.offsets[A] && (d.matrix.multiply(n.offsets[A]), d.matrix.decompose(d.position, d.quaternion, d.scale), d.updateMatrixWorld()), u.push(d.matrixWorld.clone());
              }
            }

            for (var _e238 = 0; _e238 < h.length; ++_e238) {
              if (d = h[_e238], A = n.names[d.name] || d.name, p = this.getBoneByName(A, c), l.copy(d.matrixWorld), p) {
                if (p.updateMatrixWorld(), n.useTargetMatrix ? o.copy(p.matrixWorld) : (o.copy(t.matrixWorld).invert(), o.multiply(p.matrixWorld)), s.setFromMatrixScale(o), o.scale(s.set(1 / s.x, 1 / s.y, 1 / s.z)), l.makeRotationFromQuaternion(r.setFromRotationMatrix(o)), t.isObject3D) {
                  var _e239 = h.indexOf(d),
                      _n214 = u ? u[_e239] : a.copy(t.skeleton.boneInverses[_e239]).invert();

                  l.multiply(_n214);
                }

                l.copyPosition(o);
              }

              d.parent && d.parent.isBone ? (d.matrix.copy(d.parent.matrixWorld).invert(), d.matrix.multiply(l)) : d.matrix.copy(l), n.preserveHipPosition && A === n.hip && d.matrix.setPosition(i.set(0, d.position.y, 0)), d.matrix.decompose(d.position, d.quaternion, d.scale), d.updateMatrixWorld();
            }

            if (n.preservePosition) for (var _t308 = 0; _t308 < h.length; ++_t308) {
              d = h[_t308], A = n.names[d.name] || d.name, A !== n.hip && d.position.copy(g[_t308]);
            }
            n.preserveMatrix && t.updateMatrixWorld(!0);
          }
        }, {
          key: "retargetClip",
          value: function retargetClip(t, e, n) {
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            i.useFirstFramePosition = void 0 !== i.useFirstFramePosition && i.useFirstFramePosition, i.fps = void 0 !== i.fps ? i.fps : 30, i.names = i.names || [], e.isObject3D || (e = this.getHelperFromSkeleton(e));
            var r = Math.round(n.duration * (i.fps / 1e3) * 1e3),
                s = 1 / i.fps,
                a = [],
                o = new ha(e),
                l = this.getBones(t.skeleton),
                c = [];
            var h, u, d, A, p;
            o.clipAction(n).play(), o.update(0), e.updateMatrixWorld();

            for (var _n215 = 0; _n215 < r; ++_n215) {
              var _a56 = _n215 * s;

              this.retarget(t, e, i);

              for (var _t309 = 0; _t309 < l.length; ++_t309) {
                p = i.names[l[_t309].name] || l[_t309].name, d = this.getBoneByName(p, e.skeleton), d && (u = l[_t309], A = c[_t309] = c[_t309] || {
                  bone: u
                }, i.hip === p && (A.pos || (A.pos = {
                  times: new Float32Array(r),
                  values: new Float32Array(3 * r)
                }), i.useFirstFramePosition && (0 === _n215 && (h = u.position.clone()), u.position.sub(h)), A.pos.times[_n215] = _a56, u.position.toArray(A.pos.values, 3 * _n215)), A.quat || (A.quat = {
                  times: new Float32Array(r),
                  values: new Float32Array(4 * r)
                }), A.quat.times[_n215] = _a56, u.quaternion.toArray(A.quat.values, 4 * _n215));
              }

              o.update(s), e.updateMatrixWorld();
            }

            for (var _t310 = 0; _t310 < c.length; ++_t310) {
              A = c[_t310], A && (A.pos && a.push(new bs(".bones[" + A.bone.name + "].position", A.pos.times, A.pos.values)), a.push(new xs(".bones[" + A.bone.name + "].quaternion", A.quat.times, A.quat.values)));
            }

            return o.uncacheAction(n), new _s(n.name, -1, a);
          }
        }, {
          key: "getHelperFromSkeleton",
          value: function getHelperFromSkeleton(t) {
            var e = new fa(t.bones[0]);
            return e.skeleton = t, e;
          }
        }, {
          key: "getSkeletonOffsets",
          value: function getSkeletonOffsets(t, e) {
            var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var i = new H(),
                r = new H(),
                s = new H(),
                a = new H(),
                o = new R(),
                l = new R();
            n.hip = void 0 !== n.hip ? n.hip : "hip", n.names = n.names || {}, e.isObject3D || (e = this.getHelperFromSkeleton(e));
            var c = Object.keys(n.names),
                h = Object.values(n.names),
                u = e.isObject3D ? e.skeleton.bones : this.getBones(e),
                d = t.isObject3D ? t.skeleton.bones : this.getBones(t),
                A = [];
            var p, g, m, f;

            for (t.skeleton.pose(), f = 0; f < d.length; ++f) {
              if (p = d[f], m = n.names[p.name] || p.name, g = this.getBoneByName(m, u), g && m !== n.hip) {
                var _t311 = this.getNearestBone(p.parent, c),
                    _e240 = this.getNearestBone(g.parent, h);

                _t311.updateMatrixWorld(), _e240.updateMatrixWorld(), i.setFromMatrixPosition(_t311.matrixWorld), r.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(_e240.matrixWorld), a.setFromMatrixPosition(g.matrixWorld), o.subVectors(new R(r.x, r.y), new R(i.x, i.y)).normalize(), l.subVectors(new R(a.x, a.y), new R(s.x, s.y)).normalize();

                var _n216 = o.angle() - l.angle(),
                    _u14 = new yt().makeRotationFromEuler(new Bt(0, 0, _n216));

                p.matrix.multiply(_u14), p.matrix.decompose(p.position, p.quaternion, p.scale), p.updateMatrixWorld(), A[m] = _u14;
              }
            }

            return A;
          }
        }, {
          key: "renameBones",
          value: function renameBones(t, e) {
            var n = this.getBones(t);

            for (var _t312 = 0; _t312 < n.length; ++_t312) {
              var _i199 = n[_t312];
              e[_i199.name] && (_i199.name = e[_i199.name]);
            }

            return this;
          }
        }, {
          key: "getBones",
          value: function getBones(t) {
            return Array.isArray(t) ? t : t.bones;
          }
        }, {
          key: "getBoneByName",
          value: function getBoneByName(t, e) {
            for (var _n217 = 0, _i200 = this.getBones(e); _n217 < _i200.length; _n217++) {
              if (t === _i200[_n217].name) return _i200[_n217];
            }
          }
        }, {
          key: "getNearestBone",
          value: function getNearestBone(t, e) {
            for (; t.isBone;) {
              if (-1 !== e.indexOf(t.name)) return t;
              t = t.parent;
            }
          }
        }, {
          key: "findBoneTrackData",
          value: function findBoneTrackData(t, e) {
            var n = /\[(.*)\]\.(.*)/,
                i = {
              name: t
            };

            for (var _r134 = 0; _r134 < e.length; ++_r134) {
              var _s71 = n.exec(e[_r134].name);

              _s71 && t === _s71[1] && (i[_s71[2]] = _r134);
            }

            return i;
          }
        }, {
          key: "getEqualsBonesNames",
          value: function getEqualsBonesNames(t, e) {
            var n = this.getBones(t),
                i = this.getBones(e),
                r = [];

            t: for (var _t313 = 0; _t313 < n.length; _t313++) {
              var _e241 = n[_t313].name;

              for (var _t314 = 0; _t314 < i.length; _t314++) {
                if (_e241 === i[_t314].name) {
                  r.push(_e241);
                  continue t;
                }
              }
            }

            return r;
          }
        }, {
          key: "clone",
          value: function clone(t) {
            var e = new Map(),
                n = new Map(),
                i = t.clone();
            return kc(t, i, function (t, i) {
              e.set(i, t), n.set(t, i);
            }), i.traverse(function (t) {
              if (!t.isSkinnedMesh) return;
              var i = t,
                  r = e.get(t),
                  s = r.skeleton.bones;
              i.skeleton = r.skeleton.clone(), i.bindMatrix.copy(r.bindMatrix), i.skeleton.bones = s.map(function (t) {
                return n.get(t);
              }), i.bind(i.skeleton, i.bindMatrix);
            }), i;
          }
        }]);

        return _class6;
      }().clone(this.scene),
          n = [e],
          i = t.userData ? Object.assign({}, t.userData) : {};

      return Object.assign(Object.assign({}, t), {
        scene: e,
        scenes: n,
        userData: i
      });
    }
  }], [{
    key: "prepare",
    value: function prepare(t) {
      if (null == t.scene) throw new Error("Model does not have a scene");
      if (t[Oc]) return t;
      var e = this[Hc](t);
      return e[Oc] = !0, e;
    }
  }, {
    key: Hc,
    value: function value(t) {
      var e = t.scene,
          n = [e];
      return Object.assign(Object.assign({}, t), {
        scene: e,
        scenes: n
      });
    }
  }]);

  return Wc;
}();
/**
 * @license MIT
 * @see https://github.com/mrdoob/three.js/blob/dev/LICENSE
 */


var qc = "\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n    diffuseColor.a = 1.0;\n\n#endif\n",
    jc = Symbol("threeGLTF"),
    Yc = Symbol("gltf"),
    Jc = Symbol("gltfElementMap"),
    Xc = Symbol("threeObjectMap"),
    Kc = Symbol("parallelTraverseThreeScene"),
    Zc = Symbol("correlateOriginalThreeGLTF"),
    $c = Symbol("correlateCloneThreeGLTF");

var th = /*#__PURE__*/function () {
  function th(t, e, n, i) {
    _classCallCheck(this, th);

    this[jc] = t, this[Yc] = e, this[Jc] = i, this[Xc] = n;
  }

  _createClass(th, [{
    key: "threeGLTF",
    get: function get() {
      return this[jc];
    }
  }, {
    key: "gltf",
    get: function get() {
      return this[Yc];
    }
  }, {
    key: "gltfElementMap",
    get: function get() {
      return this[Jc];
    }
  }, {
    key: "threeObjectMap",
    get: function get() {
      return this[Xc];
    }
  }, {
    key: "loadVariant",
    value: function loadVariant(t) {
      var _this85 = this;

      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      var n = new Set();
      return this.threeGLTF.scene.traverse( /*#__PURE__*/function () {
        var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(i) {
          var r, s, a, _iterator7, _step7, _e242, o, l, c;

          return regeneratorRuntime.wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  r = i.userData.gltfExtensions;

                  if (!(!i.isMesh || null == r)) {
                    _context15.next = 3;
                    break;
                  }

                  return _context15.abrupt("return");

                case 3:
                  s = r.KHR_materials_variants;

                  if (!(null == s)) {
                    _context15.next = 6;
                    break;
                  }

                  return _context15.abrupt("return");

                case 6:
                  a = -1;
                  _iterator7 = _createForOfIteratorHelper(s.mappings);
                  _context15.prev = 8;

                  _iterator7.s();

                case 10:
                  if ((_step7 = _iterator7.n()).done) {
                    _context15.next = 17;
                    break;
                  }

                  _e242 = _step7.value;

                  if (!(_e242.variants.indexOf(t) >= 0)) {
                    _context15.next = 15;
                    break;
                  }

                  a = _e242.material;
                  return _context15.abrupt("break", 17);

                case 15:
                  _context15.next = 10;
                  break;

                case 17:
                  _context15.next = 22;
                  break;

                case 19:
                  _context15.prev = 19;
                  _context15.t0 = _context15["catch"](8);

                  _iterator7.e(_context15.t0);

                case 22:
                  _context15.prev = 22;

                  _iterator7.f();

                  return _context15.finish(22);

                case 25:
                  if (!(a < 0)) {
                    _context15.next = 27;
                    break;
                  }

                  return _context15.abrupt("return");

                case 27:
                  _context15.next = 29;
                  return _this85.threeGLTF.parser.getDependency("material", a);

                case 29:
                  o = _context15.sent;
                  n.add(a), i.material = o, _this85.threeGLTF.parser.assignFinalMaterial(i), e();
                  l = _this85.gltf.materials[a];
                  c = _this85.gltfElementMap.get(l);
                  null == c && (c = new Set(), _this85.gltfElementMap.set(l, c)), c.add(i.material);

                case 34:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15, null, [[8, 19, 22, 25]]);
        }));

        return function (_x14) {
          return _ref11.apply(this, arguments);
        };
      }()), n;
    }
  }], [{
    key: "from",
    value: function from(t, e) {
      return null != e ? this[$c](t, e) : this[Zc](t);
    }
  }, {
    key: Zc,
    value: function value(t) {
      var e = t.parser.json,
          n = t.parser.associations,
          i = new Map(),
          r = {
        name: "Default"
      },
          s = {
        type: "materials",
        index: -1
      };
      return n.forEach(function (t, n) {
        null == t && (s.index < 0 && (null == e.materials && (e.materials = []), s.index = e.materials.length, e.materials.push(r)), t = s);
        var _t315 = t,
            a = _t315.type,
            o = _t315.index,
            l = (e[a] || [])[o];
        if (null == l) return;
        var c = i.get(l);
        null == c && (c = new Set(), i.set(l, c)), c.add(n);
      }), new th(t, e, n, i);
    }
  }, {
    key: $c,
    value: function value(t, e) {
      var n = e.threeGLTF,
          i = e.gltf,
          r = JSON.parse(JSON.stringify(i)),
          s = new Map(),
          a = new Map(),
          o = {
        name: "Default"
      },
          l = {
        type: "materials",
        index: -1
      };

      for (var _i201 = 0; _i201 < n.scenes.length; _i201++) {
        this[Kc](n.scenes[_i201], t.scenes[_i201], function (t, n) {
          var i = e.threeObjectMap.get(t);
          null == i && (l.index < 0 && (null == r.materials && (r.materials = []), l.index = r.materials.length, r.materials.push(o)), i = l);
          var _i202 = i,
              c = _i202.type,
              h = _i202.index,
              u = r[c][h];
          s.set(n, {
            type: c,
            index: h
          });
          var d = a.get(u) || new Set();
          d.add(n), a.set(u, d);
        });
      }

      return new th(t, r, s, a);
    }
  }, {
    key: Kc,
    value: function value(t, e, n) {
      var i = function i(t, e) {
        if (n(t, e), t.isObject3D) {
          if (t.isMesh) if (Array.isArray(t.material)) for (var _n218 = 0; _n218 < t.material.length; ++_n218) {
            i(t.material[_n218], e.material[_n218]);
          } else i(t.material, e.material);

          for (var _n219 = 0; _n219 < t.children.length; ++_n219) {
            i(t.children[_n219], e.children[_n219]);
          }
        }
      };

      i(t, e);
    }
  }]);

  return th;
}();
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var eh = Symbol("cloneAndPatchMaterial"),
    nh = Symbol("correlatedSceneGraph");

var ih = /*#__PURE__*/function (_Wc) {
  _inherits(ih, _Wc);

  var _super83 = _createSuper(ih);

  function ih() {
    _classCallCheck(this, ih);

    return _super83.apply(this, arguments);
  }

  _createClass(ih, [{
    key: "correlatedSceneGraph",
    get: function get() {
      return this[zc][nh];
    }
  }, {
    key: Vc,
    value: function value() {
      var _this86 = this;

      var t = _get(_getPrototypeOf(ih.prototype), Vc, this).call(this),
          e = new Map();

      return t.scene.traverse(function (t) {
        if (t.isMesh) {
          var n = t;
          Array.isArray(n.material) ? n.material = n.material.map(function (t) {
            return _this86[eh](t, e);
          }) : null != n.material && (n.material = _this86[eh](n.material, e));
        }
      }), t[nh] = th.from(t, this.correlatedSceneGraph), t;
    }
  }, {
    key: eh,
    value: function value(t, e) {
      if (e.has(t.uuid)) return e.get(t.uuid);
      var n = t.clone();
      null != t.map && (n.map = t.map.clone(), n.map.needsUpdate = !0), null != t.normalMap && (n.normalMap = t.normalMap.clone(), n.normalMap.needsUpdate = !0), null != t.emissiveMap && (n.emissiveMap = t.emissiveMap.clone(), n.emissiveMap.needsUpdate = !0);
      var i = null;

      if (null != t.roughnessMap && (i = t.roughnessMap.clone()), null != i) {
        i.needsUpdate = !0, n.roughnessMap = i;
        var _dh$singleton = dh.singleton,
            _t316 = _dh$singleton.threeRenderer,
            _e243 = _dh$singleton.roughnessMipmapper,
            _r135 = _t316.xr.enabled;
        _t316.xr.enabled = !1, _e243.generateMipmaps(n), _t316.xr.enabled = _r135;
      }

      t.roughnessMap === t.metalnessMap ? n.metalnessMap = i : null != t.metalnessMap && (n.metalnessMap = t.metalnessMap.clone(), n.metalnessMap.needsUpdate = !0), t.roughnessMap === t.aoMap ? n.aoMap = i : null != t.aoMap && (n.aoMap = t.aoMap.clone(), n.aoMap.needsUpdate = !0);
      var r = t.onBeforeCompile;
      return n.onBeforeCompile = t.isGLTFSpecularGlossinessMaterial ? function (t) {
        r(t, void 0), t.fragmentShader = t.fragmentShader.replace("#include <alphatest_fragment>", qc);
      } : function (t) {
        t.fragmentShader = t.fragmentShader.replace("#include <alphatest_fragment>", qc), r(t, void 0);
      }, n.shadowSide = 0, n.transparent && (n.depthWrite = !1), n.alphaTest || n.transparent || (n.alphaTest = -.5), e.set(t.uuid, n), n;
    }
  }], [{
    key: Hc,
    value: function value(t) {
      var e = _get(_getPrototypeOf(ih), Hc, this).call(this, t);

      null == e[nh] && (e[nh] = th.from(e));
      var n = e.scene,
          i = [];
      n.traverse(function (t) {
        if (t.renderOrder = 1e3, t.frustumCulled = !1, t.name || (t.name = t.uuid), !t.isMesh) return;
        t.castShadow = !0;
        var e = t;
        var n = !1;
        (Array.isArray(e.material) ? e.material : [e.material]).forEach(function (t) {
          t.isMeshStandardMaterial && t.transparent && 2 === t.side && (n = !0, t.side = 0);
        }), n && i.push(e);
      });

      for (var _i204 = 0, _i203 = i; _i204 < _i203.length; _i204++) {
        var _t317 = _i203[_i204];

        var _e244 = (Array.isArray(_t317.material) ? _t317.material : [_t317.material]).map(function (t) {
          var e = t.clone();
          return e.side = 1, e;
        }),
            _n220 = Array.isArray(_t317.material) ? _e244 : _e244[0],
            _i205 = _t317.clone();

        _i205.material = _n220, _i205.renderOrder = -1, _t317.parent.add(_i205);
      }

      return e;
    }
  }]);

  return ih;
}(Wc);
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var rh = /*#__PURE__*/function (_Mr2) {
  _inherits(rh, _Mr2);

  var _super84 = _createSuper(rh);

  function rh() {
    var _this87;

    _classCallCheck(this, rh);

    _this87 = _super84.call(this), _this87.position.y = -3.5;
    var t = new Xe();
    t.deleteAttribute("uv");
    var e = new cs({
      metalness: 0,
      side: 1
    }),
        n = new cs({
      metalness: 0
    }),
        i = new js(16777215, 500, 28, 2);
    i.position.set(.418, 16.199, .3), _this87.add(i);
    var r = new Ye(t, e);
    r.position.set(-.757, 13.219, .717), r.scale.set(31.713, 28.305, 28.591), _this87.add(r);
    var s = new Ye(t, n);
    s.position.set(-10.906, 2.009, 1.846), s.rotation.set(0, -.195, 0), s.scale.set(2.328, 7.905, 4.651), _this87.add(s);
    var a = new Ye(t, n);
    a.position.set(-5.607, -.754, -.758), a.rotation.set(0, .994, 0), a.scale.set(1.97, 1.534, 3.955), _this87.add(a);
    var o = new Ye(t, n);
    o.position.set(6.167, .857, 7.803), o.rotation.set(0, .561, 0), o.scale.set(3.927, 6.285, 3.687), _this87.add(o);
    var l = new Ye(t, n);
    l.position.set(-2.017, .018, 6.124), l.rotation.set(0, .333, 0), l.scale.set(2.002, 4.566, 2.064), _this87.add(l);
    var c = new Ye(t, n);
    c.position.set(2.291, -.756, -2.621), c.rotation.set(0, -.286, 0), c.scale.set(1.546, 1.552, 1.496), _this87.add(c);
    var h = new Ye(t, n);
    h.position.set(-2.193, -.369, -5.547), h.rotation.set(0, .516, 0), h.scale.set(3.875, 3.487, 2.986), _this87.add(h);
    var u = new Ye(t, _this87.createAreaLightMaterial(50));
    u.position.set(-16.116, 14.37, 8.208), u.scale.set(.1, 2.428, 2.739), _this87.add(u);
    var d = new Ye(t, _this87.createAreaLightMaterial(50));
    d.position.set(-16.109, 18.021, -8.207), d.scale.set(.1, 2.425, 2.751), _this87.add(d);
    var A = new Ye(t, _this87.createAreaLightMaterial(17));
    A.position.set(14.904, 12.198, -1.832), A.scale.set(.15, 4.265, 6.331), _this87.add(A);
    var p = new Ye(t, _this87.createAreaLightMaterial(43));
    p.position.set(-.462, 8.89, 14.52), p.scale.set(4.38, 5.441, .088), _this87.add(p);
    var g = new Ye(t, _this87.createAreaLightMaterial(20));
    g.position.set(3.235, 11.486, -12.541), g.scale.set(2.5, 2, .1), _this87.add(g);
    var m = new Ye(t, _this87.createAreaLightMaterial(100));
    m.position.set(0, 20, 0), m.scale.set(1, .1, 1), _this87.add(m);
    return _this87;
  }

  _createClass(rh, [{
    key: "createAreaLightMaterial",
    value: function createAreaLightMaterial(t) {
      var e = new ge();
      return e.color.setScalar(t), e;
    }
  }]);

  return rh;
}(Mr);
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var sh = /*#__PURE__*/function (_Mr3) {
  _inherits(sh, _Mr3);

  var _super85 = _createSuper(sh);

  function sh() {
    var _this88;

    _classCallCheck(this, sh);

    _this88 = _super85.call(this), _this88.position.y = -3.5;
    var t = new Xe();
    t.deleteAttribute("uv");
    var e = new cs({
      metalness: 0,
      side: 1
    }),
        n = new cs({
      metalness: 0
    }),
        i = new js(16777215, 400, 28, 2);
    i.position.set(.5, 14, .5), _this88.add(i);
    var r = new Ye(t, e);
    r.position.set(0, 13.2, 0), r.scale.set(31.5, 28.5, 31.5), _this88.add(r);
    var s = new Ye(t, n);
    s.position.set(-10.906, -1, 1.846), s.rotation.set(0, -.195, 0), s.scale.set(2.328, 7.905, 4.651), _this88.add(s);
    var a = new Ye(t, n);
    a.position.set(-5.607, -.754, -.758), a.rotation.set(0, .994, 0), a.scale.set(1.97, 1.534, 3.955), _this88.add(a);
    var o = new Ye(t, n);
    o.position.set(6.167, -.16, 7.803), o.rotation.set(0, .561, 0), o.scale.set(3.927, 6.285, 3.687), _this88.add(o);
    var l = new Ye(t, n);
    l.position.set(-2.017, .018, 6.124), l.rotation.set(0, .333, 0), l.scale.set(2.002, 4.566, 2.064), _this88.add(l);
    var c = new Ye(t, n);
    c.position.set(2.291, -.756, -2.621), c.rotation.set(0, -.286, 0), c.scale.set(1.546, 1.552, 1.496), _this88.add(c);
    var h = new Ye(t, n);
    h.position.set(-2.193, -.369, -5.547), h.rotation.set(0, .516, 0), h.scale.set(3.875, 3.487, 2.986), _this88.add(h);
    var u = new Ye(t, _this88.createAreaLightMaterial(80));
    u.position.set(-14, 10, 8), u.scale.set(.1, 2.5, 2.5), _this88.add(u);
    var d = new Ye(t, _this88.createAreaLightMaterial(80));
    d.position.set(-14, 14, -4), d.scale.set(.1, 2.5, 2.5), _this88.add(d);
    var A = new Ye(t, _this88.createAreaLightMaterial(23));
    A.position.set(14, 12, 0), A.scale.set(.1, 5, 5), _this88.add(A);
    var p = new Ye(t, _this88.createAreaLightMaterial(16));
    p.position.set(0, 9, 14), p.scale.set(5, 5, .1), _this88.add(p);
    var g = new Ye(t, _this88.createAreaLightMaterial(80));
    g.position.set(7, 8, -14), g.scale.set(2.5, 2.5, .1), _this88.add(g);
    var m = new Ye(t, _this88.createAreaLightMaterial(80));
    m.position.set(-7, 16, -14), m.scale.set(2.5, 2.5, .1), _this88.add(m);
    var f = new Ye(t, _this88.createAreaLightMaterial(1));
    f.position.set(0, 20, 0), f.scale.set(.1, .1, .1), _this88.add(f);
    return _this88;
  }

  _createClass(sh, [{
    key: "createAreaLightMaterial",
    value: function createAreaLightMaterial(t) {
      var e = new ge();
      return e.color.setScalar(t), e;
    }
  }]);

  return sh;
}(Mr);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ah = /\.hdr(\.js)?$/,
    oh = new Ps(),
    lh = new ( /*#__PURE__*/function (_Qs) {
  _inherits(_class7, _Qs);

  var _super86 = _createSuper(_class7);

  function _class7(t) {
    var _this89;

    _classCallCheck(this, _class7);

    _this89 = _super86.call(this, t), _this89.type = 1009;
    return _this89;
  }

  _createClass(_class7, [{
    key: "parse",
    value: function parse(t) {
      var e = function e(t, _e245) {
        switch (t) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (_e245 || ""));
            break;

          case 2:
            console.error("THREE.RGBELoader Write Error: " + (_e245 || ""));
            break;

          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (_e245 || ""));
            break;

          default:
          case 4:
            console.error("THREE.RGBELoader: Error: " + (_e245 || ""));
        }

        return -1;
      },
          n = function n(t, e, _n221) {
        e = e || 1024;
        var i = t.pos,
            r = -1,
            s = 0,
            a = "",
            o = String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));

        for (; 0 > (r = o.indexOf("\n")) && s < e && i < t.byteLength;) {
          a += o, s += o.length, i += 128, o += String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));
        }

        return -1 < r && (!1 !== _n221 && (t.pos += s + r + 1), a + o.slice(0, r));
      },
          i = function i(t, e, n, _i206) {
        var r = t[e + 3],
            s = Math.pow(2, r - 128) / 255;
        n[_i206 + 0] = t[e + 0] * s, n[_i206 + 1] = t[e + 1] * s, n[_i206 + 2] = t[e + 2] * s;
      },
          r = function r(t, e, n, i) {
        var r = t[e + 3],
            s = Math.pow(2, r - 128) / 255;
        n[i + 0] = xa.toHalfFloat(t[e + 0] * s), n[i + 1] = xa.toHalfFloat(t[e + 1] * s), n[i + 2] = xa.toHalfFloat(t[e + 2] * s);
      },
          s = new Uint8Array(t);

      s.pos = 0;

      var a = function (t) {
        var i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
            r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
            s = /^\s*FORMAT=(\S+)\s*$/,
            a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
            o = {
          valid: 0,
          string: "",
          comments: "",
          programtype: "RGBE",
          format: "",
          gamma: 1,
          exposure: 1,
          width: 0,
          height: 0
        };
        var l, c;
        if (t.pos >= t.byteLength || !(l = n(t))) return e(1, "no header found");
        if (!(c = l.match(/^#\?(\S+)/))) return e(3, "bad initial token");

        for (o.valid |= 1, o.programtype = c[1], o.string += l + "\n"; l = n(t), !1 !== l;) {
          if (o.string += l + "\n", "#" !== l.charAt(0)) {
            if ((c = l.match(i)) && (o.gamma = parseFloat(c[1], 10)), (c = l.match(r)) && (o.exposure = parseFloat(c[1], 10)), (c = l.match(s)) && (o.valid |= 2, o.format = c[1]), (c = l.match(a)) && (o.valid |= 4, o.height = parseInt(c[1], 10), o.width = parseInt(c[2], 10)), 2 & o.valid && 4 & o.valid) break;
          } else o.comments += l + "\n";
        }

        return 2 & o.valid ? 4 & o.valid ? o : e(3, "missing image size specifier") : e(3, "missing format specifier");
      }(s);

      if (-1 !== a) {
        var _t318 = a.width,
            _n222 = a.height,
            _o36 = function (t, n, i) {
          var r = n;
          if (r < 8 || r > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2]) return new Uint8Array(t);
          if (r !== (t[2] << 8 | t[3])) return e(3, "wrong scanline width");
          var s = new Uint8Array(4 * n * i);
          if (!s.length) return e(4, "unable to allocate buffer space");
          var a = 0,
              o = 0;
          var l = 4 * r,
              c = new Uint8Array(4),
              h = new Uint8Array(l);
          var u = i;

          for (; u > 0 && o < t.byteLength;) {
            if (o + 4 > t.byteLength) return e(1);
            if (c[0] = t[o++], c[1] = t[o++], c[2] = t[o++], c[3] = t[o++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != r) return e(3, "bad rgbe scanline format");

            var _n223 = void 0,
                _i207 = 0;

            for (; _i207 < l && o < t.byteLength;) {
              _n223 = t[o++];

              var _r136 = _n223 > 128;

              if (_r136 && (_n223 -= 128), 0 === _n223 || _i207 + _n223 > l) return e(3, "bad scanline data");

              if (_r136) {
                var _e246 = t[o++];

                for (var _t319 = 0; _t319 < _n223; _t319++) {
                  h[_i207++] = _e246;
                }
              } else h.set(t.subarray(o, o + _n223), _i207), _i207 += _n223, o += _n223;
            }

            var _d13 = r;

            for (var _t320 = 0; _t320 < _d13; _t320++) {
              var _e247 = 0;
              s[a] = h[_t320 + _e247], _e247 += r, s[a + 1] = h[_t320 + _e247], _e247 += r, s[a + 2] = h[_t320 + _e247], _e247 += r, s[a + 3] = h[_t320 + _e247], a += 4;
            }

            u--;
          }

          return s;
        }(s.subarray(s.pos), _t318, _n222);

        if (-1 !== _o36) {
          var _e248, _s72, _l37, _c31;

          switch (this.type) {
            case 1009:
              _e248 = _o36, _s72 = 1023, _l37 = 1009;
              break;

            case 1015:
              _c31 = _o36.length / 4 * 3;

              var _t321 = new Float32Array(_c31);

              for (var _e249 = 0; _e249 < _c31; _e249++) {
                i(_o36, 4 * _e249, _t321, 3 * _e249);
              }

              _e248 = _t321, _s72 = 1022, _l37 = 1015;
              break;

            case 1016:
              _c31 = _o36.length / 4 * 3;

              var _n224 = new Uint16Array(_c31);

              for (var _t322 = 0; _t322 < _c31; _t322++) {
                r(_o36, 4 * _t322, _n224, 3 * _t322);
              }

              _e248 = _n224, _s72 = 1022, _l37 = 1016;
              break;

            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }

          return {
            width: _t318,
            height: _n222,
            data: _e248,
            header: a.string,
            gamma: a.gamma,
            exposure: a.exposure,
            format: _s72,
            type: _l37
          };
        }
      }

      return null;
    }
  }, {
    key: "setDataType",
    value: function setDataType(t) {
      return this.type = t, this;
    }
  }, {
    key: "load",
    value: function load(t, e, n, i) {
      return _get(_getPrototypeOf(_class7.prototype), "load", this).call(this, t, function (t, n) {
        switch (t.type) {
          case 1009:
            t.encoding = 3002, t.minFilter = 1003, t.magFilter = 1003, t.generateMipmaps = !1, t.flipY = !0;
            break;

          case 1015:
          case 1016:
            t.encoding = 3e3, t.minFilter = 1006, t.magFilter = 1006, t.generateMipmaps = !1, t.flipY = !0;
        }

        e && e(t, n);
      }, n, i);
    }
  }]);

  return _class7;
}(Qs))(),
    ch = {
  url: null
};

var hh = /*#__PURE__*/function (_y12) {
  _inherits(hh, _y12);

  var _super87 = _createSuper(hh);

  function hh(t) {
    var _this90;

    _classCallCheck(this, hh);

    _this90 = _super87.call(this), _this90.generatedEnvironmentMap = null, _this90.generatedEnvironmentMapAlt = null, _this90.skyboxCache = new Map(), _this90.environmentMapCache = new Map(), _this90.PMREMGenerator = new Ua(t);
    return _this90;
  }

  _createClass(hh, [{
    key: "load",
    value: function () {
      var _load2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(t) {
        var e,
            n,
            _i208,
            _r137,
            _args16 = arguments;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                e = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : function () {};
                _context16.prev = 1;
                n = ah.test(t);
                _i208 = n ? lh : oh;
                _context16.next = 6;
                return new Promise(function (n, r) {
                  return _i208.load(t, n, function (t) {
                    e(t.loaded / t.total * .9);
                  }, r);
                });

              case 6:
                _r137 = _context16.sent;
                return _context16.abrupt("return", (e(1), this.addMetadata(_r137, t), _r137.mapping = 303, n ? (_r137.encoding = 3002, _r137.minFilter = 1003, _r137.magFilter = 1003, _r137.flipY = !0) : _r137.encoding = 3007, _r137));

              case 8:
                _context16.prev = 8;
                e && e(1);
                return _context16.finish(8);

              case 11:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[1,, 8, 11]]);
      }));

      function load(_x15) {
        return _load2.apply(this, arguments);
      }

      return load;
    }()
  }, {
    key: "generateEnvironmentMapAndSkybox",
    value: function () {
      var _generateEnvironmentMapAndSkybox = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
        var t,
            e,
            n,
            i,
            r,
            s,
            a,
            _e250,
            _n225,
            _yield$Promise$all,
            _yield$Promise$all2,
            _o37,
            _l38,
            _args17 = arguments;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                t = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : null;
                e = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : null;
                n = _args17.length > 2 && _args17[2] !== undefined ? _args17[2] : {};
                i = n.progressTracker, r = null != i ? i.beginActivity() : function () {}, s = "neutral" === e;
                !0 === s && (e = null);
                a = kl(e);
                _context17.prev = 6;
                _n225 = Promise.resolve(null);
                t && (_n225 = this.loadSkyboxFromUrl(t, i)), _e250 = a ? this.loadEnvironmentMapFromUrl(a, i) : t ? this.loadEnvironmentMapFromUrl(t, i) : !0 === s ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
                _context17.next = 11;
                return Promise.all([_e250, _n225]);

              case 11:
                _yield$Promise$all = _context17.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                _o37 = _yield$Promise$all2[0];
                _l38 = _yield$Promise$all2[1];

                if (!(null == _o37)) {
                  _context17.next = 17;
                  break;
                }

                throw new Error("Failed to load environment map.");

              case 17:
                return _context17.abrupt("return", {
                  environmentMap: _o37,
                  skybox: _l38
                });

              case 18:
                _context17.prev = 18;
                r(1);
                return _context17.finish(18);

              case 21:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this, [[6,, 18, 21]]);
      }));

      function generateEnvironmentMapAndSkybox() {
        return _generateEnvironmentMapAndSkybox.apply(this, arguments);
      }

      return generateEnvironmentMapAndSkybox;
    }()
  }, {
    key: "addMetadata",
    value: function addMetadata(t, e) {
      null != t && (t.userData = Object.assign(Object.assign({}, ch), {
        url: e
      }));
    }
  }, {
    key: "loadSkyboxFromUrl",
    value: function loadSkyboxFromUrl(t, e) {
      if (!this.skyboxCache.has(t)) {
        var n = e ? e.beginActivity() : function () {},
            _i209 = this.load(t, n);

        this.skyboxCache.set(t, _i209);
      }

      return this.skyboxCache.get(t);
    }
  }, {
    key: "loadEnvironmentMapFromUrl",
    value: function loadEnvironmentMapFromUrl(t, e) {
      var _this91 = this;

      if (!this.environmentMapCache.has(t)) {
        var n = this.loadSkyboxFromUrl(t, e).then(function (e) {
          var n = _this91.PMREMGenerator.fromEquirectangular(e);

          return _this91.addMetadata(n.texture, t), n;
        });
        this.PMREMGenerator.compileEquirectangularShader(), this.environmentMapCache.set(t, n);
      }

      return this.environmentMapCache.get(t);
    }
  }, {
    key: "loadGeneratedEnvironmentMap",
    value: function loadGeneratedEnvironmentMap() {
      if (null == this.generatedEnvironmentMap) {
        var _t323 = new rh();

        this.generatedEnvironmentMap = this.PMREMGenerator.fromScene(_t323, .04), this.addMetadata(this.generatedEnvironmentMap.texture, null);
      }

      return Promise.resolve(this.generatedEnvironmentMap);
    }
  }, {
    key: "loadGeneratedEnvironmentMapAlt",
    value: function loadGeneratedEnvironmentMapAlt() {
      if (null == this.generatedEnvironmentMapAlt) {
        var _t324 = new sh();

        this.generatedEnvironmentMapAlt = this.PMREMGenerator.fromScene(_t324, .04), this.addMetadata(this.generatedEnvironmentMapAlt.texture, null);
      }

      return Promise.resolve(this.generatedEnvironmentMapAlt);
    }
  }, {
    key: "dispose",
    value: function () {
      var _dispose = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        var t, _i210, _t325, _e251;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                t = [];
                this.environmentMapCache.forEach(function (e) {
                  t.push(e);
                }), this.environmentMapCache.clear();
                _i210 = 0, _t325 = t;

              case 3:
                if (!(_i210 < _t325.length)) {
                  _context18.next = 16;
                  break;
                }

                _e251 = _t325[_i210];
                _context18.prev = 5;
                _context18.next = 8;
                return _e251;

              case 8:
                _context18.sent.dispose();

                _context18.next = 13;
                break;

              case 11:
                _context18.prev = 11;
                _context18.t0 = _context18["catch"](5);

              case 13:
                _i210++;
                _context18.next = 3;
                break;

              case 16:
                null != this.generatedEnvironmentMap && (this.generatedEnvironmentMap.dispose(), this.generatedEnvironmentMap = null), null != this.generatedEnvironmentMapAlt && (this.generatedEnvironmentMapAlt.dispose(), this.generatedEnvironmentMapAlt = null);

              case 17:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[5, 11]]);
      }));

      function dispose() {
        return _dispose.apply(this, arguments);
      }

      return dispose;
    }()
  }]);

  return hh;
}(y);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var uh = [1, .79, .62, .5, .4, .31, .25];

var dh = /*#__PURE__*/function (_y13) {
  _inherits(dh, _y13);

  var _super88 = _createSuper(dh);

  function dh(t) {
    var _this92;

    _classCallCheck(this, dh);

    _this92 = _super88.call(this), _this92.loader = new Rl(ih), _this92.width = 0, _this92.height = 0, _this92.dpr = 1, _this92.debugger = null, _this92.scenes = new Set(), _this92.multipleScenesVisible = !1, _this92.scaleStep = 0, _this92.lastStep = 3, _this92.avgFrameDuration = 22, _this92.onWebGLContextLost = function (t) {
      _this92.dispatchEvent({
        type: "contextlost",
        sourceEvent: t
      });
    }, _this92.dpr = Wl(), _this92.canvasElement = document.createElement("canvas"), _this92.canvasElement.id = "webgl-canvas", _this92.canvas3D = _this92.canvasElement, _this92.canvas3D.addEventListener("webglcontextlost", _this92.onWebGLContextLost);

    try {
      _this92.threeRenderer = new Cr({
        canvas: _this92.canvas3D,
        alpha: !0,
        antialias: !0,
        powerPreference: "high-performance",
        preserveDrawingBuffer: !0
      }), _this92.threeRenderer.autoClear = !0, _this92.threeRenderer.outputEncoding = 3007, _this92.threeRenderer.physicallyCorrectLights = !0, _this92.threeRenderer.setPixelRatio(1), _this92.threeRenderer.shadowMap.enabled = !0, _this92.threeRenderer.shadowMap.type = 2, _this92.threeRenderer.shadowMap.autoUpdate = !1, _this92.debugger = null != t && t.debug ? new Gc(_assertThisInitialized(_this92)) : null, _this92.threeRenderer.debug = {
        checkShaderErrors: !!_this92.debugger
      }, _this92.threeRenderer.toneMapping = 4;
    } catch (t) {
      console.warn(t);
    }

    _this92.arRenderer = new Uc(_assertThisInitialized(_this92)), _this92.textureUtils = _this92.canRender ? new hh(_this92.threeRenderer) : null, _this92.roughnessMipmapper = new _c(_this92.threeRenderer), Rl.initializeKTX2Loader(_this92.threeRenderer), _this92.updateRendererSize(), _this92.lastTick = performance.now(), _this92.avgFrameDuration = 0;
    return _this92;
  }

  _createClass(dh, [{
    key: "canRender",
    get: function get() {
      return null != this.threeRenderer;
    }
  }, {
    key: "scaleFactor",
    get: function get() {
      return uh[this.scaleStep];
    }
  }, {
    key: "minScale",
    set: function set(t) {
      var e = 1;

      for (; e < uh.length && !(uh[e] < t);) {
        ++e;
      }

      this.lastStep = e - 1;
    }
  }, {
    key: "updateRendererSize",
    value: function updateRendererSize() {
      var t = Wl();

      if (t !== this.dpr) {
        var _iterator8 = _createForOfIteratorHelper(this.scenes),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var _t326 = _step8.value;
            var _e252 = _t326.element;

            _e252[Gh](_e252.getBoundingClientRect());
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }

      var e = 0,
          n = 0;

      var _iterator9 = _createForOfIteratorHelper(this.scenes),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var _t327 = _step9.value;
          e = Math.max(e, _t327.width), n = Math.max(n, _t327.height);
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      if (e === this.width && n === this.height && t === this.dpr) return;
      this.width = e, this.height = n, this.dpr = t, this.canRender && this.threeRenderer.setSize(e * t, n * t, !1);
      var i = this.scaleFactor,
          r = e / i,
          s = n / i;
      this.canvasElement.style.width = "".concat(r, "px"), this.canvasElement.style.height = "".concat(s, "px");

      var _iterator10 = _createForOfIteratorHelper(this.scenes),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _i211 = _step10.value;
          var _a57 = _i211.canvas;
          _a57.width = Math.round(e * t), _a57.height = Math.round(n * t), _a57.style.width = "".concat(r, "px"), _a57.style.height = "".concat(s, "px"), _i211.isDirty = !0;
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  }, {
    key: "updateRendererScale",
    value: function updateRendererScale() {
      var t = this.scaleStep;
      if (this.avgFrameDuration > 26 && this.scaleStep < this.lastStep ? ++this.scaleStep : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep, t == this.scaleStep) return;
      var e = this.scaleFactor;
      this.avgFrameDuration = 22;
      var n = this.width / e,
          i = this.height / e;
      this.canvasElement.style.width = "".concat(n, "px"), this.canvasElement.style.height = "".concat(i, "px");

      var _iterator11 = _createForOfIteratorHelper(this.scenes),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _t328 = _step11.value;
          var _e253 = _t328.canvas.style;
          _e253.width = "".concat(n, "px"), _e253.height = "".concat(i, "px"), _t328.isDirty = !0;
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    }
  }, {
    key: "registerScene",
    value: function registerScene(t) {
      var _this93 = this;

      this.scenes.add(t);
      var e = t.canvas,
          n = this.scaleFactor;
      e.width = Math.round(this.width * this.dpr), e.height = Math.round(this.height * this.dpr), e.style.width = this.width / n + "px", e.style.height = this.height / n + "px", this.multipleScenesVisible && e.classList.add("show"), t.isDirty = !0, this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop(function (t, e) {
        return _this93.render(t, e);
      }), null != this.debugger && this.debugger.addScene(t);
    }
  }, {
    key: "unregisterScene",
    value: function unregisterScene(t) {
      this.scenes.delete(t), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null), null != this.debugger && this.debugger.removeScene(t);
    }
  }, {
    key: "displayCanvas",
    value: function displayCanvas(t) {
      return this.multipleScenesVisible ? t.element[Jh] : this.canvasElement;
    }
  }, {
    key: "selectCanvas",
    value: function selectCanvas() {
      var t = 0,
          e = null;

      var _iterator12 = _createForOfIteratorHelper(this.scenes),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var _n226 = _step12.value;
          var _i212 = _n226.element;
          _i212.modelIsVisible && null == _n226.externalRenderer && (++t, e = _n226.canvas);
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      if (null == e) return;
      var n = t > 1 || false,
          i = this.canvasElement;

      if (n !== this.multipleScenesVisible || !n && i.parentElement !== e.parentElement) {
        this.multipleScenesVisible = n, n && i.classList.remove("show");

        var _iterator13 = _createForOfIteratorHelper(this.scenes),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _t329 = _step13.value;
            if (null != _t329.externalRenderer) continue;
            var _r138 = _t329.element[Jh];
            n ? (_r138.classList.add("show"), _t329.isDirty = !0) : _t329.canvas === e && (_t329.canvas.parentElement.appendChild(i), i.classList.add("show"), _r138.classList.remove("show"), _t329.isDirty = !0);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }
    }
  }, {
    key: "orderedScenes",
    value: function orderedScenes() {
      var t = [];

      for (var _i213 = 0, _arr2 = [!1, !0]; _i213 < _arr2.length; _i213++) {
        var _e254 = _arr2[_i213];

        var _iterator14 = _createForOfIteratorHelper(this.scenes),
            _step14;

        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
            var n = _step14.value;
            n.element.modelIsVisible === _e254 && t.push(n);
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
      }

      return t;
    }
  }, {
    key: "isPresenting",
    get: function get() {
      return this.arRenderer.isPresenting;
    }
  }, {
    key: "preRender",
    value: function preRender(t, e, n) {
      var i = t.element,
          r = t.exposure;
      i[Zh](e, n);
      var s = "number" == typeof r && !self.isNaN(r);
      this.threeRenderer.toneMappingExposure = s ? r : 1, t.isShadowDirty() && (this.threeRenderer.shadowMap.needsUpdate = !0);
    }
  }, {
    key: "render",
    value: function render(t, e) {
      if (null != e) return this.arRenderer.onWebXRFrame(t, e), void this.arRenderer.presentedScene.postRender();
      var n = t - this.lastTick;
      if (this.lastTick = t, !this.canRender || this.isPresenting) return;
      this.avgFrameDuration += Vl(.2 * (n - this.avgFrameDuration), -2, 2), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale();
      var i = this.dpr,
          r = this.scaleFactor;

      var _iterator15 = _createForOfIteratorHelper(this.orderedScenes()),
          _step15;

      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var _e255 = _step15.value;
          var _s73 = _e255.element;
          if (!_s73.modelIsVisible && _e255.renderCount > 0) continue;
          if (this.preRender(_e255, t, n), !_e255.isDirty) continue;

          if (null != _e255.externalRenderer) {
            _e255.camera.updateMatrix();

            var _e255$camera = _e255.camera,
                _t330 = _e255$camera.matrix,
                _n227 = _e255$camera.projectionMatrix,
                _i214 = _t330.elements.slice(),
                _r139 = _e255.getTarget();

            _i214[12] += _r139.x, _i214[13] += _r139.y, _i214[14] += _r139.z, _e255.externalRenderer.render({
              viewMatrix: _i214,
              projectionMatrix: _n227.elements
            });
            continue;
          }

          if (!_s73.modelIsVisible && !this.multipleScenesVisible) {
            var _iterator16 = _createForOfIteratorHelper(this.scenes),
                _step16;

            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var _t331 = _step16.value;
                _t331.element.modelIsVisible && (_t331.isDirty = !0);
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
          }

          var _a58 = Math.min(Math.ceil(_e255.width * r * i), this.canvas3D.width),
              _o38 = Math.min(Math.ceil(_e255.height * r * i), this.canvas3D.height);

          if (this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * i) - _o38, _a58, _o38), this.threeRenderer.render(_e255, _e255.camera), _e255.postRender(), this.multipleScenesVisible) {
            null == _e255.context && _e255.createContext();
            {
              var _t332 = _e255.context;
              _t332.clearRect(0, 0, _a58, _o38), _t332.drawImage(this.canvas3D, 0, 0, _a58, _o38, 0, 0, _a58, _o38);
            }
          }

          _e255.isDirty = !1, _s73.loaded && ++_e255.renderCount;
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      null != this.textureUtils && this.textureUtils.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null, this.scenes.clear(), this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost);
    }
  }], [{
    key: "singleton",
    get: function get() {
      return this._singleton;
    }
  }, {
    key: "resetSingleton",
    value: function resetSingleton() {
      this._singleton.dispose(), this._singleton = new dh({
        debug: ql()
      });
    }
  }]);

  return dh;
}(y);

dh._singleton = new dh({
  debug: ql()
});
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ah, ph;
var gh = Symbol("ongoingActivities"),
    mh = Symbol("announceTotalProgress"),
    fh = Symbol("eventDelegate");

var vh = /*#__PURE__*/function () {
  function vh() {
    var _this94 = this;

    _classCallCheck(this, vh);

    this[Ah] = document.createDocumentFragment(), this.addEventListener = function () {
      var _this94$fh;

      return (_this94$fh = _this94[fh]).addEventListener.apply(_this94$fh, arguments);
    }, this.removeEventListener = function () {
      var _this94$fh2;

      return (_this94$fh2 = _this94[fh]).removeEventListener.apply(_this94$fh2, arguments);
    }, this.dispatchEvent = function () {
      var _this94$fh3;

      return (_this94$fh3 = _this94[fh]).dispatchEvent.apply(_this94$fh3, arguments);
    }, this[ph] = new Set();
  }

  _createClass(vh, [{
    key: "ongoingActivityCount",
    get: function get() {
      return this[gh].size;
    }
  }, {
    key: "beginActivity",
    value: function beginActivity() {
      var _this95 = this;

      var t = {
        progress: 0
      };
      return this[gh].add(t), 1 === this.ongoingActivityCount && this[mh](), function (e) {
        var n;
        return n = Math.max(Vl(e, 0, 1), t.progress), n !== t.progress && (t.progress = n, _this95[mh]()), t.progress;
      };
    }
  }, {
    key: (Ah = fh, ph = gh, mh),
    value: function value() {
      var t = 0,
          e = 0,
          n = 0;

      var _iterator17 = _createForOfIteratorHelper(this[gh]),
          _step17;

      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var _i215 = _step17.value;
          var _r140 = _i215.progress;
          t += _r140 * (.5 / Math.pow(2, e++)), 1 === _r140 && n++;
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }

      n === this.ongoingActivityCount && (t = 1, this[gh].clear()), this.dispatchEvent(new CustomEvent("progress", {
        detail: {
          totalProgress: t
        }
      }));
    }
  }]);

  return vh;
}();
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var yh,
    Eh,
    xh,
    wh,
    bh,
    _h,
    Ih,
    Ch,
    Mh,
    Sh,
    Bh = function Bh(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var Th = document.createElement("canvas");
var Lh = null;

var Rh = Symbol("template"),
    Dh = Symbol("fallbackResizeHandler"),
    Qh = Symbol("defaultAriaLabel"),
    Ph = Symbol("resizeObserver"),
    Fh = Symbol("clearModelTimeout"),
    Nh = Symbol("onContextLost"),
    Uh = Symbol("loaded"),
    Gh = Symbol("updateSize"),
    kh = Symbol("intersectionObserver"),
    Oh = Symbol("isElementInViewport"),
    Hh = Symbol("announceModelVisibility"),
    zh = Symbol("ariaLabel"),
    Vh = Symbol("loadedTime"),
    Wh = Symbol("updateSource"),
    qh = Symbol("markLoaded"),
    jh = Symbol("container"),
    Yh = Symbol("input"),
    Jh = Symbol("canvas"),
    Xh = Symbol("scene"),
    Kh = Symbol("needsRender"),
    Zh = Symbol("tick"),
    $h = Symbol("onModelLoad"),
    tu = Symbol("onResize"),
    eu = Symbol("renderer"),
    nu = Symbol("progressTracker"),
    iu = Symbol("getLoaded"),
    ru = Symbol("getModelIsVisible"),
    su = Symbol("shouldAttemptPreload"),
    au = Symbol("sceneIsReady"),
    ou = Symbol("hasTransitioned"),
    lu = function lu(t) {
  return {
    x: t.x,
    y: t.y,
    z: t.z,
    toString: function toString() {
      return "".concat(this.x, "m ").concat(this.y, "m ").concat(this.z, "m");
    }
  };
};

var cu = /*#__PURE__*/function (_r141) {
  _inherits(cu, _r141);

  var _super89 = _createSuper(cu);

  function cu() {
    var _this96;

    _classCallCheck(this, cu);

    _this96 = _super89.call(this), _this96.alt = null, _this96.src = null, _this96[yh] = !1, _this96[Eh] = !1, _this96[xh] = 0, _this96[wh] = null, _this96[bh] = zl(function () {
      var t = _this96.getBoundingClientRect();

      _this96[Gh](t);
    }, 50), _this96[_h] = zl(function (t) {
      var e = _this96.modelIsVisible;
      e !== t && _this96.dispatchEvent(new CustomEvent("model-visibility", {
        detail: {
          visible: e
        }
      }));
    }, 0), _this96[Ih] = null, _this96[Ch] = null, _this96[Mh] = new vh(), _this96[Sh] = function (t) {
      _this96.dispatchEvent(new CustomEvent("error", {
        detail: {
          type: "webglcontextlost",
          sourceError: t.sourceEvent
        }
      }));
    };
    var t = _this96.constructor.template;
    window.ShadyCSS && window.ShadyCSS.styleElement(_assertThisInitialized(_this96), {}), _this96.attachShadow({
      mode: "open"
    });
    var e = _this96.shadowRoot;
    var n, i;

    if (e.appendChild(t.content.cloneNode(!0)), _this96[jh] = e.querySelector(".container"), _this96[Yh] = e.querySelector(".userInput"), _this96[Jh] = e.querySelector("canvas"), _this96[Qh] = _this96[Yh].getAttribute("aria-label"), _this96.isConnected) {
      var _t333 = _this96.getBoundingClientRect();

      n = _t333.width, i = _t333.height;
    } else n = 300, i = 150;

    _this96[Xh] = new vc({
      canvas: _this96[Jh],
      element: _assertThisInitialized(_this96),
      width: n,
      height: i
    }), _this96[Xh].addEventListener("model-load", /*#__PURE__*/function () {
      var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(t) {
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _this96[qh]();

                _this96[$h]();

                _context19.next = 4;
                return function () {
                  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                  return new Promise(function (e) {
                    return setTimeout(e, t);
                  });
                }();

              case 4:
                _this96.dispatchEvent(new CustomEvent("load", {
                  detail: {
                    url: t.url
                  }
                }));

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }));

      return function (_x16) {
        return _ref12.apply(this, arguments);
      };
    }()), Promise.resolve().then(function () {
      _this96[Gh](_this96.getBoundingClientRect());
    }), c && (_this96[Ph] = new ResizeObserver(function (t) {
      if (!_this96[eu].isPresenting) {
        var _iterator18 = _createForOfIteratorHelper(t),
            _step18;

        try {
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            var _e256 = _step18.value;
            _e256.target === _assertThisInitialized(_this96) && _this96[Gh](_e256.contentRect);
          }
        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }
      }
    })), h ? _this96[kh] = new IntersectionObserver(function (t) {
      var _iterator19 = _createForOfIteratorHelper(t),
          _step19;

      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var _e257 = _step19.value;

          if (_e257.target === _assertThisInitialized(_this96)) {
            var _t334 = _this96.modelIsVisible;
            _this96[Oh] = _e257.isIntersecting, _this96[Hh](_t334), _this96[Oh] && !_this96[au]() && _this96[Wh]();
          }
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }
    }, {
      root: null,
      rootMargin: "0px",
      threshold: 0
    }) : _this96[Oh] = !0;
    return _this96;
  }

  _createClass(cu, [{
    key: "loaded",
    get: function get() {
      return this[iu]();
    }
  }, {
    key: (yh = Oh, Eh = Uh, xh = Vh, wh = Fh, bh = Dh, _h = Hh, Ih = Ph, Ch = kh, Mh = nu, eu),
    get: function get() {
      return dh.singleton;
    }
  }, {
    key: "modelIsVisible",
    get: function get() {
      return this[ru]();
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      _get(_getPrototypeOf(cu.prototype), "connectedCallback", this) && _get(_getPrototypeOf(cu.prototype), "connectedCallback", this).call(this), c ? this[Ph].observe(this) : self.addEventListener("resize", this[Dh]), h && this[kh].observe(this);
      var t = this[eu];
      t.addEventListener("contextlost", this[Nh]), t.registerScene(this[Xh]), null != this[Fh] && (self.clearTimeout(this[Fh]), this[Fh] = null, this.requestUpdate("src", null));
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      var _this97 = this;

      _get(_getPrototypeOf(cu.prototype), "disconnectedCallback", this) && _get(_getPrototypeOf(cu.prototype), "disconnectedCallback", this).call(this), c ? this[Ph].unobserve(this) : self.removeEventListener("resize", this[Dh]), h && this[kh].unobserve(this);
      var t = this[eu];
      t.removeEventListener("contextlost", this[Nh]), t.unregisterScene(this[Xh]), this[Fh] = self.setTimeout(function () {
        _this97[Xh].reset();
      }, 1e3);
    }
  }, {
    key: "updated",
    value: function updated(t) {
      if (_get(_getPrototypeOf(cu.prototype), "updated", this).call(this, t), t.has("src") && (null == this.src ? (this[Uh] = !1, this[Vh] = 0, this[Xh].reset()) : this.src !== this[Xh].url && (this[Uh] = !1, this[Vh] = 0, this[Wh]())), t.has("alt")) {
        var _t335 = null == this.alt ? this[Qh] : this.alt;

        this[Yh].setAttribute("aria-label", _t335);
      }
    }
  }, {
    key: "toDataURL",
    value: function toDataURL(t, e) {
      return this[eu].displayCanvas(this[Xh]).toDataURL(t, e);
    }
  }, {
    key: "toBlob",
    value: function () {
      var _toBlob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(t) {
        var _this98 = this;

        var e, n, i, _this$Xh, r, s, a, o, _this$eu, l, c, h, u, d, A, _t336, _t337;

        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                e = t ? t.mimeType : void 0, n = t ? t.qualityArgument : void 0, i = t ? t.idealAspect : void 0, _this$Xh = this[Xh], r = _this$Xh.width, s = _this$Xh.height, a = _this$Xh.fieldOfViewAspect, o = _this$Xh.aspect, _this$eu = this[eu], l = _this$eu.dpr, c = _this$eu.scaleFactor;
                h = r * c * l, u = s * c * l, d = 0, A = 0;
                if (!0 === i) if (a > o) {
                  _t336 = u;
                  u = Math.round(h / a), A = (_t336 - u) / 2;
                } else {
                  _t337 = h;
                  h = Math.round(u * a), d = (_t337 - h) / 2;
                }
                Th.width = h, Th.height = u;
                _context22.prev = 4;
                return _context22.abrupt("return", new Promise( /*#__PURE__*/function () {
                  var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(t, i) {
                    return regeneratorRuntime.wrap(function _callee21$(_context21) {
                      while (1) {
                        switch (_context21.prev = _context21.next) {
                          case 0:
                            null == Lh && (Lh = Th.getContext("2d"));
                            Lh.drawImage(_this98[eu].displayCanvas(_this98[Xh]), d, A, h, u, 0, 0, h, u);

                            if (!(!Th.msToBlob || e && "image/png" !== e)) {
                              _context21.next = 15;
                              break;
                            }

                            if (!Th.toBlob) {
                              _context21.next = 7;
                              break;
                            }

                            _context21.t1 = void Th.toBlob(function (e) {
                              if (!e) return i(new Error("Unable to retrieve canvas blob"));
                              t(e);
                            }, e, n);
                            _context21.next = 12;
                            break;

                          case 7:
                            _context21.t2 = t;
                            _context21.next = 10;
                            return function () {
                              var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(t) {
                                return regeneratorRuntime.wrap(function _callee20$(_context20) {
                                  while (1) {
                                    switch (_context20.prev = _context20.next) {
                                      case 0:
                                        return _context20.abrupt("return", new Promise(function (e, n) {
                                          var i = t.match(/data:(.*);/);
                                          if (!i) return n(new Error("".concat(t, " is not a valid data Url")));
                                          var r = i[1],
                                              s = t.replace(/data:image\/\w+;base64,/, ""),
                                              a = atob(s),
                                              o = [];

                                          for (var _t338 = 0; _t338 < a.length; _t338 += 512) {
                                            var _e258 = a.slice(_t338, _t338 + 512),
                                                _n228 = new Array(_e258.length);

                                            for (var _t339 = 0; _t339 < _e258.length; _t339++) {
                                              _n228[_t339] = _e258.charCodeAt(_t339);
                                            }

                                            var _i216 = new Uint8Array(_n228);

                                            o.push(_i216);
                                          }

                                          e(new Blob(o, {
                                            type: r
                                          }));
                                        }));

                                      case 1:
                                      case "end":
                                        return _context20.stop();
                                    }
                                  }
                                }, _callee20);
                              }));

                              return function (_x20) {
                                return _ref14.apply(this, arguments);
                              };
                            }()(Th.toDataURL(e, n));

                          case 10:
                            _context21.t3 = _context21.sent;
                            _context21.t1 = (0, _context21.t2)(_context21.t3);

                          case 12:
                            _context21.t0 = _context21.t1;
                            _context21.next = 16;
                            break;

                          case 15:
                            _context21.t0 = t(Th.msToBlob());

                          case 16:
                            return _context21.abrupt("return", _context21.t0);

                          case 17:
                          case "end":
                            return _context21.stop();
                        }
                      }
                    }, _callee21);
                  }));

                  return function (_x18, _x19) {
                    return _ref13.apply(this, arguments);
                  };
                }()));

              case 6:
                _context22.prev = 6;
                this[Gh]({
                  width: r,
                  height: s
                });
                return _context22.finish(6);

              case 9:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this, [[4,, 6, 9]]);
      }));

      function toBlob(_x17) {
        return _toBlob.apply(this, arguments);
      }

      return toBlob;
    }()
  }, {
    key: "registerRenderer",
    value: function registerRenderer(t) {
      this[Xh].externalRenderer = t;
    }
  }, {
    key: "unregisterRenderer",
    value: function unregisterRenderer() {
      this[Xh].externalRenderer = null;
    }
  }, {
    key: zh,
    get: function get() {
      return null == this.alt || "null" === this.alt ? this[Qh] : this.alt;
    }
  }, {
    key: iu,
    value: function value() {
      return this[Uh];
    }
  }, {
    key: ru,
    value: function value() {
      return this.loaded && this[Oh];
    }
  }, {
    key: ou,
    value: function value() {
      return this.modelIsVisible;
    }
  }, {
    key: su,
    value: function value() {
      return !!this.src && this[Oh];
    }
  }, {
    key: au,
    value: function value() {
      return this[Uh];
    }
  }, {
    key: Gh,
    value: function value(_ref15) {
      var t = _ref15.width,
          e = _ref15.height;
      this[jh].style.width = "".concat(t, "px"), this[jh].style.height = "".concat(e, "px"), this[tu]({
        width: parseFloat(t),
        height: parseFloat(e)
      });
    }
  }, {
    key: Zh,
    value: function value(t, e) {}
  }, {
    key: qh,
    value: function value() {
      this[Uh] || (this[Uh] = !0, this[Vh] = performance.now());
    }
  }, {
    key: Kh,
    value: function value() {
      this[Xh].isDirty = !0;
    }
  }, {
    key: $h,
    value: function value() {}
  }, {
    key: tu,
    value: function value(t) {
      this[Xh].setSize(t.width, t.height);
    }
  }, {
    key: (Sh = Nh, Wh),
    value: function () {
      var _value = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
        var t, e, n;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(this.loaded || !this[su]())) {
                  _context23.next = 2;
                  break;
                }

                return _context23.abrupt("return");

              case 2:
                t = this[nu].beginActivity(), e = this.src;
                _context23.prev = 3;
                _context23.next = 6;
                return this[Xh].setSource(e, function (e) {
                  return t(.8 * e);
                });

              case 6:
                n = {
                  url: e
                };
                this.dispatchEvent(new CustomEvent("preload", {
                  detail: n
                }));
                _context23.next = 13;
                break;

              case 10:
                _context23.prev = 10;
                _context23.t0 = _context23["catch"](3);
                this.dispatchEvent(new CustomEvent("error", {
                  detail: _context23.t0
                }));

              case 13:
                _context23.prev = 13;
                t(.9), requestAnimationFrame(function () {
                  requestAnimationFrame(function () {
                    t(1);
                  });
                });
                return _context23.finish(13);

              case 16:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this, [[3, 10, 13, 16]]);
      }));

      function value() {
        return _value.apply(this, arguments);
      }

      return value;
    }()
  }], [{
    key: "is",
    get: function get() {
      return "model-viewer";
    }
  }, {
    key: "template",
    get: function get() {
      return this.hasOwnProperty(Rh) || (this[Rh] = function (t) {
        var e = document.createElement("template");
        return e.innerHTML = v.innerHTML, window.ShadyCSS && window.ShadyCSS.prepareTemplate(e, t), e;
      }(this.is)), this[Rh];
    }
  }, {
    key: "modelCacheSize",
    get: function get() {
      return Rl[Tl].evictionThreshold;
    },
    set: function set(t) {
      Rl[Tl].evictionThreshold = t;
    }
  }, {
    key: "minimumRenderScale",
    get: function get() {
      return dh.singleton.minScale;
    },
    set: function set(t) {
      t > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), t <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."), dh.singleton.minScale = t;
    }
  }]);

  return cu;
}(r);

Bh([a({
  type: String
})], cu.prototype, "alt", void 0), Bh([a({
  type: String
})], cu.prototype, "src", void 0);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var hu = function hu(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var uu = Symbol("changeAnimation"),
    du = Symbol("paused"),
    Au = Symbol("hotspotMap"),
    pu = Symbol("mutationCallback"),
    gu = Symbol("observer"),
    mu = Symbol("addHotspot"),
    fu = Symbol("removeHotspot"),
    vu = new R(),
    yu = new yt(),
    Eu = new D();
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/

var xu = function xu(t) {
  return URL.createObjectURL(new Blob([t], {
    type: "text/javascript"
  }));
};

try {
  URL.revokeObjectURL(xu(""));
} catch (Wo) {
  xu = function xu(t) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(t);
  };
}

var wu = Uint8Array,
    bu = Uint16Array,
    _u = Uint32Array,
    Iu = new wu([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
    Cu = new wu([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
    Mu = new wu([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    Su = function Su(t, e) {
  for (var n = new bu(31), i = 0; i < 31; ++i) {
    n[i] = e += 1 << t[i - 1];
  }

  var r = new _u(n[30]);

  for (i = 1; i < 30; ++i) {
    for (var s = n[i]; s < n[i + 1]; ++s) {
      r[s] = s - n[i] << 5 | i;
    }
  }

  return [n, r];
},
    Bu = Su(Iu, 2),
    Tu = Bu[0],
    Lu = Bu[1];

Tu[28] = 258, Lu[258] = 28;

for (var Ru = Su(Cu, 0)[1], Du = new bu(32768), Qu = 0; Qu < 32768; ++Qu) {
  var Pu = (43690 & Qu) >>> 1 | (21845 & Qu) << 1;
  Pu = (61680 & (Pu = (52428 & Pu) >>> 2 | (13107 & Pu) << 2)) >>> 4 | (3855 & Pu) << 4, Du[Qu] = ((65280 & Pu) >>> 8 | (255 & Pu) << 8) >>> 1;
}

var Fu = function Fu(t, e, n) {
  for (var i = t.length, r = 0, s = new bu(e); r < i; ++r) {
    ++s[t[r] - 1];
  }

  var a,
      o = new bu(e);

  for (r = 0; r < e; ++r) {
    o[r] = o[r - 1] + s[r - 1] << 1;
  }

  if (n) {
    a = new bu(1 << e);
    var l = 15 - e;

    for (r = 0; r < i; ++r) {
      if (t[r]) for (var c = r << 4 | t[r], h = e - t[r], u = o[t[r] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u) {
        a[Du[u] >>> l] = c;
      }
    }
  } else for (a = new bu(i), r = 0; r < i; ++r) {
    t[r] && (a[r] = Du[o[t[r] - 1]++] >>> 15 - t[r]);
  }

  return a;
},
    Nu = new wu(288);

for (Qu = 0; Qu < 144; ++Qu) {
  Nu[Qu] = 8;
}

for (Qu = 144; Qu < 256; ++Qu) {
  Nu[Qu] = 9;
}

for (Qu = 256; Qu < 280; ++Qu) {
  Nu[Qu] = 7;
}

for (Qu = 280; Qu < 288; ++Qu) {
  Nu[Qu] = 8;
}

var Uu = new wu(32);

for (Qu = 0; Qu < 32; ++Qu) {
  Uu[Qu] = 5;
}

var Gu = Fu(Nu, 9, 0),
    ku = Fu(Uu, 5, 0),
    Ou = function Ou(t) {
  return (t / 8 | 0) + (7 & t && 1);
},
    Hu = function Hu(t, e, n) {
  (null == e || e < 0) && (e = 0), (null == n || n > t.length) && (n = t.length);
  var i = new (t instanceof bu ? bu : t instanceof _u ? _u : wu)(n - e);
  return i.set(t.subarray(e, n)), i;
},
    zu = function zu(t, e, n) {
  n <<= 7 & e;
  var i = e / 8 | 0;
  t[i] |= n, t[i + 1] |= n >>> 8;
},
    Vu = function Vu(t, e, n) {
  n <<= 7 & e;
  var i = e / 8 | 0;
  t[i] |= n, t[i + 1] |= n >>> 8, t[i + 2] |= n >>> 16;
},
    Wu = function Wu(t, e) {
  for (var n = [], i = 0; i < t.length; ++i) {
    t[i] && n.push({
      s: i,
      f: t[i]
    });
  }

  var r = n.length,
      s = n.slice();
  if (!r) return [Zu, 0];

  if (1 == r) {
    var a = new wu(n[0].s + 1);
    return a[n[0].s] = 1, [a, 1];
  }

  n.sort(function (t, e) {
    return t.f - e.f;
  }), n.push({
    s: -1,
    f: 25001
  });
  var o = n[0],
      l = n[1],
      c = 0,
      h = 1,
      u = 2;

  for (n[0] = {
    s: -1,
    f: o.f + l.f,
    l: o,
    r: l
  }; h != r - 1;) {
    o = n[n[c].f < n[u].f ? c++ : u++], l = n[c != h && n[c].f < n[u].f ? c++ : u++], n[h++] = {
      s: -1,
      f: o.f + l.f,
      l: o,
      r: l
    };
  }

  var d = s[0].s;

  for (i = 1; i < r; ++i) {
    s[i].s > d && (d = s[i].s);
  }

  var A = new bu(d + 1),
      p = qu(n[h - 1], A, 0);

  if (p > e) {
    i = 0;
    var g = 0,
        m = p - e,
        f = 1 << m;

    for (s.sort(function (t, e) {
      return A[e.s] - A[t.s] || t.f - e.f;
    }); i < r; ++i) {
      var v = s[i].s;
      if (!(A[v] > e)) break;
      g += f - (1 << p - A[v]), A[v] = e;
    }

    for (g >>>= m; g > 0;) {
      var y = s[i].s;
      A[y] < e ? g -= 1 << e - A[y]++ - 1 : ++i;
    }

    for (; i >= 0 && g; --i) {
      var E = s[i].s;
      A[E] == e && (--A[E], ++g);
    }

    p = e;
  }

  return [new wu(A), p];
},
    qu = function qu(t, e, n) {
  return -1 == t.s ? Math.max(qu(t.l, e, n + 1), qu(t.r, e, n + 1)) : e[t.s] = n;
},
    ju = function ju(t) {
  for (var e = t.length; e && !t[--e];) {
    ;
  }

  for (var n = new bu(++e), i = 0, r = t[0], s = 1, a = function a(t) {
    n[i++] = t;
  }, o = 1; o <= e; ++o) {
    if (t[o] == r && o != e) ++s;else {
      if (!r && s > 2) {
        for (; s > 138; s -= 138) {
          a(32754);
        }

        s > 2 && (a(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (a(r), --s; s > 6; s -= 6) {
          a(8304);
        }

        s > 2 && (a(s - 3 << 5 | 8208), s = 0);
      }

      for (; s--;) {
        a(r);
      }

      s = 1, r = t[o];
    }
  }

  return [n.subarray(0, i), e];
},
    Yu = function Yu(t, e) {
  for (var n = 0, i = 0; i < e.length; ++i) {
    n += t[i] * e[i];
  }

  return n;
},
    Ju = function Ju(t, e, n) {
  var i = n.length,
      r = Ou(e + 2);
  t[r] = 255 & i, t[r + 1] = i >>> 8, t[r + 2] = 255 ^ t[r], t[r + 3] = 255 ^ t[r + 1];

  for (var s = 0; s < i; ++s) {
    t[r + s + 4] = n[s];
  }

  return 8 * (r + 4 + i);
},
    Xu = function Xu(t, e, n, i, r, s, a, o, l, c, h) {
  zu(e, h++, n), ++r[256];

  for (var u = Wu(r, 15), d = u[0], A = u[1], p = Wu(s, 15), g = p[0], m = p[1], f = ju(d), v = f[0], y = f[1], E = ju(g), x = E[0], w = E[1], b = new bu(19), _ = 0; _ < v.length; ++_) {
    b[31 & v[_]]++;
  }

  for (_ = 0; _ < x.length; ++_) {
    b[31 & x[_]]++;
  }

  for (var I = Wu(b, 7), C = I[0], M = I[1], S = 19; S > 4 && !C[Mu[S - 1]]; --S) {
    ;
  }

  var B,
      T,
      L,
      R,
      D = c + 5 << 3,
      Q = Yu(r, Nu) + Yu(s, Uu) + a,
      P = Yu(r, d) + Yu(s, g) + a + 14 + 3 * S + Yu(b, C) + (2 * b[16] + 3 * b[17] + 7 * b[18]);
  if (D <= Q && D <= P) return Ju(e, h, t.subarray(l, l + c));

  if (zu(e, h, 1 + (P < Q)), h += 2, P < Q) {
    B = Fu(d, A, 0), T = d, L = Fu(g, m, 0), R = g;
    var F = Fu(C, M, 0);
    zu(e, h, y - 257), zu(e, h + 5, w - 1), zu(e, h + 10, S - 4), h += 14;

    for (_ = 0; _ < S; ++_) {
      zu(e, h + 3 * _, C[Mu[_]]);
    }

    h += 3 * S;

    for (var N = [v, x], U = 0; U < 2; ++U) {
      var G = N[U];

      for (_ = 0; _ < G.length; ++_) {
        var k = 31 & G[_];
        zu(e, h, F[k]), h += C[k], k > 15 && (zu(e, h, G[_] >>> 5 & 127), h += G[_] >>> 12);
      }
    }
  } else B = Gu, T = Nu, L = ku, R = Uu;

  for (_ = 0; _ < o; ++_) {
    if (i[_] > 255) {
      k = i[_] >>> 18 & 31;
      Vu(e, h, B[k + 257]), h += T[k + 257], k > 7 && (zu(e, h, i[_] >>> 23 & 31), h += Iu[k]);
      var O = 31 & i[_];
      Vu(e, h, L[O]), h += R[O], O > 3 && (Vu(e, h, i[_] >>> 5 & 8191), h += Cu[O]);
    } else Vu(e, h, B[i[_]]), h += T[i[_]];
  }

  return Vu(e, h, B[256]), h + T[256];
},
    Ku = new _u([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
    Zu = new wu(0),
    $u = function () {
  for (var t = new _u(256), e = 0; e < 256; ++e) {
    for (var n = e, i = 9; --i;) {
      n = (1 & n && 3988292384) ^ n >>> 1;
    }

    t[e] = n;
  }

  return t;
}(),
    td = function td() {
  var t = -1;
  return {
    p: function p(e) {
      for (var n = t, i = 0; i < e.length; ++i) {
        n = $u[255 & n ^ e[i]] ^ n >>> 8;
      }

      t = n;
    },
    d: function d() {
      return ~t;
    }
  };
},
    ed = function ed(t, e, n, i, r) {
  return function (t, e, n, i, r, s) {
    var a = t.length,
        o = new wu(i + a + 5 * (1 + Math.ceil(a / 7e3)) + r),
        l = o.subarray(i, o.length - r),
        c = 0;
    if (!e || a < 8) for (var h = 0; h <= a; h += 65535) {
      var u = h + 65535;
      u < a ? c = Ju(l, c, t.subarray(h, u)) : (l[h] = s, c = Ju(l, c, t.subarray(h, a)));
    } else {
      for (var d = Ku[e - 1], A = d >>> 13, p = 8191 & d, g = (1 << n) - 1, m = new bu(32768), f = new bu(g + 1), v = Math.ceil(n / 3), y = 2 * v, E = function E(e) {
        return (t[e] ^ t[e + 1] << v ^ t[e + 2] << y) & g;
      }, x = new _u(25e3), w = new bu(288), b = new bu(32), _ = 0, I = 0, C = (h = 0, 0), M = 0, S = 0; h < a; ++h) {
        var B = E(h),
            T = 32767 & h,
            L = f[B];

        if (m[T] = L, f[B] = T, M <= h) {
          var R = a - h;

          if ((_ > 7e3 || C > 24576) && R > 423) {
            c = Xu(t, l, 0, x, w, b, I, C, S, h - S, c), C = _ = I = 0, S = h;

            for (var D = 0; D < 286; ++D) {
              w[D] = 0;
            }

            for (D = 0; D < 30; ++D) {
              b[D] = 0;
            }
          }

          var Q = 2,
              P = 0,
              F = p,
              N = T - L & 32767;
          if (R > 2 && B == E(h - N)) for (var U = Math.min(A, R) - 1, G = Math.min(32767, h), k = Math.min(258, R); N <= G && --F && T != L;) {
            if (t[h + Q] == t[h + Q - N]) {
              for (var O = 0; O < k && t[h + O] == t[h + O - N]; ++O) {
                ;
              }

              if (O > Q) {
                if (Q = O, P = N, O > U) break;
                var H = Math.min(N, O - 2),
                    z = 0;

                for (D = 0; D < H; ++D) {
                  var V = h - N + D + 32768 & 32767,
                      W = V - m[V] + 32768 & 32767;
                  W > z && (z = W, L = V);
                }
              }
            }

            N += (T = L) - (L = m[T]) + 32768 & 32767;
          }

          if (P) {
            x[C++] = 268435456 | Lu[Q] << 18 | Ru[P];
            var q = 31 & Lu[Q],
                j = 31 & Ru[P];
            I += Iu[q] + Cu[j], ++w[257 + q], ++b[j], M = h + Q, ++_;
          } else x[C++] = t[h], ++w[t[h]];
        }
      }

      c = Xu(t, l, s, x, w, b, I, C, S, h - S, c), !s && 7 & c && (c = Ju(l, c + 1, Zu));
    }
    return Hu(o, 0, i + Ou(c) + r);
  }(t, null == e.level ? 6 : e.level, null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem, n, i, !r);
},
    nd = function nd(t, e) {
  var n = {};

  for (var i in t) {
    n[i] = t[i];
  }

  for (var i in e) {
    n[i] = e[i];
  }

  return n;
},
    id = function id(t, e, n) {
  for (; n; ++e) {
    t[e] = n, n >>>= 8;
  }
};

function rd(t, e) {
  return ed(t, e || {}, 0, 0);
}

var sd = function sd(t, e, n, i) {
  for (var r in t) {
    var s = t[r],
        a = e + r;
    s instanceof wu ? n[a] = [s, i] : Array.isArray(s) ? n[a] = [s[0], nd(i, s[1])] : sd(s, a + "/", n, i);
  }
},
    ad = "undefined" != typeof TextEncoder && new TextEncoder(),
    od = "undefined" != typeof TextDecoder && new TextDecoder();

try {
  od.decode(Zu, {
    stream: !0
  }), 1;
} catch (Wo) {}

function ld(t, e) {
  if (e) {
    for (var n = new wu(t.length), i = 0; i < t.length; ++i) {
      n[i] = t.charCodeAt(i);
    }

    return n;
  }

  if (ad) return ad.encode(t);

  var r = t.length,
      s = new wu(t.length + (t.length >> 1)),
      a = 0,
      o = function o(t) {
    s[a++] = t;
  };

  for (i = 0; i < r; ++i) {
    if (a + 5 > s.length) {
      var l = new wu(a + 8 + (r - i << 1));
      l.set(s), s = l;
    }

    var c = t.charCodeAt(i);
    c < 128 || e ? o(c) : c < 2048 ? (o(192 | c >> 6), o(128 | 63 & c)) : c > 55295 && c < 57344 ? (o(240 | (c = 65536 + (1047552 & c) | 1023 & t.charCodeAt(++i)) >> 18), o(128 | c >> 12 & 63), o(128 | c >> 6 & 63), o(128 | 63 & c)) : (o(224 | c >> 12), o(128 | c >> 6 & 63), o(128 | 63 & c));
  }

  return Hu(s, 0, a);
}

var cd = function cd(t) {
  var e = 0;
  if (t) for (var n in t) {
    var i = t[n].length;
    if (i > 65535) throw "extra field too long";
    e += i + 4;
  }
  return e;
},
    hd = function hd(t, e, n, i, r, s, a, o) {
  var l = i.length,
      c = n.extra,
      h = o && o.length,
      u = cd(c);
  id(t, e, null != a ? 33639248 : 67324752), e += 4, null != a && (t[e++] = 20, t[e++] = n.os), t[e] = 20, e += 2, t[e++] = n.flag << 1 | (null == s && 8), t[e++] = r && 8, t[e++] = 255 & n.compression, t[e++] = n.compression >> 8;
  var d = new Date(null == n.mtime ? Date.now() : n.mtime),
      A = d.getFullYear() - 1980;
  if (A < 0 || A > 119) throw "date not in range 1980-2099";
  if (id(t, e, A << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1), e += 4, null != s && (id(t, e, n.crc), id(t, e + 4, s), id(t, e + 8, n.size)), id(t, e + 12, l), id(t, e + 14, u), e += 16, null != a && (id(t, e, h), id(t, e + 6, n.attrs), id(t, e + 10, a), e += 14), t.set(i, e), e += l, u) for (var p in c) {
    var g = c[p],
        m = g.length;
    id(t, e, +p), id(t, e + 2, m), t.set(g, e + 4), e += 4 + m;
  }
  return h && (t.set(o, e), e += h), e;
};

function ud(t, e) {
  e || (e = {});
  var n = {},
      i = [];
  sd(t, "", n, e);
  var r = 0,
      s = 0;

  for (var a in n) {
    var o = n[a],
        l = o[0],
        c = o[1],
        h = 0 == c.level ? 0 : 8,
        u = (b = ld(a)).length,
        d = c.comment,
        A = d && ld(d),
        p = A && A.length,
        g = cd(c.extra);
    if (u > 65535) throw "filename too long";
    var m = h ? rd(l, c) : l,
        f = m.length,
        v = td();
    v.p(l), i.push(nd(c, {
      size: l.length,
      crc: v.d(),
      c: m,
      f: b,
      m: A,
      u: u != a.length || A && d.length != p,
      o: r,
      compression: h
    })), r += 30 + u + g + f, s += 76 + 2 * (u + g) + (p || 0) + f;
  }

  for (var y = new wu(s + 22), E = r, x = s - r, w = 0; w < i.length; ++w) {
    var b = i[w];
    hd(y, b.o, b, b.f, b.u, b.c.length);

    var _ = 30 + b.f.length + cd(b.extra);

    y.set(b.c, b.o + _), hd(y, r, b, b.f, b.u, b.c.length, b.o, b.m), r += 16 + _ + (b.m ? b.m.length : 0);
  }

  return function (t, e, n, i, r) {
    id(t, e, 101010256), id(t, e + 8, n), id(t, e + 10, n), id(t, e + 12, i), id(t, e + 16, r);
  }(y, r, i.length, x, E), y;
}

var dd = /*#__PURE__*/function () {
  function dd() {
    _classCallCheck(this, dd);
  }

  _createClass(dd, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(t) {
        var e, n, i, r, _t342, _e259, s, _t343, _e260, _n231, _i219;

        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                e = '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
                n = {}, i = {};
                t.traverse(function (t) {
                  if (t.isMesh) {
                    var _r142 = t.geometry,
                        _s74 = t.material;
                    n[_s74.uuid] = _s74, null !== _s74.map && (i[_s74.map.uuid] = _s74.map), null !== _s74.normalMap && (i[_s74.normalMap.uuid] = _s74.normalMap), null !== _s74.aoMap && (i[_s74.aoMap.uuid] = _s74.aoMap), null !== _s74.roughnessMap && (i[_s74.roughnessMap.uuid] = _s74.roughnessMap), null !== _s74.metalnessMap && (i[_s74.metalnessMap.uuid] = _s74.metalnessMap), null !== _s74.emissiveMap && (i[_s74.emissiveMap.uuid] = _s74.emissiveMap), e += function (t, e) {
                      var n = "Object_" + t.id,
                          i = function (t) {
                        var e = t.elements;
                        return "( ".concat(pd(e, 0), ", ").concat(pd(e, 4), ", ").concat(pd(e, 8), ", ").concat(pd(e, 12), " )");
                      }(t.matrixWorld);

                      return "def Xform \"".concat(n, "\"\n{\n    matrix4d xformOp:transform = ").concat(i, "\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    ").concat(e, "\n}\n\n");
                    }(t, function (t, e) {
                      var n = "Geometry_" + t.id,
                          i = t.attributes,
                          r = i.position.count;
                      "uv2" in i && console.warn("THREE.USDZExporter: uv2 not supported yet.");
                      return "def Mesh \"".concat(n, "\"\n    {\n        int[] faceVertexCounts = [").concat(function (t) {
                        var e = null !== t.index ? t.index.array.length : t.attributes.position.count;
                        return Array(e / 3).fill(3).join(", ");
                      }(t), "]\n        int[] faceVertexIndices = [").concat(function (t) {
                        if (null !== t.index) return t.index.array.join(", ");
                        var e = [],
                            n = t.attributes.position.count;

                        for (var _t340 = 0; _t340 < n; _t340++) {
                          e.push(_t340);
                        }

                        return e.join(", ");
                      }(t), "]\n        rel material:binding = </Materials/Material_").concat(e.id, ">\n        normal3f[] normals = [").concat(gd(i.normal, r), "] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [").concat(gd(i.position, r), "]\n        float2[] primvars:st = [").concat(function (t, e) {
                        if (void 0 === t) return console.warn("USDZExporter: UVs missing."), Array(e).fill("(0, 0)").join(", ");
                        var n = [],
                            i = t.array;

                        for (var _t341 = 0; _t341 < i.length; _t341 += 2) {
                          n.push("(".concat(i[_t341 + 0].toPrecision(7), ", ").concat(1 - i[_t341 + 1].toPrecision(7), ")"));
                        }

                        return n.join(", ");
                      }(i.uv, r), "] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n");
                    }(_r142, _s74));
                  }
                }), e += function (t) {
                  var e = [];

                  for (var _n229 in t) {
                    var _i217 = t[_n229];
                    e.push(md(_i217));
                  }

                  return "def \"Materials\"\n{\n".concat(e.join(""), "\n}\n\n");
                }(n), e += function (t) {
                  var e = [];

                  for (var _n230 in t) {
                    var _i218 = t[_n230];
                    e.push(fd(_i218));
                  }

                  return "def \"Textures\"\n{\n".concat(e.join(""), "\n}\n\n");
                }(i);
                r = {
                  "model.usda": ld(e)
                };
                _context24.t0 = regeneratorRuntime.keys(i);

              case 5:
                if ((_context24.t1 = _context24.t0()).done) {
                  _context24.next = 13;
                  break;
                }

                _t342 = _context24.t1.value;
                _e259 = i[_t342];
                _context24.next = 10;
                return Ad(_e259.image);

              case 10:
                r["textures/Texture_" + _e259.id + ".jpg"] = _context24.sent;
                _context24.next = 5;
                break;

              case 13:
                s = 0;

                for (_t343 in r) {
                  _e260 = r[_t343];
                  s += 34 + _t343.length;
                  _n231 = 63 & s;

                  if (4 !== _n231) {
                    _i219 = new Uint8Array(64 - _n231);
                    r[_t343] = [_e260, {
                      extra: {
                        12345: _i219
                      }
                    }];
                  }

                  s = _e260.length;
                }

                return _context24.abrupt("return", ud(r, {
                  level: 0
                }));

              case 16:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24);
      }));

      function parse(_x21) {
        return _parse.apply(this, arguments);
      }

      return parse;
    }()
  }]);

  return dd;
}();

function Ad(_x22) {
  return _Ad.apply(this, arguments);
}

function _Ad() {
  _Ad = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(t) {
    var _e303, n, _i243;

    return regeneratorRuntime.wrap(function _callee42$(_context42) {
      while (1) {
        switch (_context42.prev = _context42.next) {
          case 0:
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap)) {
              _context42.next = 12;
              break;
            }

            _e303 = 1024 / Math.max(t.width, t.height), n = document.createElement("canvas");
            n.width = t.width * Math.min(1, _e303), n.height = t.height * Math.min(1, _e303);
            n.getContext("2d").drawImage(t, 0, 0, n.width, n.height);
            _context42.next = 6;
            return new Promise(function (t) {
              return n.toBlob(t, "image/jpeg", 1);
            });

          case 6:
            _i243 = _context42.sent;
            _context42.t0 = Uint8Array;
            _context42.next = 10;
            return _i243.arrayBuffer();

          case 10:
            _context42.t1 = _context42.sent;
            return _context42.abrupt("return", new _context42.t0(_context42.t1));

          case 12:
          case "end":
            return _context42.stop();
        }
      }
    }, _callee42);
  }));
  return _Ad.apply(this, arguments);
}

function pd(t, e) {
  return "(".concat(t[e + 0], ", ").concat(t[e + 1], ", ").concat(t[e + 2], ", ").concat(t[e + 3], ")");
}

function gd(t, e) {
  if (void 0 === t) return console.warn("USDZExporter: Normals missing."), Array(e).fill("(0, 0, 0)").join(", ");
  var n = [],
      i = t.array;

  for (var _t344 = 0; _t344 < i.length; _t344 += 3) {
    n.push("(".concat(i[_t344 + 0].toPrecision(7), ", ").concat(i[_t344 + 1].toPrecision(7), ", ").concat(i[_t344 + 2].toPrecision(7), ")"));
  }

  return n.join(", ");
}

function md(t) {
  var e = "            ",
      n = [];
  return null !== t.map ? n.push("".concat(e, "color3f inputs:diffuseColor.connect = </Textures/Texture_").concat(t.map.id, ".outputs:rgb>")) : n.push("".concat(e, "color3f inputs:diffuseColor = ").concat(vd(t.color))), null !== t.emissiveMap ? n.push("".concat(e, "color3f inputs:emissiveColor.connect = </Textures/Texture_").concat(t.emissiveMap.id, ".outputs:rgb>")) : t.emissive.getHex() > 0 && n.push("".concat(e, "color3f inputs:emissiveColor = ").concat(vd(t.emissive))), null !== t.normalMap && n.push("".concat(e, "normal3f inputs:normal.connect = </Textures/Texture_").concat(t.normalMap.id, ".outputs:rgb>")), null !== t.aoMap && n.push("".concat(e, "float inputs:occlusion.connect = </Textures/Texture_").concat(t.aoMap.id, ".outputs:r>")), null !== t.roughnessMap ? n.push("".concat(e, "float inputs:roughness.connect = </Textures/Texture_").concat(t.roughnessMap.id, ".outputs:g>")) : n.push("".concat(e, "float inputs:roughness = ").concat(t.roughness)), null !== t.metalnessMap ? n.push("".concat(e, "float inputs:metallic.connect = </Textures/Texture_").concat(t.metalnessMap.id, ".outputs:b>")) : n.push("".concat(e, "float inputs:metallic = ").concat(t.metalness)), "\n    def Material \"Material_".concat(t.id, "\"\n    {\n        token outputs:surface.connect = </Materials/Material_").concat(t.id, "/PreviewSurface.outputs:surface>\n\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n").concat(n.join("\n"), "\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n    }\n");
}

function fd(t) {
  return "\n    def Shader \"Texture_".concat(t.id, "\"\n    {\n        uniform token info:id = \"UsdUVTexture\"\n        asset inputs:file = @textures/Texture_").concat(t.id, ".jpg@\n        token inputs:wrapS = \"repeat\"\n        token inputs:wrapT = \"repeat\"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n    }\n");
}

function vd(t) {
  return "(".concat(t.r, ", ").concat(t.g, ", ").concat(t.b, ")");
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var yd = function yd(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var Ed = !1,
    xd = !1;
var wd = (bd = ["quick-look", "scene-viewer", "webxr", "none"], function (t) {
  try {
    var _e261 = Jl(t),
        n = (_e261.length ? _e261[0].terms : []).filter(function (t) {
      return t && "ident" === t.type;
    }).map(function (t) {
      return t.value;
    }).filter(function (t) {
      return bd.indexOf(t) > -1;
    }),
        _i220 = new Set();

    var _iterator20 = _createForOfIteratorHelper(n),
        _step20;

    try {
      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
        var _t345 = _step20.value;

        _i220.add(_t345);
      }
    } catch (err) {
      _iterator20.e(err);
    } finally {
      _iterator20.f();
    }

    return _i220;
  } catch (t) {}

  return new Set();
});
var bd;
var _d = "quick-look",
    Id = "scene-viewer",
    Cd = "webxr",
    Md = "none",
    Sd = Symbol("arButtonContainer"),
    Bd = Symbol("enterARWithWebXR"),
    Td = Symbol("openSceneViewer"),
    Ld = Symbol("openIOSARQuickLook"),
    Rd = Symbol("canActivateAR"),
    Dd = Symbol("arMode"),
    Qd = Symbol("arModes"),
    Pd = Symbol("arAnchor"),
    Fd = Symbol("preload"),
    Nd = Symbol("onARButtonContainerClick"),
    Ud = Symbol("onARStatus"),
    Gd = Symbol("onARTracking"),
    kd = Symbol("onARTap"),
    Od = Symbol("selectARMode"),
    Hd = Symbol("triggerLoad");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var zd, Vd, Wd;
var qd = Symbol("evaluate"),
    jd = Symbol("lastValue");

var Yd = /*#__PURE__*/function () {
  function Yd() {
    _classCallCheck(this, Yd);

    this[zd] = null;
  }

  _createClass(Yd, [{
    key: "isConstant",
    get: function get() {
      return !1;
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      return this.isConstant && null != this[jd] || (this[jd] = this[qd]()), this[jd];
    }
  }], [{
    key: "evaluatableFor",
    value: function evaluatableFor(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ic;
      if (t instanceof Yd) return t;
      if ("number" === t.type) return "%" === t.unit ? new Kd(t, e) : t;

      switch (t.name.value) {
        case "calc":
          return new nA(t, e);

        case "env":
          return new $d(t);
      }

      return ic;
    }
  }, {
    key: "evaluate",
    value: function evaluate(t) {
      return t instanceof Yd ? t.evaluate() : t;
    }
  }, {
    key: "isConstant",
    value: function isConstant(t) {
      return !(t instanceof Yd) || t.isConstant;
    }
  }, {
    key: "applyIntrinsics",
    value: function applyIntrinsics(t, e) {
      var n = e.basis,
          i = e.keywords,
          r = i.auto;
      return n.map(function (e, n) {
        var s = null == r[n] ? e : r[n];
        var a = t[n] ? t[n] : s;

        if ("ident" === a.type) {
          var _t346 = a.value;
          _t346 in i && (a = i[_t346][n]);
        }

        return null != a && "ident" !== a.type || (a = s), "%" === a.unit ? Yl(a.number / 100 * e.number, e.unit) : (a = ac(a, e), a.unit !== e.unit ? e : a);
      });
    }
  }]);

  return Yd;
}();

zd = jd;
var Jd = Symbol("percentage"),
    Xd = Symbol("basis");

var Kd = /*#__PURE__*/function (_Yd) {
  _inherits(Kd, _Yd);

  var _super90 = _createSuper(Kd);

  function Kd(t, e) {
    var _this99;

    _classCallCheck(this, Kd);

    _this99 = _super90.call(this), _this99[Jd] = t, _this99[Xd] = e;
    return _this99;
  }

  _createClass(Kd, [{
    key: "isConstant",
    get: function get() {
      return !0;
    }
  }, {
    key: qd,
    value: function value() {
      return Yl(this[Jd].number / 100 * this[Xd].number, this[Xd].unit);
    }
  }]);

  return Kd;
}(Yd);

var Zd = Symbol("identNode");

var $d = /*#__PURE__*/function (_Yd2) {
  _inherits($d, _Yd2);

  var _super91 = _createSuper($d);

  function $d(t) {
    var _this100;

    _classCallCheck(this, $d);

    _this100 = _super91.call(this), _this100[Vd] = null;
    var e = t.arguments.length ? t.arguments[0].terms[0] : null;
    null != e && "ident" === e.type && (_this100[Zd] = e);
    return _this100;
  }

  _createClass($d, [{
    key: "isConstant",
    get: function get() {
      return !1;
    }
  }, {
    key: (Vd = Zd, qd),
    value: function value() {
      if (null != this[Zd]) switch (this[Zd].value) {
        case "window-scroll-y":
          return {
            type: "number",
            number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0,
            unit: null
          };
      }
      return ic;
    }
  }]);

  return $d;
}(Yd);

var tA = /[\*\/]/,
    eA = Symbol("evalutor");

var nA = /*#__PURE__*/function (_Yd3) {
  _inherits(nA, _Yd3);

  var _super92 = _createSuper(nA);

  function nA(t) {
    var _this101;

    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ic;

    _classCallCheck(this, nA);

    if (_this101 = _super92.call(this), _this101[Wd] = null, 1 !== t.arguments.length) return _possibleConstructorReturn(_this101);
    var n = t.arguments[0].terms.slice(),
        i = [];

    for (; n.length;) {
      var _t347 = n.shift();

      if (i.length > 0) {
        var _n232 = i[i.length - 1];

        if ("operator" === _n232.type && tA.test(_n232.value)) {
          var _n233 = i.pop(),
              _r143 = i.pop();

          if (null == _r143) return _possibleConstructorReturn(_this101);
          i.push(new aA(_n233, Yd.evaluatableFor(_r143, e), Yd.evaluatableFor(_t347, e)));
          continue;
        }
      }

      i.push("operator" === _t347.type ? _t347 : Yd.evaluatableFor(_t347, e));
    }

    for (; i.length > 2;) {
      var _i$splice = i.splice(0, 3),
          _i$splice2 = _slicedToArray(_i$splice, 3),
          _t348 = _i$splice2[0],
          _n234 = _i$splice2[1],
          _r144 = _i$splice2[2];

      if ("operator" !== _n234.type) return _possibleConstructorReturn(_this101);
      i.unshift(new aA(_n234, Yd.evaluatableFor(_t348, e), Yd.evaluatableFor(_r144, e)));
    }

    1 === i.length && (_this101[eA] = i[0]);
    return _possibleConstructorReturn(_this101);
  }

  _createClass(nA, [{
    key: "isConstant",
    get: function get() {
      return null == this[eA] || Yd.isConstant(this[eA]);
    }
  }, {
    key: (Wd = eA, qd),
    value: function value() {
      return null != this[eA] ? Yd.evaluate(this[eA]) : ic;
    }
  }]);

  return nA;
}(Yd);

var iA = Symbol("operator"),
    rA = Symbol("left"),
    sA = Symbol("right");

var aA = /*#__PURE__*/function (_Yd4) {
  _inherits(aA, _Yd4);

  var _super93 = _createSuper(aA);

  function aA(t, e, n) {
    var _this102;

    _classCallCheck(this, aA);

    _this102 = _super93.call(this), _this102[iA] = t, _this102[rA] = e, _this102[sA] = n;
    return _this102;
  }

  _createClass(aA, [{
    key: "isConstant",
    get: function get() {
      return Yd.isConstant(this[rA]) && Yd.isConstant(this[sA]);
    }
  }, {
    key: qd,
    value: function value() {
      var t = ac(Yd.evaluate(this[rA])),
          e = ac(Yd.evaluate(this[sA])),
          n = t.number,
          i = t.unit,
          r = e.number,
          s = e.unit;
      if (null != s && null != i && s != i) return ic;
      var a = i || s;
      var o;

      switch (this[iA].value) {
        case "+":
          o = n + r;
          break;

        case "-":
          o = n - r;
          break;

        case "/":
          o = n / r;
          break;

        case "*":
          o = n * r;
          break;

        default:
          return ic;
      }

      return {
        type: "number",
        number: o,
        unit: a
      };
    }
  }]);

  return aA;
}(Yd);

var oA = Symbol("evaluatables"),
    lA = Symbol("intrinsics");

var cA = /*#__PURE__*/function (_Yd5) {
  _inherits(cA, _Yd5);

  var _super94 = _createSuper(cA);

  function cA(t, e) {
    var _this103;

    _classCallCheck(this, cA);

    _this103 = _super94.call(this), _this103[lA] = e;
    var n = t[0],
        i = null != n ? n.terms : [];
    _this103[oA] = e.basis.map(function (t, e) {
      var n = i[e];
      return null == n ? {
        type: "ident",
        value: "auto"
      } : "ident" === n.type ? n : Yd.evaluatableFor(n, t);
    });
    return _this103;
  }

  _createClass(cA, [{
    key: "isConstant",
    get: function get() {
      var _iterator21 = _createForOfIteratorHelper(this[oA]),
          _step21;

      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var _t349 = _step21.value;
          if (!Yd.isConstant(_t349)) return !1;
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }

      return !0;
    }
  }, {
    key: qd,
    value: function value() {
      var t = this[oA].map(function (t) {
        return Yd.evaluate(t);
      });
      return Yd.applyIntrinsics(t, this[lA]).map(function (t) {
        return t.number;
      });
    }
  }]);

  return cA;
}(Yd);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var hA, uA, dA, AA;
var pA = Symbol("instances"),
    gA = Symbol("activateListener"),
    mA = Symbol("deactivateListener"),
    fA = Symbol("notifyInstances"),
    vA = Symbol("notify"),
    yA = Symbol("callback");

var EA = /*#__PURE__*/function () {
  function EA(t) {
    _classCallCheck(this, EA);

    this[yA] = t;
  }

  _createClass(EA, [{
    key: "observe",
    value: function observe() {
      0 === EA[pA].size && EA[gA](), EA[pA].add(this);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      EA[pA].delete(this), 0 === EA[pA].size && EA[mA]();
    }
  }, {
    key: vA,
    value: function value() {
      this[yA]();
    }
  }], [{
    key: fA,
    value: function value() {
      var _iterator22 = _createForOfIteratorHelper(EA[pA]),
          _step22;

      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var _t350 = _step22.value;

          _t350[vA]();
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
    }
  }, {
    key: (hA = pA, gA),
    value: function value() {
      window.addEventListener("scroll", this[fA], {
        passive: !0
      });
    }
  }, {
    key: mA,
    value: function value() {
      window.removeEventListener("scroll", this[fA]);
    }
  }]);

  return EA;
}();

EA[hA] = new Set();

var xA = Symbol("computeStyleCallback"),
    wA = Symbol("astWalker"),
    bA = Symbol("dependencies"),
    _A = Symbol("onScroll");

var IA = /*#__PURE__*/function () {
  function IA(t) {
    var _this104 = this;

    _classCallCheck(this, IA);

    this[uA] = {}, this[dA] = new nc(["function"]), this[AA] = function () {
      _this104[xA]({
        relatedState: "window-scroll"
      });
    }, this[xA] = t;
  }

  _createClass(IA, [{
    key: "observeEffectsFor",
    value: function observeEffectsFor(t) {
      var _this105 = this;

      var e = {},
          n = this[bA];
      this[wA].walk(t, function (t) {
        var i = t.name,
            r = t.arguments[0].terms[0];
        if ("env" === i.value && null != r && "ident" === r.type) switch (r.value) {
          case "window-scroll-y":
            if (null == e["window-scroll"]) {
              var _t351 = "window-scroll" in n ? n["window-scroll"] : new EA(_this105[_A]);

              _t351.observe(), delete n["window-scroll"], e["window-scroll"] = _t351;
            }

        }
      });

      for (var _t352 in n) {
        n[_t352].disconnect();
      }

      this[bA] = e;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var _t353 in this[bA]) {
        this[bA][_t353].disconnect();
      }
    }
  }]);

  return IA;
}();

uA = bA, dA = wA, AA = _A;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CA = function CA(t) {
  var e = t.observeEffects || !1,
      n = t.intrinsics instanceof Function ? t.intrinsics : function () {
    return t.intrinsics;
  };
  return function (i, r) {
    var _Object$definePropert;

    var s = i.updated,
        a = i.connectedCallback,
        o = i.disconnectedCallback,
        l = Symbol("".concat(r, "StyleEffector")),
        c = Symbol("".concat(r, "StyleEvaluator")),
        h = Symbol("".concat(r, "UpdateEvaluator")),
        u = Symbol("".concat(r, "EvaluateAndSync"));
    Object.defineProperties(i, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, l, {
      value: null,
      writable: !0
    }), _defineProperty(_Object$definePropert, c, {
      value: null,
      writable: !0
    }), _defineProperty(_Object$definePropert, h, {
      value: function value() {
        var _this106 = this;

        var t = Jl(this[r]);
        this[c] = new cA(t, n(this)), null == this[l] && e && (this[l] = new IA(function () {
          return _this106[u]();
        })), null != this[l] && this[l].observeEffectsFor(t);
      }
    }), _defineProperty(_Object$definePropert, u, {
      value: function value() {
        if (null == this[c]) return;
        var e = this[c].evaluate();
        this[t.updateHandler](e);
      }
    }), _defineProperty(_Object$definePropert, "updated", {
      value: function value(t) {
        t.has(r) && (this[h](), this[u]()), s.call(this, t);
      }
    }), _defineProperty(_Object$definePropert, "connectedCallback", {
      value: function value() {
        a.call(this), this.requestUpdate(r, this[r]);
      }
    }), _defineProperty(_Object$definePropert, "disconnectedCallback", {
      value: function value() {
        o.call(this), null != this[l] && (this[l].dispose(), this[l] = null);
      }
    }), _Object$definePropert));
  };
},
    MA = Object.freeze({
  minimumRadius: 0,
  maximumRadius: 1 / 0,
  minimumPolarAngle: Math.PI / 8,
  maximumPolarAngle: Math.PI - Math.PI / 8,
  minimumAzimuthalAngle: -1 / 0,
  maximumAzimuthalAngle: 1 / 0,
  minimumFieldOfView: 10,
  maximumFieldOfView: 45,
  interactionPolicy: "always-allow",
  touchAction: "pan-y"
}),
    SA = /^touch(start|end|move)$/,
    BA = Math.PI / 8,
    TA = 33,
    LA = 34,
    RA = 37,
    DA = 38,
    QA = 39,
    PA = 40,
    FA = "user-interaction",
    NA = "none";
/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var UA = /*#__PURE__*/function (_y14) {
  _inherits(UA, _y14);

  var _super95 = _createSuper(UA);

  function UA(t, e) {
    var _this107;

    _classCallCheck(this, UA);

    _this107 = _super95.call(this), _this107.camera = t, _this107.element = e, _this107.sensitivity = 1, _this107._interactionEnabled = !1, _this107._disableZoom = !1, _this107.isUserChange = !1, _this107.isUserPointing = !1, _this107.spherical = new Aa(), _this107.goalSpherical = new Aa(), _this107.thetaDamper = new jl(), _this107.phiDamper = new jl(), _this107.radiusDamper = new jl(), _this107.logFov = Math.log(MA.maximumFieldOfView), _this107.goalLogFov = _this107.logFov, _this107.fovDamper = new jl(), _this107.pointerIsDown = !1, _this107.lastPointerPosition = {
      clientX: 0,
      clientY: 0
    }, _this107.touchMode = "rotate", _this107.touchDecided = !1, _this107.onPointerMove = function (t) {
      if (_this107.pointerIsDown && _this107.canInteract) {
        if (SA.test(t.type)) {
          var _e262 = t.touches;

          switch (_this107.touchMode) {
            case "zoom":
              if (_this107.lastTouches.length > 1 && _e262.length > 1) {
                var _t355 = .04 * (_this107.twoTouchDistance(_this107.lastTouches[0], _this107.lastTouches[1]) - _this107.twoTouchDistance(_e262[0], _e262[1])) / 10;

                _this107.userAdjustOrbit(0, 0, _t355);
              }

              break;

            case "rotate":
              var _t354 = _this107._options.touchAction;

              if (!_this107.touchDecided && "none" !== _t354) {
                _this107.touchDecided = !0;

                var _e262$ = _e262[0],
                    n = _e262$.clientX,
                    _i221 = _e262$.clientY,
                    _r145 = Math.abs(n - _this107.lastPointerPosition.clientX),
                    _s75 = Math.abs(_i221 - _this107.lastPointerPosition.clientY);

                if ("pan-y" === _t354 && _s75 > _r145 || "pan-x" === _t354 && _r145 > _s75) return void (_this107.touchMode = "scroll");
              }

              _this107.handleSinglePointerMove(_e262[0]);

              break;

            case "scroll":
              return;
          }

          _this107.lastTouches = _e262;
        } else _this107.handleSinglePointerMove(t);

        t.cancelable && t.preventDefault();
      }
    }, _this107.onPointerDown = function (t) {
      if (_this107.pointerIsDown = !0, _this107.isUserPointing = !1, SA.test(t.type)) {
        var _e263 = t.touches;

        switch (_this107.touchDecided = !1, _e263.length) {
          default:
          case 1:
            _this107.touchMode = "rotate", _this107.handleSinglePointerDown(_e263[0]);
            break;

          case 2:
            _this107.touchMode = _this107._disableZoom ? "scroll" : "zoom";
        }

        _this107.lastTouches = _e263;
      } else _this107.handleSinglePointerDown(t);
    }, _this107.onPointerUp = function (t) {
      _this107.element.style.cursor = "grab", _this107.pointerIsDown = !1, _this107.isUserPointing && _this107.dispatchEvent({
        type: "pointer-change-end",
        pointer: Object.assign({}, _this107.lastPointerPosition)
      });
    }, _this107.onWheel = function (t) {
      if (!_this107.canInteract) return;
      var e = t.deltaY * (1 == t.deltaMode ? 18 : 1) * .04 / 30;
      _this107.userAdjustOrbit(0, 0, e), t.cancelable && t.preventDefault();
    }, _this107.onKeyDown = function (t) {
      var e = !1;

      switch (t.keyCode) {
        case TA:
          e = !0, _this107.userAdjustOrbit(0, 0, .04);
          break;

        case LA:
          e = !0, _this107.userAdjustOrbit(0, 0, -.04);
          break;

        case DA:
          e = !0, _this107.userAdjustOrbit(0, -BA, 0);
          break;

        case PA:
          e = !0, _this107.userAdjustOrbit(0, BA, 0);
          break;

        case RA:
          e = !0, _this107.userAdjustOrbit(-BA, 0, 0);
          break;

        case QA:
          e = !0, _this107.userAdjustOrbit(BA, 0, 0);
      }

      e && t.cancelable && t.preventDefault();
    }, _this107._options = Object.assign({}, MA), _this107.setOrbit(0, Math.PI / 2, 1), _this107.setFieldOfView(100), _this107.jumpToGoal();
    return _this107;
  }

  _createClass(UA, [{
    key: "interactionEnabled",
    get: function get() {
      return this._interactionEnabled;
    }
  }, {
    key: "enableInteraction",
    value: function enableInteraction() {
      if (!1 === this._interactionEnabled) {
        var _t356 = this.element;
        _t356.addEventListener("mousemove", this.onPointerMove), _t356.addEventListener("mousedown", this.onPointerDown), this._disableZoom || _t356.addEventListener("wheel", this.onWheel), _t356.addEventListener("keydown", this.onKeyDown), _t356.addEventListener("touchstart", this.onPointerDown, {
          passive: !0
        }), _t356.addEventListener("touchmove", this.onPointerMove), self.addEventListener("mouseup", this.onPointerUp), self.addEventListener("touchend", this.onPointerUp), this.element.style.cursor = "grab", this._interactionEnabled = !0;
      }
    }
  }, {
    key: "disableInteraction",
    value: function disableInteraction() {
      if (!0 === this._interactionEnabled) {
        var _t357 = this.element;
        _t357.removeEventListener("mousemove", this.onPointerMove), _t357.removeEventListener("mousedown", this.onPointerDown), this._disableZoom || _t357.removeEventListener("wheel", this.onWheel), _t357.removeEventListener("keydown", this.onKeyDown), _t357.removeEventListener("touchstart", this.onPointerDown), _t357.removeEventListener("touchmove", this.onPointerMove), self.removeEventListener("mouseup", this.onPointerUp), self.removeEventListener("touchend", this.onPointerUp), _t357.style.cursor = "", this._interactionEnabled = !1;
      }
    }
  }, {
    key: "options",
    get: function get() {
      return this._options;
    }
  }, {
    key: "disableZoom",
    set: function set(t) {
      this._disableZoom != t && (this._disableZoom = t, !0 === t ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel));
    }
  }, {
    key: "getCameraSpherical",
    value: function getCameraSpherical() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Aa();
      return t.copy(this.spherical);
    }
  }, {
    key: "getFieldOfView",
    value: function getFieldOfView() {
      return this.camera.fov;
    }
  }, {
    key: "applyOptions",
    value: function applyOptions(t) {
      Object.assign(this._options, t), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov));
    }
  }, {
    key: "updateNearFar",
    value: function updateNearFar(t, e) {
      this.camera.near = Math.max(t, e / 1e3), this.camera.far = e, this.camera.updateProjectionMatrix();
    }
  }, {
    key: "updateAspect",
    value: function updateAspect(t) {
      this.camera.aspect = t, this.camera.updateProjectionMatrix();
    }
  }, {
    key: "setOrbit",
    value: function setOrbit() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.goalSpherical.theta;
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.goalSpherical.phi;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.goalSpherical.radius;
      var _this$_options = this._options,
          i = _this$_options.minimumAzimuthalAngle,
          r = _this$_options.maximumAzimuthalAngle,
          s = _this$_options.minimumPolarAngle,
          a = _this$_options.maximumPolarAngle,
          o = _this$_options.minimumRadius,
          l = _this$_options.maximumRadius,
          _this$goalSpherical = this.goalSpherical,
          c = _this$goalSpherical.theta,
          h = _this$goalSpherical.phi,
          u = _this$goalSpherical.radius,
          d = Vl(t, i, r);
      isFinite(i) || isFinite(r) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d) + d);
      var A = Vl(e, s, a),
          p = Vl(n, o, l);
      return (d !== c || A !== h || p !== u) && (this.goalSpherical.theta = d, this.goalSpherical.phi = A, this.goalSpherical.radius = p, this.goalSpherical.makeSafe(), this.isUserChange = !1, !0);
    }
  }, {
    key: "setRadius",
    value: function setRadius(t) {
      this.goalSpherical.radius = t, this.setOrbit();
    }
  }, {
    key: "setFieldOfView",
    value: function setFieldOfView(t) {
      var _this$_options2 = this._options,
          e = _this$_options2.minimumFieldOfView,
          n = _this$_options2.maximumFieldOfView;
      t = Vl(t, e, n), this.goalLogFov = Math.log(t);
    }
  }, {
    key: "setDamperDecayTime",
    value: function setDamperDecayTime(t) {
      this.thetaDamper.setDecayTime(t), this.phiDamper.setDecayTime(t), this.radiusDamper.setDecayTime(t), this.fovDamper.setDecayTime(t);
    }
  }, {
    key: "adjustOrbit",
    value: function adjustOrbit(t, e, n) {
      var _this$goalSpherical2 = this.goalSpherical,
          i = _this$goalSpherical2.theta,
          r = _this$goalSpherical2.phi,
          s = _this$goalSpherical2.radius,
          _this$_options3 = this._options,
          a = _this$_options3.minimumRadius,
          o = _this$_options3.maximumRadius,
          l = _this$_options3.minimumFieldOfView,
          c = _this$_options3.maximumFieldOfView,
          h = this.spherical.theta - i,
          u = Math.PI - .001,
          d = i - Vl(t, -u - h, u - h),
          A = r - e,
          p = 0 === n ? 0 : n > 0 ? (o - s) / (Math.log(c) - this.goalLogFov) : (s - a) / (this.goalLogFov - Math.log(l)),
          g = s + n * Math.min(isFinite(p) ? p : 1 / 0, o - a);

      if (this.setOrbit(d, A, g), 0 !== n) {
        var _t358 = this.goalLogFov + n;

        this.setFieldOfView(Math.exp(_t358));
      }
    }
  }, {
    key: "jumpToGoal",
    value: function jumpToGoal() {
      this.update(0, 1e4);
    }
  }, {
    key: "update",
    value: function update(t, e) {
      if (this.isStationary()) return;
      var _this$_options4 = this._options,
          n = _this$_options4.maximumPolarAngle,
          i = _this$_options4.maximumRadius,
          r = this.spherical.theta - this.goalSpherical.theta;
      Math.abs(r) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(r) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, e, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e, n), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e, i), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e, 1), this.moveCamera();
    }
  }, {
    key: "isStationary",
    value: function isStationary() {
      return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;
    }
  }, {
    key: "moveCamera",
    value: function moveCamera() {
      this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new Bt(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix());
      var t = this.isUserChange ? FA : NA;
      this.dispatchEvent({
        type: "change",
        source: t
      });
    }
  }, {
    key: "canInteract",
    get: function get() {
      if ("allow-when-focused" == this._options.interactionPolicy) {
        return this.element.getRootNode().activeElement === this.element;
      }

      return "always-allow" === this._options.interactionPolicy;
    }
  }, {
    key: "userAdjustOrbit",
    value: function userAdjustOrbit(t, e, n) {
      this.adjustOrbit(t * this.sensitivity, e * this.sensitivity, n), this.isUserChange = !0, this.dispatchEvent({
        type: "change",
        source: FA
      });
    }
  }, {
    key: "wrapAngle",
    value: function wrapAngle(t) {
      var e = (t + Math.PI) / (2 * Math.PI);
      return 2 * (e - Math.floor(e)) * Math.PI - Math.PI;
    }
  }, {
    key: "pixelLengthToSphericalAngle",
    value: function pixelLengthToSphericalAngle(t) {
      return 2 * Math.PI * t / this.element.clientHeight;
    }
  }, {
    key: "twoTouchDistance",
    value: function twoTouchDistance(t, e) {
      var n = t.clientX,
          i = t.clientY,
          r = e.clientX,
          s = e.clientY,
          a = r - n,
          o = s - i;
      return Math.sqrt(a * a + o * o);
    }
  }, {
    key: "handleSinglePointerMove",
    value: function handleSinglePointerMove(t) {
      var e = t.clientX,
          n = t.clientY,
          i = this.pixelLengthToSphericalAngle(e - this.lastPointerPosition.clientX),
          r = this.pixelLengthToSphericalAngle(n - this.lastPointerPosition.clientY);
      this.lastPointerPosition.clientX = e, this.lastPointerPosition.clientY = n, !1 === this.isUserPointing && (this.isUserPointing = !0, this.dispatchEvent({
        type: "pointer-change-start",
        pointer: Object.assign({}, t)
      })), this.userAdjustOrbit(i, r, 0);
    }
  }, {
    key: "handleSinglePointerDown",
    value: function handleSinglePointerDown(t) {
      this.lastPointerPosition.clientX = t.clientX, this.lastPointerPosition.clientY = t.clientY, this.element.style.cursor = "grabbing";
    }
  }]);

  return UA;
}(y);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var GA = function GA(t) {
  return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1;
},
    kA = function kA(t, e) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : GA;
  return function (i) {
    return t + (e - t) * n(i);
  };
},
    OA = function OA(t, e) {
  var n = [],
      i = [];
  var r = t;

  for (var _t359 = 0; _t359 < e.length; ++_t359) {
    var _s76 = e[_t359],
        _a59 = _s76.value,
        _o39 = _s76.frames,
        _l39 = _s76.ease || GA,
        _c32 = kA(r, _a59, _l39);

    n.push(_c32), i.push(_o39), r = _a59;
  }

  return function (t, e) {
    var n = e.reduce(function (t, e) {
      return t + e;
    }, 0),
        i = e.map(function (t) {
      return t / n;
    });
    return function (e) {
      var n = 0,
          r = 1 / 0,
          s = function s() {
        return 0;
      };

      for (var _a60 = 0; _a60 < i.length && (r = i[_a60], s = t[_a60], !(e <= n + r)); ++_a60) {
        n += r;
      }

      return s((e - n) / r);
    };
  }(n, i);
};
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var HA = function HA(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var zA = OA(0, [{
  frames: 5,
  value: -1
}, {
  frames: 1,
  value: -1
}, {
  frames: 8,
  value: 1
}, {
  frames: 1,
  value: 1
}, {
  frames: 5,
  value: 0
}, {
  frames: 18,
  value: 0
}]),
    VA = OA(0, [{
  frames: 1,
  value: 1
}, {
  frames: 5,
  value: 1
}, {
  frames: 1,
  value: 0
}, {
  frames: 6,
  value: 0
}]),
    WA = 1.1 * uc,
    qA = ["front", "right", "back", "left"],
    jA = ["upper-", "", "lower-"],
    YA = "auto",
    JA = "when-focused",
    XA = "wiggle",
    KA = "always-allow",
    ZA = "pan-y",
    $A = function $A(t) {
  return {
    basis: [Yl(t[Ip] * Math.PI / 180, "rad")],
    keywords: {
      auto: [null]
    }
  };
},
    tp = {
  basis: [rc(Yl(25, "deg"))],
  keywords: {
    auto: [null]
  }
},
    ep = function ep(t) {
  var e = t[Xh];
  return {
    basis: [rc(Yl(45, "deg"))],
    keywords: {
      auto: [Yl(e.framedFieldOfView, "deg")]
    }
  };
},
    np = function () {
  var t = Jl("0deg 75deg 105%")[0].terms,
      e = ac(t[0]),
      n = ac(t[1]);
  return function (t) {
    var i = t[Xh].idealCameraDistance;
    return {
      basis: [e, n, Yl(i, "m")],
      keywords: {
        auto: [null, null, Yl(105, "%")]
      }
    };
  };
}(),
    ip = function ip(t) {
  var e = WA * t[Xh].idealCameraDistance;
  return {
    basis: [Yl(-1 / 0, "rad"), Yl(Math.PI / 8, "rad"), Yl(e, "m")],
    keywords: {
      auto: [null, null, null]
    }
  };
},
    rp = function rp(t) {
  var e = np(t),
      n = new cA([], e).evaluate()[2];
  return {
    basis: [Yl(1 / 0, "rad"), Yl(Math.PI - Math.PI / 8, "rad"), Yl(n, "m")],
    keywords: {
      auto: [null, null, null]
    }
  };
},
    sp = function sp(t) {
  var e = t[Xh].boundingBox.getCenter(new H());
  return {
    basis: [Yl(e.x, "m"), Yl(e.y, "m"), Yl(e.z, "m")],
    keywords: {
      auto: [null, null, null]
    }
  };
},
    ap = Math.PI / 2,
    op = Math.PI / 3,
    lp = ap / 2,
    cp = 2 * Math.PI,
    hp = Symbol("controls"),
    up = Symbol("promptElement"),
    dp = Symbol("promptAnimatedContainer"),
    Ap = Symbol("deferInteractionPrompt"),
    pp = Symbol("updateAria"),
    gp = Symbol("updateCameraForRadius"),
    mp = Symbol("onBlur"),
    fp = Symbol("onFocus"),
    vp = Symbol("onChange"),
    yp = Symbol("onPointerChange"),
    Ep = Symbol("waitingToPromptUser"),
    xp = Symbol("userHasInteracted"),
    wp = Symbol("promptElementVisibleTime"),
    bp = Symbol("lastPromptOffset"),
    _p = Symbol("focusedTime"),
    Ip = Symbol("zoomAdjustedFieldOfView"),
    Cp = Symbol("lastSpherical"),
    Mp = Symbol("jumpCamera"),
    Sp = Symbol("initialized"),
    Bp = Symbol("maintainThetaPhi"),
    Tp = Symbol("syncCameraOrbit"),
    Lp = Symbol("syncFieldOfView"),
    Rp = Symbol("syncCameraTarget"),
    Dp = Symbol("syncMinCameraOrbit"),
    Qp = Symbol("syncMaxCameraOrbit"),
    Pp = Symbol("syncMinFieldOfView"),
    Fp = Symbol("syncMaxFieldOfView");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Np = function Np(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var Up = Symbol("currentEnvironmentMap"),
    Gp = Symbol("applyEnvironmentMap"),
    kp = Symbol("updateEnvironment"),
    Op = Symbol("cancelEnvironmentUpdate"),
    Hp = Symbol("onPreload");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var zp, Vp;
var Wp = Symbol("modelViewerStatusInstance"),
    qp = Symbol("updateStatus");
zp = Wp, Vp = qp;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var jp = function jp(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var Yp = "auto",
    Jp = "manual",
    Xp = "auto",
    Kp = "eager",
    Zp = "interaction",
    $p = new ( /*#__PURE__*/function (_y15) {
  _inherits(_class8, _y15);

  var _super96 = _createSuper(_class8);

  function _class8() {
    var _this108;

    _classCallCheck(this, _class8);

    _this108 = _super96.call(this), _this108[zp] = null, _this108.registeredInstanceStatuses = new Map(), _this108.loadingPromises = [], _this108.statusElement = document.createElement("p"), _this108.statusUpdateInProgress = !1, _this108[Vp] = zl(function () {
      return _this108.updateStatus();
    }, 100);

    var _assertThisInitialize = _assertThisInitialized(_this108),
        t = _assertThisInitialize.statusElement,
        e = t.style;

    t.setAttribute("role", "status"), t.classList.add("screen-reader-only"), e.top = e.left = "0", e.pointerEvents = "none";
    return _this108;
  }

  _createClass(_class8, [{
    key: "registerInstance",
    value: function registerInstance(t) {
      if (this.registeredInstanceStatuses.has(t)) return;

      var e = function e() {};

      var n = !1 === t.loaded && !!t.src,
          i = new Promise(function (i) {
        if (!n) return void i();

        var r = function r() {
          i(), t.removeEventListener("load", r), t.removeEventListener("error", r);
        };

        t.addEventListener("load", r), t.addEventListener("error", r), e = r;
      });
      this.registeredInstanceStatuses.set(t, {
        onUnregistered: e
      }), this.loadingPromises.push(i), null == this.modelViewerStatusInstance && (this.modelViewerStatusInstance = t);
    }
  }, {
    key: "unregisterInstance",
    value: function unregisterInstance(t) {
      if (!this.registeredInstanceStatuses.has(t)) return;
      var e = this.registeredInstanceStatuses,
          n = e.get(t);
      e.delete(t), n.onUnregistered(), this.modelViewerStatusInstance === t && (this.modelViewerStatusInstance = e.size > 0 ? function (t) {
        if (null != t.keys) return t.keys().next().value || null;
        var e = null;

        try {
          t.forEach(function (t, n, i) {
            throw e = n, new Error();
          });
        } catch (t) {}

        return e;
      }(e) : null);
    }
  }, {
    key: "modelViewerStatusInstance",
    get: function get() {
      return this[Wp];
    },
    set: function set(t) {
      if (this[Wp] === t) return;
      var e = this.statusElement;
      null != t && null != t.shadowRoot ? t.shadowRoot.appendChild(e) : null != e.parentNode && e.parentNode.removeChild(e), this[Wp] = t, this[qp]();
    }
  }, {
    key: "updateStatus",
    value: function () {
      var _updateStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
        var _t360;

        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (!(!this.statusUpdateInProgress && 0 !== this.loadingPromises.length)) {
                  _context25.next = 10;
                  break;
                }

                this.statusElement.textContent = "This page includes one or more 3D models that are loading", this.statusUpdateInProgress = !0, this.dispatchEvent({
                  type: "initial-status-announced"
                });

              case 2:
                if (!this.loadingPromises.length) {
                  _context25.next = 9;
                  break;
                }

                _t360 = this.loadingPromises;
                this.loadingPromises = [];
                _context25.next = 7;
                return Promise.all(_t360);

              case 7:
                _context25.next = 2;
                break;

              case 9:
                this.statusElement.textContent = "All 3D models in the page have loaded", this.statusUpdateInProgress = !1, this.dispatchEvent({
                  type: "finished-loading-announced"
                });

              case 10:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function updateStatus() {
        return _updateStatus.apply(this, arguments);
      }

      return updateStatus;
    }()
  }]);

  return _class8;
}(y))(),
    tg = Symbol("defaultProgressBarElement"),
    eg = Symbol("defaultProgressMaskElement"),
    ng = Symbol("posterContainerElement"),
    ig = Symbol("defaultPosterElement"),
    rg = Symbol("posterDismissalSource"),
    sg = Symbol("hidePoster"),
    ag = Symbol("modelIsRevealed"),
    og = Symbol("updateProgressBar"),
    lg = Symbol("lastReportedProgress"),
    cg = Symbol("transitioned"),
    hg = Symbol("ariaLabelCallToAction"),
    ug = Symbol("onClick"),
    dg = Symbol("onKeydown"),
    Ag = Symbol("onProgress");

var pg = /*#__PURE__*/function () {
  function pg() {
    _classCallCheck(this, pg);

    this.pluginCallbacks = [], this.register(function (t) {
      return new Hg(t);
    }), this.register(function (t) {
      return new zg(t);
    }), this.register(function (t) {
      return new Vg(t);
    });
  }

  _createClass(pg, [{
    key: "register",
    value: function register(t) {
      return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
    }
  }, {
    key: "unregister",
    value: function unregister(t) {
      return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
    }
  }, {
    key: "parse",
    value: function parse(t, e, n) {
      var i = new Og(),
          r = [];

      for (var _t361 = 0, _e264 = this.pluginCallbacks.length; _t361 < _e264; _t361++) {
        r.push(this.pluginCallbacks[_t361](i));
      }

      i.setPlugins(r), i.write(t, e, n);
    }
  }]);

  return pg;
}();

var gg = 0,
    mg = 1,
    fg = 2,
    vg = 3,
    yg = 4,
    Eg = 5121,
    xg = 5123,
    wg = 5126,
    bg = 5125,
    _g = 34962,
    Ig = 34963,
    Cg = 9728,
    Mg = 9729,
    Sg = 9984,
    Bg = 9985,
    Tg = 9986,
    Lg = 9987,
    Rg = 33071,
    Dg = 33648,
    Qg = 10497,
    Pg = {};
Pg[1003] = Cg, Pg[1004] = Sg, Pg[1005] = Tg, Pg[1006] = Mg, Pg[1007] = Bg, Pg[1008] = Lg, Pg[1001] = Rg, Pg[1e3] = Qg, Pg[1002] = Dg;
var Fg = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
};

function Ng(t, e) {
  return t.length === e.length && t.every(function (t, n) {
    return t === e[n];
  });
}

function Ug(t) {
  return 4 * Math.ceil(t / 4);
}

function Gg(t) {
  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var n = Ug(t.byteLength);

  if (n !== t.byteLength) {
    var _i222 = new Uint8Array(n);

    if (_i222.set(new Uint8Array(t)), 0 !== e) for (var _r146 = t.byteLength; _r146 < n; _r146++) {
      _i222[_r146] = e;
    }
    return _i222.buffer;
  }

  return t;
}

var kg = null;

var Og = /*#__PURE__*/function () {
  function Og() {
    _classCallCheck(this, Og);

    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: new Map(),
      attributes: new Map(),
      attributesNormalized: new Map(),
      materials: new Map(),
      textures: new Map(),
      images: new Map()
    };
  }

  _createClass(Og, [{
    key: "setPlugins",
    value: function setPlugins(t) {
      this.plugins = t;
    }
  }, {
    key: "write",
    value: function write(t, e, n) {
      this.options = Object.assign({}, {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        embedImages: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      }, n), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(t);
      var i = this;
      Promise.all(this.pending).then(function () {
        var t = i.buffers,
            n = i.json,
            r = i.options,
            s = i.extensionsUsed,
            a = new Blob(t, {
          type: "application/octet-stream"
        }),
            o = Object.keys(s);

        if (o.length > 0 && (n.extensionsUsed = o), n.buffers && n.buffers.length > 0 && (n.buffers[0].byteLength = a.size), !0 === r.binary) {
          var _t362 = new window.FileReader();

          _t362.readAsArrayBuffer(a), _t362.onloadend = function () {
            var i = Gg(_t362.result),
                r = new DataView(new ArrayBuffer(8));
            r.setUint32(0, i.byteLength, !0), r.setUint32(4, 5130562, !0);
            var s = Gg(function (t) {
              if (void 0 !== window.TextEncoder) return new TextEncoder().encode(t).buffer;
              var e = new Uint8Array(new ArrayBuffer(t.length));

              for (var _n235 = 0, _i223 = t.length; _n235 < _i223; _n235++) {
                var _i224 = t.charCodeAt(_n235);

                e[_n235] = _i224 > 255 ? 32 : _i224;
              }

              return e.buffer;
            }(JSON.stringify(n)), 32),
                a = new DataView(new ArrayBuffer(8));
            a.setUint32(0, s.byteLength, !0), a.setUint32(4, 1313821514, !0);
            var o = new ArrayBuffer(12),
                l = new DataView(o);
            l.setUint32(0, 1179937895, !0), l.setUint32(4, 2, !0);
            var c = 12 + a.byteLength + s.byteLength + r.byteLength + i.byteLength;
            l.setUint32(8, c, !0);
            var h = new Blob([o, a, s, r, i], {
              type: "application/octet-stream"
            }),
                u = new window.FileReader();
            u.readAsArrayBuffer(h), u.onloadend = function () {
              e(u.result);
            };
          };
        } else if (n.buffers && n.buffers.length > 0) {
          var _t363 = new window.FileReader();

          _t363.readAsDataURL(a), _t363.onloadend = function () {
            var i = _t363.result;
            n.buffers[0].uri = i, e(n);
          };
        } else e(n);
      });
    }
  }, {
    key: "serializeUserData",
    value: function serializeUserData(t, e) {
      if (0 === Object.keys(t.userData).length) return;
      var n = this.options,
          i = this.extensionsUsed;

      try {
        var _r147 = JSON.parse(JSON.stringify(t.userData));

        if (n.includeCustomExtensions && _r147.gltfExtensions) {
          void 0 === e.extensions && (e.extensions = {});

          for (var _t364 in _r147.gltfExtensions) {
            e.extensions[_t364] = _r147.gltfExtensions[_t364], i[_t364] = !0;
          }

          delete _r147.gltfExtensions;
        }

        Object.keys(_r147).length > 0 && (e.extras = _r147);
      } catch (e) {
        console.warn("THREE.GLTFExporter: userData of '" + t.name + "' won't be serialized because of JSON.stringify error - " + e.message);
      }
    }
  }, {
    key: "getUID",
    value: function getUID(t) {
      return this.uids.has(t) || this.uids.set(t, this.uid++), this.uids.get(t);
    }
  }, {
    key: "isNormalizedNormalAttribute",
    value: function isNormalizedNormalAttribute(t) {
      if (this.cache.attributesNormalized.has(t)) return !1;
      var e = new H();

      for (var n = 0, _i225 = t.count; n < _i225; n++) {
        if (Math.abs(e.fromBufferAttribute(t, n).length() - 1) > 5e-4) return !1;
      }

      return !0;
    }
  }, {
    key: "createNormalizedNormalAttribute",
    value: function createNormalizedNormalAttribute(t) {
      var e = this.cache;
      if (e.attributesNormalized.has(t)) return e.attributesNormalized.get(t);
      var n = t.clone(),
          i = new H();

      for (var _t365 = 0, _e265 = n.count; _t365 < _e265; _t365++) {
        i.fromBufferAttribute(n, _t365), 0 === i.x && 0 === i.y && 0 === i.z ? i.setX(1) : i.normalize(), n.setXYZ(_t365, i.x, i.y, i.z);
      }

      return e.attributesNormalized.set(t, n), n;
    }
  }, {
    key: "applyTextureTransform",
    value: function applyTextureTransform(t, e) {
      var n = !1;
      var i = {};
      0 === e.offset.x && 0 === e.offset.y || (i.offset = e.offset.toArray(), n = !0), 0 !== e.rotation && (i.rotation = e.rotation, n = !0), 1 === e.repeat.x && 1 === e.repeat.y || (i.scale = e.repeat.toArray(), n = !0), n && (t.extensions = t.extensions || {}, t.extensions.KHR_texture_transform = i, this.extensionsUsed.KHR_texture_transform = !0);
    }
  }, {
    key: "processBuffer",
    value: function processBuffer(t) {
      var e = this.json,
          n = this.buffers;
      return e.buffers || (e.buffers = [{
        byteLength: 0
      }]), n.push(t), 0;
    }
  }, {
    key: "processBufferView",
    value: function processBufferView(t, e, n, i, r) {
      var s = this.json;
      var a;
      s.bufferViews || (s.bufferViews = []), a = e === Eg ? 1 : e === xg ? 2 : 4;
      var o = Ug(i * t.itemSize * a),
          l = new DataView(new ArrayBuffer(o));
      var c = 0;

      for (var _r148 = n; _r148 < n + i; _r148++) {
        for (var _n236 = 0; _n236 < t.itemSize; _n236++) {
          var _i226 = void 0;

          t.itemSize > 4 ? _i226 = t.array[_r148 * t.itemSize + _n236] : 0 === _n236 ? _i226 = t.getX(_r148) : 1 === _n236 ? _i226 = t.getY(_r148) : 2 === _n236 ? _i226 = t.getZ(_r148) : 3 === _n236 && (_i226 = t.getW(_r148)), e === wg ? l.setFloat32(c, _i226, !0) : e === bg ? l.setUint32(c, _i226, !0) : e === xg ? l.setUint16(c, _i226, !0) : e === Eg && l.setUint8(c, _i226), c += a;
        }
      }

      var h = {
        buffer: this.processBuffer(l.buffer),
        byteOffset: this.byteOffset,
        byteLength: o
      };
      void 0 !== r && (h.target = r), r === _g && (h.byteStride = t.itemSize * a), this.byteOffset += o, s.bufferViews.push(h);
      return {
        id: s.bufferViews.length - 1,
        byteLength: 0
      };
    }
  }, {
    key: "processBufferViewImage",
    value: function processBufferViewImage(t) {
      var e = this,
          n = e.json;
      return n.bufferViews || (n.bufferViews = []), new Promise(function (i) {
        var r = new window.FileReader();
        r.readAsArrayBuffer(t), r.onloadend = function () {
          var t = Gg(r.result),
              s = {
            buffer: e.processBuffer(t),
            byteOffset: e.byteOffset,
            byteLength: t.byteLength
          };
          e.byteOffset += t.byteLength, i(n.bufferViews.push(s) - 1);
        };
      });
    }
  }, {
    key: "processAccessor",
    value: function processAccessor(t, e, n, i) {
      var r = this.options,
          s = this.json;
      var a;
      if (t.array.constructor === Float32Array) a = wg;else if (t.array.constructor === Uint32Array) a = bg;else if (t.array.constructor === Uint16Array) a = xg;else {
        if (t.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
        a = Eg;
      }

      if (void 0 === n && (n = 0), void 0 === i && (i = t.count), r.truncateDrawRange && void 0 !== e && null === e.index) {
        var _r149 = n + i,
            _s77 = e.drawRange.count === 1 / 0 ? t.count : e.drawRange.start + e.drawRange.count;

        n = Math.max(n, e.drawRange.start), (i = Math.min(_r149, _s77) - n) < 0 && (i = 0);
      }

      if (0 === i) return null;

      var o = function (t, e, n) {
        var i = {
          min: new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),
          max: new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)
        };

        for (var _r150 = e; _r150 < e + n; _r150++) {
          for (var _e266 = 0; _e266 < t.itemSize; _e266++) {
            var _n237 = void 0;

            t.itemSize > 4 ? _n237 = t.array[_r150 * t.itemSize + _e266] : 0 === _e266 ? _n237 = t.getX(_r150) : 1 === _e266 ? _n237 = t.getY(_r150) : 2 === _e266 ? _n237 = t.getZ(_r150) : 3 === _e266 && (_n237 = t.getW(_r150)), i.min[_e266] = Math.min(i.min[_e266], _n237), i.max[_e266] = Math.max(i.max[_e266], _n237);
          }
        }

        return i;
      }(t, n, i);

      var l;
      void 0 !== e && (l = t === e.index ? Ig : _g);
      var c = this.processBufferView(t, a, n, i, l),
          h = {
        bufferView: c.id,
        byteOffset: c.byteOffset,
        componentType: a,
        count: i,
        max: o.max,
        min: o.min,
        type: {
          1: "SCALAR",
          2: "VEC2",
          3: "VEC3",
          4: "VEC4",
          16: "MAT4"
        }[t.itemSize]
      };
      return !0 === t.normalized && (h.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(h) - 1;
    }
  }, {
    key: "processImage",
    value: function processImage(t, e, n) {
      var i = this,
          r = i.cache,
          s = i.json,
          a = i.options,
          o = i.pending;
      r.images.has(t) || r.images.set(t, {});
      var l = r.images.get(t),
          c = 1023 === e ? "image/png" : "image/jpeg",
          h = c + ":flipY/" + n.toString();
      if (void 0 !== l[h]) return l[h];
      s.images || (s.images = []);
      var u = {
        mimeType: c
      };

      if (a.embedImages) {
        var _r151 = kg = kg || document.createElement("canvas");

        _r151.width = Math.min(t.width, a.maxTextureSize), _r151.height = Math.min(t.height, a.maxTextureSize);

        var _s78 = _r151.getContext("2d");

        if (!0 === n && (_s78.translate(0, _r151.height), _s78.scale(1, -1)), "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) _s78.drawImage(t, 0, 0, _r151.width, _r151.height);else {
          1023 !== e && 1022 !== e && console.error("GLTFExporter: Only RGB and RGBA formats are supported."), (t.width > a.maxTextureSize || t.height > a.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", t);
          var _n238 = t.data;

          if (1022 === e) {
            _n238 = new Uint8ClampedArray(t.height * t.width * 4);

            for (var _e267 = 0, _i227 = 0; _e267 < _n238.length; _e267 += 4, _i227 += 3) {
              _n238[_e267 + 0] = t.data[_i227 + 0], _n238[_e267 + 1] = t.data[_i227 + 1], _n238[_e267 + 2] = t.data[_i227 + 2], _n238[_e267 + 3] = 255;
            }
          }

          _s78.putImageData(new ImageData(_n238, t.width, t.height), 0, 0);
        }
        !0 === a.binary ? o.push(new Promise(function (t) {
          _r151.toBlob(function (e) {
            i.processBufferViewImage(e).then(function (e) {
              u.bufferView = e, t();
            });
          }, c);
        })) : u.uri = _r151.toDataURL(c);
      } else u.uri = t.src;

      var d = s.images.push(u) - 1;
      return l[h] = d, d;
    }
  }, {
    key: "processSampler",
    value: function processSampler(t) {
      var e = this.json;
      e.samplers || (e.samplers = []);
      var n = {
        magFilter: Pg[t.magFilter],
        minFilter: Pg[t.minFilter],
        wrapS: Pg[t.wrapS],
        wrapT: Pg[t.wrapT]
      };
      return e.samplers.push(n) - 1;
    }
  }, {
    key: "processTexture",
    value: function processTexture(t) {
      var e = this.cache,
          n = this.json;
      if (e.textures.has(t)) return e.textures.get(t);
      n.textures || (n.textures = []);
      var i = {
        sampler: this.processSampler(t),
        source: this.processImage(t.image, t.format, t.flipY)
      };
      t.name && (i.name = t.name), this._invokeAll(function (e) {
        e.writeTexture && e.writeTexture(t, i);
      });
      var r = n.textures.push(i) - 1;
      return e.textures.set(t, r), r;
    }
  }, {
    key: "processMaterial",
    value: function processMaterial(t) {
      var e = this.cache,
          n = this.json;
      if (e.materials.has(t)) return e.materials.get(t);
      if (t.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
      n.materials || (n.materials = []);
      var i = {
        pbrMetallicRoughness: {}
      };
      !0 !== t.isMeshStandardMaterial && !0 !== t.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
      var r = t.color.toArray().concat([t.opacity]);
      if (Ng(r, [1, 1, 1, 1]) || (i.pbrMetallicRoughness.baseColorFactor = r), t.isMeshStandardMaterial ? (i.pbrMetallicRoughness.metallicFactor = t.metalness, i.pbrMetallicRoughness.roughnessFactor = t.roughness) : (i.pbrMetallicRoughness.metallicFactor = .5, i.pbrMetallicRoughness.roughnessFactor = .5), t.metalnessMap || t.roughnessMap) if (t.metalnessMap === t.roughnessMap) {
        var _e268 = {
          index: this.processTexture(t.metalnessMap)
        };
        this.applyTextureTransform(_e268, t.metalnessMap), i.pbrMetallicRoughness.metallicRoughnessTexture = _e268;
      } else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");

      if (t.map) {
        var _e269 = {
          index: this.processTexture(t.map)
        };
        this.applyTextureTransform(_e269, t.map), i.pbrMetallicRoughness.baseColorTexture = _e269;
      }

      if (t.emissive) {
        var _e270 = t.emissive.clone().multiplyScalar(t.emissiveIntensity).toArray();

        if (Ng(_e270, [0, 0, 0]) || (i.emissiveFactor = _e270), t.emissiveMap) {
          var _e271 = {
            index: this.processTexture(t.emissiveMap)
          };
          this.applyTextureTransform(_e271, t.emissiveMap), i.emissiveTexture = _e271;
        }
      }

      if (t.normalMap) {
        var _e272 = {
          index: this.processTexture(t.normalMap)
        };
        t.normalScale && -1 !== t.normalScale.x && (t.normalScale.x !== t.normalScale.y && console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."), _e272.scale = t.normalScale.x), this.applyTextureTransform(_e272, t.normalMap), i.normalTexture = _e272;
      }

      if (t.aoMap) {
        var _e273 = {
          index: this.processTexture(t.aoMap),
          texCoord: 1
        };
        1 !== t.aoMapIntensity && (_e273.strength = t.aoMapIntensity), this.applyTextureTransform(_e273, t.aoMap), i.occlusionTexture = _e273;
      }

      t.transparent ? i.alphaMode = "BLEND" : t.alphaTest > 0 && (i.alphaMode = "MASK", i.alphaCutoff = t.alphaTest), 2 === t.side && (i.doubleSided = !0), "" !== t.name && (i.name = t.name), this.serializeUserData(t, i), this._invokeAll(function (e) {
        e.writeMaterial && e.writeMaterial(t, i);
      });
      var s = n.materials.push(i) - 1;
      return e.materials.set(t, s), s;
    }
  }, {
    key: "processMesh",
    value: function processMesh(t) {
      var e = this.cache,
          n = this.json,
          i = [t.geometry.uuid];
      if (Array.isArray(t.material)) for (var _e274 = 0, _n239 = t.material.length; _e274 < _n239; _e274++) {
        i.push(t.material[_e274].uuid);
      } else i.push(t.material.uuid);
      var r = i.join(":");
      if (e.meshes.has(r)) return e.meshes.get(r);
      var s = t.geometry;
      var a;
      if (a = t.isLineSegments ? mg : t.isLineLoop ? fg : t.isLine ? vg : t.isPoints ? gg : t.material.wireframe ? mg : yg, !0 !== s.isBufferGeometry) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
      var o = {},
          l = {},
          c = [],
          h = [],
          u = {
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1",
        color: "COLOR_0",
        skinWeight: "WEIGHTS_0",
        skinIndex: "JOINTS_0"
      },
          d = s.getAttribute("normal");
      void 0 === d || this.isNormalizedNormalAttribute(d) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), s.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
      var A = null;

      for (var _t366 in s.attributes) {
        if ("morph" === _t366.substr(0, 5)) continue;
        var _n240 = s.attributes[_t366];
        _t366 = u[_t366] || _t366.toUpperCase();

        if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(_t366) || (_t366 = "_" + _t366), e.attributes.has(this.getUID(_n240))) {
          l[_t366] = e.attributes.get(this.getUID(_n240));
          continue;
        }

        A = null;
        var _i228 = _n240.array;
        "JOINTS_0" !== _t366 || _i228 instanceof Uint16Array || _i228 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), A = new ve(new Uint16Array(_i228), _n240.itemSize, _n240.normalized));

        var _r152 = this.processAccessor(A || _n240, s);

        null !== _r152 && (l[_t366] = _r152, e.attributes.set(this.getUID(_n240), _r152));
      }

      if (void 0 !== d && s.setAttribute("normal", d), 0 === Object.keys(l).length) return null;

      if (void 0 !== t.morphTargetInfluences && t.morphTargetInfluences.length > 0) {
        var _n241 = [],
            _i229 = [],
            _r153 = {};
        if (void 0 !== t.morphTargetDictionary) for (var _e275 in t.morphTargetDictionary) {
          _r153[t.morphTargetDictionary[_e275]] = _e275;
        }

        for (var _a61 = 0; _a61 < t.morphTargetInfluences.length; ++_a61) {
          var _o40 = {};

          var _l40 = !1;

          for (var _t367 in s.morphAttributes) {
            if ("position" !== _t367 && "normal" !== _t367) {
              _l40 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), _l40 = !0);
              continue;
            }

            var _n242 = s.morphAttributes[_t367][_a61],
                _i230 = _t367.toUpperCase(),
                _r154 = s.attributes[_t367];

            if (e.attributes.has(this.getUID(_n242))) {
              _o40[_i230] = e.attributes.get(this.getUID(_n242));
              continue;
            }

            var _c33 = _n242.clone();

            if (!s.morphTargetsRelative) for (var _t368 = 0, _e276 = _n242.count; _t368 < _e276; _t368++) {
              _c33.setXYZ(_t368, _n242.getX(_t368) - _r154.getX(_t368), _n242.getY(_t368) - _r154.getY(_t368), _n242.getZ(_t368) - _r154.getZ(_t368));
            }
            _o40[_i230] = this.processAccessor(_c33, s), e.attributes.set(this.getUID(_r154), _o40[_i230]);
          }

          h.push(_o40), _n241.push(t.morphTargetInfluences[_a61]), void 0 !== t.morphTargetDictionary && _i229.push(_r153[_a61]);
        }

        o.weights = _n241, _i229.length > 0 && (o.extras = {}, o.extras.targetNames = _i229);
      }

      var p = Array.isArray(t.material);
      if (p && 0 === s.groups.length) return null;
      var g = p ? t.material : [t.material],
          m = p ? s.groups : [{
        materialIndex: 0,
        start: void 0,
        count: void 0
      }];

      for (var _t369 = 0, _n243 = m.length; _t369 < _n243; _t369++) {
        var _n244 = {
          mode: a,
          attributes: l
        };

        if (this.serializeUserData(s, _n244), h.length > 0 && (_n244.targets = h), null !== s.index) {
          var _i232 = this.getUID(s.index);

          void 0 === m[_t369].start && void 0 === m[_t369].count || (_i232 += ":" + m[_t369].start + ":" + m[_t369].count), e.attributes.has(_i232) ? _n244.indices = e.attributes.get(_i232) : (_n244.indices = this.processAccessor(s.index, s, m[_t369].start, m[_t369].count), e.attributes.set(_i232, _n244.indices)), null === _n244.indices && delete _n244.indices;
        }

        var _i231 = this.processMaterial(g[m[_t369].materialIndex]);

        null !== _i231 && (_n244.material = _i231), c.push(_n244);
      }

      o.primitives = c, n.meshes || (n.meshes = []), this._invokeAll(function (e) {
        e.writeMesh && e.writeMesh(t, o);
      });
      var f = n.meshes.push(o) - 1;
      return e.meshes.set(r, f), f;
    }
  }, {
    key: "processCamera",
    value: function processCamera(t) {
      var e = this.json;
      e.cameras || (e.cameras = []);
      var n = t.isOrthographicCamera,
          i = {
        type: n ? "orthographic" : "perspective"
      };
      return n ? i.orthographic = {
        xmag: 2 * t.right,
        ymag: 2 * t.top,
        zfar: t.far <= 0 ? .001 : t.far,
        znear: t.near < 0 ? 0 : t.near
      } : i.perspective = {
        aspectRatio: t.aspect,
        yfov: L.degToRad(t.fov),
        zfar: t.far <= 0 ? .001 : t.far,
        znear: t.near < 0 ? 0 : t.near
      }, "" !== t.name && (i.name = t.type), e.cameras.push(i) - 1;
    }
  }, {
    key: "processAnimation",
    value: function processAnimation(t, e) {
      var n = this.json,
          i = this.nodeMap;
      n.animations || (n.animations = []);
      var r = (t = pg.Utils.mergeMorphTargetTracks(t.clone(), e)).tracks,
          s = [],
          a = [];

      for (var _t370 = 0; _t370 < r.length; ++_t370) {
        var _n245 = r[_t370],
            _o41 = la.parseTrackName(_n245.name);

        var _l41 = la.findNode(e, _o41.nodeName);

        var _c34 = Fg[_o41.propertyName];
        if ("bones" === _o41.objectName && (_l41 = !0 === _l41.isSkinnedMesh ? _l41.skeleton.getBoneByName(_o41.objectIndex) : void 0), !_l41 || !_c34) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', _n245.name), null;
        var _h15 = 1;

        var _u15 = void 0,
            _d14 = _n245.values.length / _n245.times.length;

        _c34 === Fg.morphTargetInfluences && (_d14 /= _l41.morphTargetInfluences.length), !0 === _n245.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (_u15 = "CUBICSPLINE", _d14 /= 3) : _u15 = 2300 === _n245.getInterpolation() ? "STEP" : "LINEAR", a.push({
          input: this.processAccessor(new ve(_n245.times, _h15)),
          output: this.processAccessor(new ve(_n245.values, _d14)),
          interpolation: _u15
        }), s.push({
          sampler: a.length - 1,
          target: {
            node: i.get(_l41),
            path: _c34
          }
        });
      }

      return n.animations.push({
        name: t.name || "clip_" + n.animations.length,
        samplers: a,
        channels: s
      }), n.animations.length - 1;
    }
  }, {
    key: "processSkin",
    value: function processSkin(t) {
      var e = this.json,
          n = this.nodeMap,
          i = e.nodes[n.get(t)],
          r = t.skeleton;
      if (void 0 === r) return null;
      var s = t.skeleton.bones[0];
      if (void 0 === s) return null;
      var a = [],
          o = new Float32Array(16 * r.bones.length),
          l = new yt();

      for (var _e277 = 0; _e277 < r.bones.length; ++_e277) {
        a.push(n.get(r.bones[_e277])), l.copy(r.boneInverses[_e277]), l.multiply(t.bindMatrix).toArray(o, 16 * _e277);
      }

      void 0 === e.skins && (e.skins = []), e.skins.push({
        inverseBindMatrices: this.processAccessor(new ve(o, 16)),
        joints: a,
        skeleton: n.get(s)
      });
      return i.skin = e.skins.length - 1;
    }
  }, {
    key: "processNode",
    value: function processNode(t) {
      var e = this.json,
          n = this.options,
          i = this.nodeMap;
      e.nodes || (e.nodes = []);
      var r = {};

      if (n.trs) {
        var _e278 = t.quaternion.toArray(),
            _n246 = t.position.toArray(),
            _i233 = t.scale.toArray();

        Ng(_e278, [0, 0, 0, 1]) || (r.rotation = _e278), Ng(_n246, [0, 0, 0]) || (r.translation = _n246), Ng(_i233, [1, 1, 1]) || (r.scale = _i233);
      } else t.matrixAutoUpdate && t.updateMatrix(), !1 === Ng(t.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (r.matrix = t.matrix.elements);

      if ("" !== t.name && (r.name = String(t.name)), this.serializeUserData(t, r), t.isMesh || t.isLine || t.isPoints) {
        var _e279 = this.processMesh(t);

        null !== _e279 && (r.mesh = _e279);
      } else t.isCamera && (r.camera = this.processCamera(t));

      if (t.isSkinnedMesh && this.skins.push(t), t.children.length > 0) {
        var _e280 = [];

        for (var _i234 = 0, _r155 = t.children.length; _i234 < _r155; _i234++) {
          var _r156 = t.children[_i234];

          if (_r156.visible || !1 === n.onlyVisible) {
            var _t371 = this.processNode(_r156);

            null !== _t371 && _e280.push(_t371);
          }
        }

        _e280.length > 0 && (r.children = _e280);
      }

      this._invokeAll(function (e) {
        e.writeNode && e.writeNode(t, r);
      });

      var s = e.nodes.push(r) - 1;
      return i.set(t, s), s;
    }
  }, {
    key: "processScene",
    value: function processScene(t) {
      var e = this.json,
          n = this.options;
      e.scenes || (e.scenes = [], e.scene = 0);
      var i = {};
      "" !== t.name && (i.name = t.name), e.scenes.push(i);
      var r = [];

      for (var _e281 = 0, _i235 = t.children.length; _e281 < _i235; _e281++) {
        var _i236 = t.children[_e281];

        if (_i236.visible || !1 === n.onlyVisible) {
          var _t372 = this.processNode(_i236);

          null !== _t372 && r.push(_t372);
        }
      }

      r.length > 0 && (i.nodes = r), this.serializeUserData(t, i);
    }
  }, {
    key: "processObjects",
    value: function processObjects(t) {
      var e = new Mr();
      e.name = "AuxScene";

      for (var n = 0; n < t.length; n++) {
        e.children.push(t[n]);
      }

      this.processScene(e);
    }
  }, {
    key: "processInput",
    value: function processInput(t) {
      var e = this.options;
      t = t instanceof Array ? t : [t], this._invokeAll(function (e) {
        e.beforeParse && e.beforeParse(t);
      });
      var n = [];

      for (var _e282 = 0; _e282 < t.length; _e282++) {
        t[_e282] instanceof Mr ? this.processScene(t[_e282]) : n.push(t[_e282]);
      }

      n.length > 0 && this.processObjects(n);

      for (var _t373 = 0; _t373 < this.skins.length; ++_t373) {
        this.processSkin(this.skins[_t373]);
      }

      for (var _n247 = 0; _n247 < e.animations.length; ++_n247) {
        this.processAnimation(e.animations[_n247], t[0]);
      }

      this._invokeAll(function (e) {
        e.afterParse && e.afterParse(t);
      });
    }
  }, {
    key: "_invokeAll",
    value: function _invokeAll(t) {
      for (var _e283 = 0, n = this.plugins.length; _e283 < n; _e283++) {
        t(this.plugins[_e283]);
      }
    }
  }]);

  return Og;
}();

var Hg = /*#__PURE__*/function () {
  function Hg(t) {
    _classCallCheck(this, Hg);

    this.writer = t, this.name = "KHR_lights_punctual";
  }

  _createClass(Hg, [{
    key: "writeNode",
    value: function writeNode(t, e) {
      if (!t.isLight) return;
      if (!t.isDirectionalLight && !t.isPointLight && !t.isSpotLight) return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", t);
      var n = this.writer,
          i = n.json,
          r = n.extensionsUsed,
          s = {};
      t.name && (s.name = t.name), s.color = t.color.toArray(), s.intensity = t.intensity, t.isDirectionalLight ? s.type = "directional" : t.isPointLight ? (s.type = "point", t.distance > 0 && (s.range = t.distance)) : t.isSpotLight && (s.type = "spot", t.distance > 0 && (s.range = t.distance), s.spot = {}, s.spot.innerConeAngle = (t.penumbra - 1) * t.angle * -1, s.spot.outerConeAngle = t.angle), void 0 !== t.decay && 2 !== t.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !t.target || t.target.parent === t && 0 === t.target.position.x && 0 === t.target.position.y && -1 === t.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), r[this.name] || (i.extensions = i.extensions || {}, i.extensions[this.name] = {
        lights: []
      }, r[this.name] = !0);
      var a = i.extensions[this.name].lights;
      a.push(s), e.extensions = e.extensions || {}, e.extensions[this.name] = {
        light: a.length - 1
      };
    }
  }]);

  return Hg;
}();

var zg = /*#__PURE__*/function () {
  function zg(t) {
    _classCallCheck(this, zg);

    this.writer = t, this.name = "KHR_materials_unlit";
  }

  _createClass(zg, [{
    key: "writeMaterial",
    value: function writeMaterial(t, e) {
      if (!t.isMeshBasicMaterial) return;
      var n = this.writer.extensionsUsed;
      e.extensions = e.extensions || {}, e.extensions[this.name] = {}, n[this.name] = !0, e.pbrMetallicRoughness.metallicFactor = 0, e.pbrMetallicRoughness.roughnessFactor = .9;
    }
  }]);

  return zg;
}();

var Vg = /*#__PURE__*/function () {
  function Vg(t) {
    _classCallCheck(this, Vg);

    this.writer = t, this.name = "KHR_materials_pbrSpecularGlossiness";
  }

  _createClass(Vg, [{
    key: "writeMaterial",
    value: function writeMaterial(t, e) {
      if (!t.isGLTFSpecularGlossinessMaterial) return;
      var n = this.writer,
          i = n.extensionsUsed,
          r = {};
      e.pbrMetallicRoughness.baseColorFactor && (r.diffuseFactor = e.pbrMetallicRoughness.baseColorFactor);
      var s = [1, 1, 1];

      if (t.specular.toArray(s, 0), r.specularFactor = s, r.glossinessFactor = t.glossiness, e.pbrMetallicRoughness.baseColorTexture && (r.diffuseTexture = e.pbrMetallicRoughness.baseColorTexture), t.specularMap) {
        var _e284 = {
          index: n.processTexture(t.specularMap)
        };
        n.applyTextureTransform(_e284, t.specularMap), r.specularGlossinessTexture = _e284;
      }

      e.extensions = e.extensions || {}, e.extensions[this.name] = r, i[this.name] = !0;
    }
  }]);

  return Vg;
}();

pg.Utils = {
  insertKeyframe: function insertKeyframe(t, e) {
    var n = .001,
        i = t.getValueSize(),
        r = new t.TimeBufferType(t.times.length + 1),
        s = new t.ValueBufferType(t.values.length + i),
        a = t.createInterpolant(new t.ValueBufferType(i));
    var o;

    if (0 === t.times.length) {
      r[0] = e;

      for (var _t374 = 0; _t374 < i; _t374++) {
        s[_t374] = 0;
      }

      o = 0;
    } else if (e < t.times[0]) {
      if (Math.abs(t.times[0] - e) < n) return 0;
      r[0] = e, r.set(t.times, 1), s.set(a.evaluate(e), 0), s.set(t.values, i), o = 0;
    } else if (e > t.times[t.times.length - 1]) {
      if (Math.abs(t.times[t.times.length - 1] - e) < n) return t.times.length - 1;
      r[r.length - 1] = e, r.set(t.times, 0), s.set(t.values, 0), s.set(a.evaluate(e), t.values.length), o = r.length - 1;
    } else for (var _l42 = 0; _l42 < t.times.length; _l42++) {
      if (Math.abs(t.times[_l42] - e) < n) return _l42;

      if (t.times[_l42] < e && t.times[_l42 + 1] > e) {
        r.set(t.times.slice(0, _l42 + 1), 0), r[_l42 + 1] = e, r.set(t.times.slice(_l42 + 1), _l42 + 2), s.set(t.values.slice(0, (_l42 + 1) * i), 0), s.set(a.evaluate(e), (_l42 + 1) * i), s.set(t.values.slice((_l42 + 1) * i), (_l42 + 2) * i), o = _l42 + 1;
        break;
      }
    }

    return t.times = r, t.values = s, o;
  },
  mergeMorphTargetTracks: function mergeMorphTargetTracks(t, e) {
    var n = [],
        i = {},
        r = t.tracks;

    for (var _t375 = 0; _t375 < r.length; ++_t375) {
      var _s79 = r[_t375];

      var _a62 = la.parseTrackName(_s79.name),
          _o42 = la.findNode(e, _a62.nodeName);

      if ("morphTargetInfluences" !== _a62.propertyName || void 0 === _a62.propertyIndex) {
        n.push(_s79);
        continue;
      }

      if (_s79.createInterpolant !== _s79.InterpolantFactoryMethodDiscrete && _s79.createInterpolant !== _s79.InterpolantFactoryMethodLinear) {
        if (_s79.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), _s79 = _s79.clone(), _s79.setInterpolation(2301);
      }

      var _l43 = _o42.morphTargetInfluences.length,
          _c35 = _o42.morphTargetDictionary[_a62.propertyIndex];
      if (void 0 === _c35) throw new Error("THREE.GLTFExporter: Morph target name not found: " + _a62.propertyIndex);

      var _h16 = void 0;

      if (void 0 === i[_o42.uuid]) {
        _h16 = _s79.clone();

        var _t376 = new _h16.ValueBufferType(_l43 * _h16.times.length);

        for (var _e285 = 0; _e285 < _h16.times.length; _e285++) {
          _t376[_e285 * _l43 + _c35] = _h16.values[_e285];
        }

        _h16.name = (_a62.nodeName || "") + ".morphTargetInfluences", _h16.values = _t376, i[_o42.uuid] = _h16, n.push(_h16);
        continue;
      }

      var _u16 = _s79.createInterpolant(new _s79.ValueBufferType(1));

      _h16 = i[_o42.uuid];

      for (var _t377 = 0; _t377 < _h16.times.length; _t377++) {
        _h16.values[_t377 * _l43 + _c35] = _u16.evaluate(_h16.times[_t377]);
      }

      for (var _t378 = 0; _t378 < _s79.times.length; _t378++) {
        var _e286 = this.insertKeyframe(_h16, _s79.times[_t378]);

        _h16.values[_e286 * _l43 + _c35] = _s79.values[_t378];
      }
    }

    return t.tracks = n, t;
  }
};
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Wg = Symbol("correlatedObjects"),
    qg = Symbol("sourceObject"),
    jg = Symbol("onUpdate");

var Yg = function Yg(t, e) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  _classCallCheck(this, Yg);

  this[jg] = t, this[qg] = e, this[Wg] = n;
};
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Jg, Xg;
var Kg = new Rs(),
    Zg = Symbol("threeTextures"),
    $g = Symbol("uri"),
    tm = Symbol("bufferViewImages");

var em = /*#__PURE__*/function (_Yg) {
  _inherits(em, _Yg);

  var _super97 = _createSuper(em);

  function em(t, e, n) {
    var _this109;

    _classCallCheck(this, em);

    if (_this109 = _super97.call(this, t, e, n), _this109[Jg] = void 0, _this109[Xg] = new WeakMap(), null != e.uri && (_this109[$g] = e.uri), null != e.bufferView) {
      var _iterator23 = _createForOfIteratorHelper(n),
          _step23;

      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var _t379 = _step23.value;

          _this109[tm].set(_t379, _t379.image);
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    }

    return _possibleConstructorReturn(_this109);
  }

  _createClass(em, [{
    key: Zg,
    get: function get() {
      return this[Wg];
    }
  }, {
    key: "name",
    get: function get() {
      return this[qg].name || "";
    }
  }, {
    key: "uri",
    get: function get() {
      return this[$g];
    }
  }, {
    key: "type",
    get: function get() {
      return null != this.uri ? "external" : "embedded";
    }
  }, {
    key: "setURI",
    value: function () {
      var _setURI = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(t) {
        var e, _iterator24, _step24, _t380;

        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                this[$g] = t;
                _context26.next = 3;
                return new Promise(function (e, n) {
                  Kg.load(t, e, void 0, n);
                });

              case 3:
                e = _context26.sent;
                _iterator24 = _createForOfIteratorHelper(this[Zg]);

                try {
                  for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                    _t380 = _step24.value;
                    null == e && null != this[qg].bufferView ? _t380.image = this[tm].get(_t380) : _t380.image = e, _t380.needsUpdate = !0;
                  }
                } catch (err) {
                  _iterator24.e(err);
                } finally {
                  _iterator24.f();
                }

                this[jg]();

              case 7:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function setURI(_x23) {
        return _setURI.apply(this, arguments);
      }

      return setURI;
    }()
  }]);

  return em;
}(Yg);

Jg = $g, Xg = tm;
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var nm = function () {
  var t = [9728, 9729, 9984, 9985, 9986, 9987];
  return function (e) {
    return t.indexOf(e) > -1;
  };
}(),
    im = function () {
  var t = [9728, 9729];
  return function (e) {
    return t.indexOf(e) > -1;
  };
}(),
    rm = function () {
  var t = [33071, 33648, 10497];
  return function (e) {
    return t.indexOf(e) > -1;
  };
}(),
    sm = Symbol("threeTextures"),
    am = Symbol("setProperty");

var om = /*#__PURE__*/function (_Yg2) {
  _inherits(om, _Yg2);

  var _super98 = _createSuper(om);

  function om(t, e, n) {
    var _this110;

    _classCallCheck(this, om);

    null == e.minFilter && (e.minFilter = 9987), null == e.magFilter && (e.magFilter = 9729), null == e.wrapS && (e.wrapS = 10497), null == e.wrapT && (e.wrapT = 10497), _this110 = _super98.call(this, t, e, n);
    return _this110;
  }

  _createClass(om, [{
    key: sm,
    get: function get() {
      return this[Wg];
    }
  }, {
    key: "name",
    get: function get() {
      return this[qg].name || "";
    }
  }, {
    key: "minFilter",
    get: function get() {
      return this[qg].minFilter;
    }
  }, {
    key: "magFilter",
    get: function get() {
      return this[qg].magFilter;
    }
  }, {
    key: "wrapS",
    get: function get() {
      return this[qg].wrapS;
    }
  }, {
    key: "wrapT",
    get: function get() {
      return this[qg].wrapT;
    }
  }, {
    key: "setMinFilter",
    value: function setMinFilter(t) {
      this[am]("minFilter", t);
    }
  }, {
    key: "setMagFilter",
    value: function setMagFilter(t) {
      this[am]("magFilter", t);
    }
  }, {
    key: "setWrapS",
    value: function setWrapS(t) {
      this[am]("wrapS", t);
    }
  }, {
    key: "setWrapT",
    value: function setWrapT(t) {
      this[am]("wrapT", t);
    }
  }, {
    key: am,
    value: function value(t, e) {
      var n = this[qg];

      if (function (t, e) {
        switch (t) {
          case "minFilter":
            return nm(e);

          case "magFilter":
            return im(e);

          case "wrapS":
          case "wrapT":
            return rm(e);

          default:
            throw new Error("Cannot configure property \"".concat(t, "\" on Sampler"));
        }
      }(t, e)) {
        n[t] = e;

        var _iterator25 = _createForOfIteratorHelper(this[sm]),
            _step25;

        try {
          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
            var _n248 = _step25.value;
            _n248[t] = e, _n248.needsUpdate = !0;
          }
        } catch (err) {
          _iterator25.e(err);
        } finally {
          _iterator25.f();
        }
      }

      this[jg]();
    }
  }]);

  return om;
}(Yg);
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var lm = Symbol("source"),
    cm = Symbol("sampler");

var hm = /*#__PURE__*/function (_Yg3) {
  _inherits(hm, _Yg3);

  var _super99 = _createSuper(hm);

  function hm(t, e, n, i) {
    var _this111;

    _classCallCheck(this, hm);

    _this111 = _super99.call(this, t, n, i);
    var r = n.sampler,
        s = n.source,
        a = null != e.samplers && null != r ? e.samplers[r] : {};

    if (_this111[cm] = new om(t, a, i), null != e.images && null != s) {
      var _n249 = e.images[s];
      null != _n249 && (_this111[lm] = new em(t, _n249, i));
    }

    return _this111;
  }

  _createClass(hm, [{
    key: "name",
    get: function get() {
      return this[qg].name || "";
    }
  }, {
    key: "sampler",
    get: function get() {
      return this[cm];
    }
  }, {
    key: "source",
    get: function get() {
      return this[lm];
    }
  }]);

  return hm;
}(Yg);
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var um = Symbol("texture");

var dm = /*#__PURE__*/function (_Yg4) {
  _inherits(dm, _Yg4);

  var _super100 = _createSuper(dm);

  function dm(t, e, n, i) {
    var _this112;

    _classCallCheck(this, dm);

    _this112 = _super100.call(this, t, n, i);
    var r = n.index,
        s = e.textures[r];
    null != s && (_this112[um] = new hm(t, e, s, i));
    return _this112;
  }

  _createClass(dm, [{
    key: "texture",
    get: function get() {
      return this[um];
    }
  }]);

  return dm;
}(Yg);
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Am, pm;
var gm = Symbol("threeMaterials"),
    mm = Symbol("baseColorTexture"),
    fm = Symbol("metallicRoughnessTexture");

var vm = /*#__PURE__*/function (_Yg5) {
  _inherits(vm, _Yg5);

  var _super101 = _createSuper(vm);

  function vm(t, e, n, i) {
    var _this113;

    _classCallCheck(this, vm);

    _this113 = _super101.call(this, t, n, i), _this113[Am] = null, _this113[pm] = null, null == n.baseColorFactor && (n.baseColorFactor = [1, 1, 1, 1]), null == n.roughnessFactor && (n.roughnessFactor = 0), null == n.metallicFactor && (n.metallicFactor = 0);
    var r = n.baseColorTexture,
        s = n.metallicRoughnessTexture,
        a = new Set(),
        o = new Set();

    var _iterator26 = _createForOfIteratorHelper(i),
        _step26;

    try {
      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
        var _t381 = _step26.value;
        null != r && null != _t381.map && a.add(_t381.map), null != s && null != _t381.metalnessMap && o.add(_t381.metalnessMap);
      }
    } catch (err) {
      _iterator26.e(err);
    } finally {
      _iterator26.f();
    }

    a.size > 0 && (_this113[mm] = new dm(t, e, r, a)), o.size > 0 && (_this113[fm] = new dm(t, e, s, o));
    return _this113;
  }

  _createClass(vm, [{
    key: (Am = mm, pm = fm, gm),
    get: function get() {
      return this[Wg];
    }
  }, {
    key: "baseColorFactor",
    get: function get() {
      return this[qg].baseColorFactor;
    }
  }, {
    key: "metallicFactor",
    get: function get() {
      return this[qg].metallicFactor;
    }
  }, {
    key: "roughnessFactor",
    get: function get() {
      return this[qg].roughnessFactor;
    }
  }, {
    key: "baseColorTexture",
    get: function get() {
      return this[mm];
    }
  }, {
    key: "metallicRoughnessTexture",
    get: function get() {
      return this[fm];
    }
  }, {
    key: "setBaseColorFactor",
    value: function setBaseColorFactor(t) {
      var _iterator27 = _createForOfIteratorHelper(this[gm]),
          _step27;

      try {
        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
          var _e287 = _step27.value;
          _e287.color.fromArray(t), _e287.opacity = t[3];
        }
      } catch (err) {
        _iterator27.e(err);
      } finally {
        _iterator27.f();
      }

      this[qg].baseColorFactor = t, this[jg]();
    }
  }, {
    key: "setMetallicFactor",
    value: function setMetallicFactor(t) {
      var _iterator28 = _createForOfIteratorHelper(this[gm]),
          _step28;

      try {
        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
          var _e288 = _step28.value;
          _e288.metalness = t;
        }
      } catch (err) {
        _iterator28.e(err);
      } finally {
        _iterator28.f();
      }

      this[qg].metallicFactor = t, this[jg]();
    }
  }, {
    key: "setRoughnessFactor",
    value: function setRoughnessFactor(t) {
      var _iterator29 = _createForOfIteratorHelper(this[gm]),
          _step29;

      try {
        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
          var _e289 = _step29.value;
          _e289.roughness = t;
        }
      } catch (err) {
        _iterator29.e(err);
      } finally {
        _iterator29.f();
      }

      this[qg].roughnessFactor = t, this[jg]();
    }
  }]);

  return vm;
}(Yg);
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ym, Em, xm;

var wm = Symbol("pbrMetallicRoughness"),
    bm = Symbol("normalTexture"),
    _m = Symbol("occlusionTexture"),
    Im = Symbol("emissiveTexture");

var Cm = /*#__PURE__*/function (_Yg6) {
  _inherits(Cm, _Yg6);

  var _super102 = _createSuper(Cm);

  function Cm(t, e, n, i) {
    var _this114;

    _classCallCheck(this, Cm);

    if (_this114 = _super102.call(this, t, n, i), _this114[ym] = null, _this114[Em] = null, _this114[xm] = null, null == i) return _possibleConstructorReturn(_this114);
    null == n.pbrMetallicRoughness && (n.pbrMetallicRoughness = {}), _this114[wm] = new vm(t, e, n.pbrMetallicRoughness, i);
    var r = n.normalTexture,
        s = n.occlusionTexture,
        a = n.emissiveTexture,
        o = new Set(),
        l = new Set(),
        c = new Set();

    var _iterator30 = _createForOfIteratorHelper(i),
        _step30;

    try {
      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
        var _t382 = _step30.value;
        var _e290 = _t382.normalMap,
            _n250 = _t382.aoMap,
            _i237 = _t382.emissiveMap;
        null != r && null != _e290 && o.add(_e290), null != s && null != _n250 && l.add(_n250), null != a && null != _i237 && c.add(_i237);
      }
    } catch (err) {
      _iterator30.e(err);
    } finally {
      _iterator30.f();
    }

    o.size > 0 && (_this114[bm] = new dm(t, e, r, o)), l.size > 0 && (_this114[_m] = new dm(t, e, s, l)), c.size > 0 && (_this114[Im] = new dm(t, e, a, c));
    return _possibleConstructorReturn(_this114);
  }

  _createClass(Cm, [{
    key: "name",
    get: function get() {
      return this[qg].name || "";
    }
  }, {
    key: "pbrMetallicRoughness",
    get: function get() {
      return this[wm];
    }
  }, {
    key: "normalTexture",
    get: function get() {
      return this[bm];
    }
  }, {
    key: "occlusionTexture",
    get: function get() {
      return this[_m];
    }
  }, {
    key: "emissiveTexture",
    get: function get() {
      return this[Im];
    }
  }, {
    key: "emissiveFactor",
    get: function get() {
      return this[qg].emissiveFactor;
    }
  }, {
    key: "setEmissiveFactor",
    value: function setEmissiveFactor(t) {
      var _iterator31 = _createForOfIteratorHelper(this[Wg]),
          _step31;

      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
          var _e291 = _step31.value;

          _e291.emissive.fromArray(t);
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }

      this[qg].emissiveFactor = t, this[jg]();
    }
  }]);

  return Cm;
}(Yg);
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Mm;
ym = bm, Em = _m, xm = Im;
var Sm = Symbol("materials");

var Bm = /*#__PURE__*/function () {
  function Bm(t) {
    var _this115 = this;

    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    _classCallCheck(this, Bm);

    this[Mm] = [];
    var n = t.gltf,
        i = t.gltfElementMap;
    n.materials.forEach(function (t) {
      _this115[Sm].push(new Cm(e, n, t, i.get(t)));
    });
  }

  _createClass(Bm, [{
    key: "materials",
    get: function get() {
      return this[Sm];
    }
  }]);

  return Bm;
}();

Mm = Sm;
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Tm = function Tm(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var Lm = Symbol("currentGLTF"),
    Rm = Symbol("model"),
    Dm = Symbol("variants");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Qm = function Qm(t, e, n, i) {
  for (var r, s = arguments.length, a = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, o = t.length - 1; o >= 0; o--) {
    (r = t[o]) && (a = (s < 3 ? r(a) : s > 3 ? r(e, n, a) : r(e, n)) || a);
  }

  return s > 3 && a && Object.defineProperty(e, n, a), a;
};

var Pm = Math.PI / 32,
    Fm = {
  basis: [rc(Yl(Pm, "rad"))],
  keywords: {
    auto: [null]
  }
},
    Nm = Symbol("autoRotateStartTime"),
    Um = Symbol("radiansPerSecond"),
    Gm = Symbol("syncRotationRate"),
    km = Symbol("onCameraChange"),
    Om = function (t) {
  var e, n, i;

  var r = /*#__PURE__*/function (_t383) {
    _inherits(r, _t383);

    var _super103 = _createSuper(r);

    function r() {
      var _this116;

      _classCallCheck(this, r);

      _this116 = _super103.apply(this, arguments), _this116[e] = new Map(), _this116[n] = function (t) {
        t.forEach(function (t) {
          t instanceof MutationRecord && "childList" !== t.type || (t.addedNodes.forEach(function (t) {
            _this116[mu](t);
          }), t.removedNodes.forEach(function (t) {
            _this116[fu](t);
          }), _this116[Kh]());
        });
      }, _this116[i] = new MutationObserver(_this116[pu]);
      return _this116;
    }

    _createClass(r, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(r.prototype), "connectedCallback", this).call(this);

        for (var _t384 = 0; _t384 < this.children.length; ++_t384) {
          this[mu](this.children[_t384]);
        }

        var _self = self,
            t = _self.ShadyDOM;
        null == t ? this[gu].observe(this, {
          childList: !0
        }) : this[gu] = t.observeChildren(this, this[pu]);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(r.prototype), "disconnectedCallback", this).call(this);

        var _self2 = self,
            t = _self2.ShadyDOM;
        null == t ? this[gu].disconnect() : t.unobserveChildren(this[gu]);
      }
    }, {
      key: "updateHotspot",
      value: function updateHotspot(t) {
        var e = this[Au].get(t.name);
        null != e && (e.updatePosition(t.position), e.updateNormal(t.normal), this[Kh]());
      }
    }, {
      key: "positionAndNormalFromPoint",
      value: function positionAndNormalFromPoint(t, e) {
        var n = this[Xh],
            i = n.width,
            _r157 = n.height,
            s = n.target;
        vu.set(t / i, e / _r157).multiplyScalar(2).subScalar(1), vu.y *= -1;
        var a = n.positionAndNormalFromPoint(vu);
        if (null == a) return null;
        yu.copy(s.matrixWorld).invert();
        var o = lu(a.position.applyMatrix4(yu));
        Eu.getNormalMatrix(yu);
        return {
          position: o,
          normal: lu(a.normal.applyNormalMatrix(Eu))
        };
      }
    }, {
      key: (e = Au, n = pu, i = gu, mu),
      value: function value(t) {
        if (!(t instanceof HTMLElement && 0 === t.slot.indexOf("hotspot"))) return;
        var e = this[Au].get(t.slot);
        null != e ? e.increment() : (e = new oc({
          name: t.slot,
          position: t.dataset.position,
          normal: t.dataset.normal
        }), this[Au].set(t.slot, e), this[Xh].addHotspot(e)), this[Xh].isDirty = !0;
      }
    }, {
      key: fu,
      value: function value(t) {
        if (!(t instanceof HTMLElement)) return;
        var e = this[Au].get(t.slot);
        e && (e.decrement() && (this[Xh].removeHotspot(e), this[Au].delete(t.slot)), this[Xh].isDirty = !0);
      }
    }]);

    return r;
  }(t);

  return r;
}(function (t) {
  var e, n, i;

  var r = /*#__PURE__*/function (_t385) {
    _inherits(r, _t385);

    var _super104 = _createSuper(r);

    function r() {
      var _this117;

      _classCallCheck(this, r);

      _this117 = _super104.apply(this, arguments), _this117[e] = void 0, _this117[n] = null, _this117[i] = [], _this117.variantName = void 0, _this117.orientation = "0 0 0", _this117.scale = "1 1 1";
      return _this117;
    }

    _createClass(r, [{
      key: "model",
      get: function get() {
        return this[Rm];
      }
    }, {
      key: "availableVariants",
      get: function get() {
        return this[Dm];
      }
    }, {
      key: "updated",
      value: function updated(t) {
        var _this118 = this;

        if (_get(_getPrototypeOf(r.prototype), "updated", this).call(this, t), t.has("variantName")) {
          var _t386 = this[Dm],
              _e292 = this[Lm],
              _n251 = this.variantName,
              _i238 = _t386.findIndex(function (t) {
            return t === _n251;
          });

          if (null == _e292 || _i238 < 0) return;

          var _r161 = function _r161() {
            _this118[Kh]();
          },
              _s80 = _e292.correlatedSceneGraph.loadVariant(_i238, _r161),
              _e292$correlatedScene = _e292.correlatedSceneGraph,
              _a63 = _e292$correlatedScene.gltf,
              _o43 = _e292$correlatedScene.gltfElementMap;

          var _iterator32 = _createForOfIteratorHelper(_s80),
              _step32;

          try {
            for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
              var _t387 = _step32.value;
              var _e293 = _a63.materials[_t387];
              this[Rm].materials[_t387] = new Cm(_r161, _a63, _e293, _o43.get(_e293));
            }
          } catch (err) {
            _iterator32.e(err);
          } finally {
            _iterator32.f();
          }
        }

        if (t.has("orientation") || t.has("scale")) {
          var _t388 = this[Xh].modelContainer,
              _e294 = Jl(this.orientation)[0].terms,
              _n252 = ac(_e294[0]).number,
              _i239 = ac(_e294[1]).number,
              _r162 = ac(_e294[2]).number;

          _t388.quaternion.setFromEuler(new Bt(_i239, _r162, _n252, "YXZ"));

          var _s81 = Jl(this.scale)[0].terms;
          _t388.scale.set(_s81[0].number, _s81[1].number, _s81[2].number), this[Xh].updateBoundingBox(), this[Xh].updateShadow(), this[eu].arRenderer.onUpdateScene(), this[Kh]();
        }
      }
    }, {
      key: (e = Rm, n = Lm, i = Dm, $h),
      value: function value() {
        var _this119 = this;

        _get(_getPrototypeOf(r.prototype), $h, this).call(this), this[Dm] = [];
        var t = this[Xh].currentGLTF;

        if (null != t) {
          var _e295 = t.correlatedSceneGraph;
          null != _e295 && t !== this[Lm] && (this[Rm] = new Bm(_e295, function () {
            _this119[Kh]();
          }));
          var _n253 = t.userData.gltfExtensions;

          if (null != _n253) {
            var _t389 = _n253.KHR_materials_variants;
            null != _t389 && (this[Dm] = _t389.variants.map(function (t) {
              return t.name;
            }), this.requestUpdate("variantName"));
          }
        }

        this[Lm] = t, this.dispatchEvent(new CustomEvent("scene-graph-ready"));
      }
    }, {
      key: "exportScene",
      value: function () {
        var _exportScene = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(t) {
          var e;
          return regeneratorRuntime.wrap(function _callee28$(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  e = this[Xh];
                  return _context28.abrupt("return", new Promise( /*#__PURE__*/function () {
                    var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(n) {
                      var i, _r160, s;

                      return regeneratorRuntime.wrap(function _callee27$(_context27) {
                        while (1) {
                          switch (_context27.prev = _context27.next) {
                            case 0:
                              i = {
                                binary: !0,
                                onlyVisible: !0,
                                maxTextureSize: 1 / 0,
                                forcePowerOfTwoTextures: !1,
                                includeCustomExtensions: !1,
                                embedImages: !0
                              };
                              Object.assign(i, t), i.animations = e.animations, i.truncateDrawRange = !0;
                              _r160 = e.shadow;
                              s = !1;
                              null != _r160 && (s = _r160.visible, _r160.visible = !1);
                              new pg().parse(e.modelContainer, function (t) {
                                return n(new Blob([i.binary ? t : JSON.stringify(t)], {
                                  type: i.binary ? "application/octet-stream" : "application/json"
                                }));
                              }, i), null != _r160 && (_r160.visible = s);

                            case 6:
                            case "end":
                              return _context27.stop();
                          }
                        }
                      }, _callee27);
                    }));

                    return function (_x25) {
                      return _ref16.apply(this, arguments);
                    };
                  }()));

                case 2:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee28, this);
        }));

        function exportScene(_x24) {
          return _exportScene.apply(this, arguments);
        }

        return exportScene;
      }()
    }]);

    return r;
  }(t);

  return Tm([a({
    type: String,
    attribute: "variant-name"
  })], r.prototype, "variantName", void 0), Tm([a({
    type: String,
    attribute: "orientation"
  })], r.prototype, "orientation", void 0), Tm([a({
    type: String,
    attribute: "scale"
  })], r.prototype, "scale", void 0), r;
}(function (t) {
  var e, n, i;

  var r = /*#__PURE__*/function (_t390) {
    _inherits(r, _t390);

    var _super105 = _createSuper(r);

    function r() {
      var _this120;

      _classCallCheck(this, r);

      _this120 = _super105.apply(this, arguments), _this120.autoRotate = !1, _this120.autoRotateDelay = 3e3, _this120.rotationPerSecond = "auto", _this120[e] = performance.now(), _this120[n] = 0, _this120[i] = function (t) {
        _this120.autoRotate && "user-interaction" === t.detail.source && (_this120[Nm] = performance.now());
      };
      return _this120;
    }

    _createClass(r, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(r.prototype), "connectedCallback", this).call(this), this.addEventListener("camera-change", this[km]), this[Nm] = performance.now();
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(r.prototype), "disconnectedCallback", this).call(this), this.removeEventListener("camera-change", this[km]), this[Nm] = performance.now();
      }
    }, {
      key: "updated",
      value: function updated(t) {
        _get(_getPrototypeOf(r.prototype), "updated", this).call(this, t), t.has("autoRotate") && (this[Nm] = performance.now());
      }
    }, {
      key: (e = Nm, n = Um, Gm),
      value: function value(t) {
        this[Um] = t[0];
      }
    }, {
      key: Zh,
      value: function value(t, e) {
        if (_get(_getPrototypeOf(r.prototype), Zh, this).call(this, t, e), !this.autoRotate || !this[ou]() || this[eu].isPresenting) return;
        var n = Math.min(e, t - this[Nm] - this.autoRotateDelay);
        n > 0 && (this[Xh].yaw = this.turntableRotation + this[Um] * n * .001);
      }
    }, {
      key: "turntableRotation",
      get: function get() {
        return this[Xh].yaw;
      }
    }, {
      key: "resetTurntableRotation",
      value: function resetTurntableRotation() {
        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this[Xh].yaw = t;
      }
    }]);

    return r;
  }(t);

  return i = km, Qm([a({
    type: Boolean,
    attribute: "auto-rotate"
  })], r.prototype, "autoRotate", void 0), Qm([a({
    type: Number,
    attribute: "auto-rotate-delay"
  })], r.prototype, "autoRotateDelay", void 0), Qm([CA({
    intrinsics: Fm,
    updateHandler: Gm
  }), a({
    type: String,
    attribute: "rotation-per-second"
  })], r.prototype, "rotationPerSecond", void 0), r;
}(function (t) {
  var e, n, i;

  var r = /*#__PURE__*/function (_t391) {
    _inherits(r, _t391);

    var _super106 = _createSuper(r);

    function r() {
      var _this121;

      _classCallCheck(this, r);

      _this121 = _super106.apply(this, arguments), _this121.environmentImage = null, _this121.skyboxImage = null, _this121.shadowIntensity = 0, _this121.shadowSoftness = 1, _this121.exposure = 1, _this121[e] = null, _this121[n] = null, _this121[i] = function (t) {
        t.element === _assertThisInitialized(_this121) && _this121[kp]();
      };
      return _this121;
    }

    _createClass(r, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(r.prototype), "connectedCallback", this).call(this), this[eu].loader.addEventListener("preload", this[Hp]);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(r.prototype), "disconnectedCallback", this).call(this), this[eu].loader.removeEventListener("preload", this[Hp]);
      }
    }, {
      key: "updated",
      value: function updated(t) {
        _get(_getPrototypeOf(r.prototype), "updated", this).call(this, t), t.has("shadowIntensity") && (this[Xh].setShadowIntensity(.1 * this.shadowIntensity), this[Kh]()), t.has("shadowSoftness") && (this[Xh].setShadowSoftness(this.shadowSoftness), this[Kh]()), t.has("exposure") && (this[Xh].exposure = this.exposure, this[Kh]()), (t.has("environmentImage") || t.has("skyboxImage")) && this[su]() && this[kp]();
      }
    }, {
      key: (e = Up, n = Op, i = Hp, $h),
      value: function value() {
        _get(_getPrototypeOf(r.prototype), $h, this).call(this), null != this[Up] && this[Gp](this[Up]);
      }
    }, {
      key: kp,
      value: function () {
        var _value2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30() {
          var _this122 = this;

          var t, e, n, _yield$Promise, _i240, _r165, _s82;

          return regeneratorRuntime.wrap(function _callee30$(_context30) {
            while (1) {
              switch (_context30.prev = _context30.next) {
                case 0:
                  t = this.skyboxImage, e = this.environmentImage;
                  null != this[Op] && (this[Op](), this[Op] = null);
                  n = this[eu].textureUtils;

                  if (!(null != n)) {
                    _context30.next = 18;
                    break;
                  }

                  _context30.prev = 4;
                  _context30.next = 7;
                  return new Promise( /*#__PURE__*/function () {
                    var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(i, _r164) {
                      var s;
                      return regeneratorRuntime.wrap(function _callee29$(_context29) {
                        while (1) {
                          switch (_context29.prev = _context29.next) {
                            case 0:
                              s = n.generateEnvironmentMapAndSkybox(kl(t), e, {
                                progressTracker: _this122[nu]
                              });

                              _this122[Op] = function () {
                                return _r164(s);
                              };

                              _context29.t0 = i;
                              _context29.next = 5;
                              return s;

                            case 5:
                              _context29.t1 = _context29.sent;
                              (0, _context29.t0)(_context29.t1);

                            case 7:
                            case "end":
                              return _context29.stop();
                          }
                        }
                      }, _callee29);
                    }));

                    return function (_x26, _x27) {
                      return _ref17.apply(this, arguments);
                    };
                  }());

                case 7:
                  _yield$Promise = _context30.sent;
                  _i240 = _yield$Promise.environmentMap;
                  _r165 = _yield$Promise.skybox;
                  _s82 = _i240.texture;
                  this[Xh].background = null != _r165 ? _r165.userData.url === _s82.userData.url ? _s82 : _r165 : null, this[Gp](_i240.texture), this[Xh].dispatchEvent({
                    type: "envmap-update"
                  });
                  _context30.next = 18;
                  break;

                case 14:
                  _context30.prev = 14;
                  _context30.t0 = _context30["catch"](4);

                  if (!(_context30.t0 instanceof Error)) {
                    _context30.next = 18;
                    break;
                  }

                  throw this[Gp](null), _context30.t0;

                case 18:
                case "end":
                  return _context30.stop();
              }
            }
          }, _callee30, this, [[4, 14]]);
        }));

        function value() {
          return _value2.apply(this, arguments);
        }

        return value;
      }()
    }, {
      key: Gp,
      value: function value(t) {
        this[Up] = t, this[Xh].environment = this[Up], this.dispatchEvent(new CustomEvent("environment-change")), this[Kh]();
      }
    }]);

    return r;
  }(t);

  return Np([a({
    type: String,
    attribute: "environment-image"
  })], r.prototype, "environmentImage", void 0), Np([a({
    type: String,
    attribute: "skybox-image"
  })], r.prototype, "skyboxImage", void 0), Np([a({
    type: Number,
    attribute: "shadow-intensity"
  })], r.prototype, "shadowIntensity", void 0), Np([a({
    type: Number,
    attribute: "shadow-softness"
  })], r.prototype, "shadowSoftness", void 0), Np([a({
    type: Number
  })], r.prototype, "exposure", void 0), r;
}(function (t) {
  var e, n, i, r, s, o, l, c, h, u, d, A, p, g, m, f, v;

  var y = /*#__PURE__*/function (_t392) {
    _inherits(y, _t392);

    var _super107 = _createSuper(y);

    function y() {
      var _this123;

      _classCallCheck(this, y);

      _this123 = _super107.apply(this, arguments), _this123.cameraControls = !1, _this123.cameraOrbit = "0deg 75deg 105%", _this123.cameraTarget = "auto auto auto", _this123.fieldOfView = "auto", _this123.minCameraOrbit = "auto", _this123.maxCameraOrbit = "auto", _this123.minFieldOfView = "auto", _this123.maxFieldOfView = "auto", _this123.interactionPromptThreshold = 3e3, _this123.interactionPromptStyle = XA, _this123.interactionPrompt = YA, _this123.interactionPolicy = KA, _this123.orbitSensitivity = 1, _this123.touchAction = ZA, _this123.disableZoom = !1, _this123.interpolationDecay = 50, _this123.bounds = "legacy", _this123[e] = _this123.shadowRoot.querySelector(".interaction-prompt"), _this123[n] = _this123.shadowRoot.querySelector(".interaction-prompt > .animated-container"), _this123[i] = 1 / 0, _this123[r] = 0, _this123[s] = 1 / 0, _this123[o] = !1, _this123[l] = !1, _this123[c] = new UA(_this123[Xh].camera, _this123[Yh]), _this123[h] = 0, _this123[u] = new Aa(), _this123[d] = !1, _this123[A] = !1, _this123[p] = !1, _this123[g] = function () {
        var t = _this123[Yh];
        isFinite(_this123[_p]) || (_this123[_p] = performance.now());
        var e = _this123[zh];
        t.getAttribute("aria-label") !== e && t.setAttribute("aria-label", e), _this123.interactionPrompt !== JA || _this123[xp] || (_this123[Ep] = !0);
      }, _this123[m] = function () {
        _this123.interactionPrompt === JA && (_this123[Ep] = !1, _this123[up].classList.remove("visible"), _this123[wp] = 1 / 0, _this123[_p] = 1 / 0);
      }, _this123[f] = function (_ref18) {
        var t = _ref18.source;
        _this123[pp](), _this123[Kh](), t === FA && (_this123[xp] = !0, _this123[Ap]()), _this123.dispatchEvent(new CustomEvent("camera-change", {
          detail: {
            source: t
          }
        }));
      }, _this123[v] = function (t) {
        "pointer-change-start" === t.type ? _this123[jh].classList.add("pointer-tumbling") : _this123[jh].classList.remove("pointer-tumbling");
      };
      return _this123;
    }

    _createClass(y, [{
      key: "getCameraOrbit",
      value: function getCameraOrbit() {
        var _this$Cp = this[Cp],
            t = _this$Cp.theta,
            e = _this$Cp.phi,
            n = _this$Cp.radius;
        return {
          theta: t,
          phi: e,
          radius: n,
          toString: function toString() {
            return "".concat(this.theta, "rad ").concat(this.phi, "rad ").concat(this.radius, "m");
          }
        };
      }
    }, {
      key: "getCameraTarget",
      value: function getCameraTarget() {
        return lu(this[eu].isPresenting ? this[eu].arRenderer.target : this[Xh].getTarget());
      }
    }, {
      key: "getFieldOfView",
      value: function getFieldOfView() {
        return this[hp].getFieldOfView();
      }
    }, {
      key: "getMinimumFieldOfView",
      value: function getMinimumFieldOfView() {
        return this[hp].options.minimumFieldOfView;
      }
    }, {
      key: "getMaximumFieldOfView",
      value: function getMaximumFieldOfView() {
        return this[hp].options.maximumFieldOfView;
      }
    }, {
      key: "jumpCameraToGoal",
      value: function jumpCameraToGoal() {
        this[Mp] = !0, this.requestUpdate(Mp, !1);
      }
    }, {
      key: "resetInteractionPrompt",
      value: function resetInteractionPrompt() {
        this[bp] = 0, this[wp] = 1 / 0, this[xp] = !1, this[Ep] = this.interactionPrompt === YA && this.cameraControls;
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(y.prototype), "connectedCallback", this).call(this), this[hp].addEventListener("change", this[vp]), this[hp].addEventListener("pointer-change-start", this[yp]), this[hp].addEventListener("pointer-change-end", this[yp]);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(y.prototype), "disconnectedCallback", this).call(this), this[hp].removeEventListener("change", this[vp]), this[hp].removeEventListener("pointer-change-start", this[yp]), this[hp].removeEventListener("pointer-change-end", this[yp]);
      }
    }, {
      key: "updated",
      value: function updated(t) {
        var _this124 = this;

        _get(_getPrototypeOf(y.prototype), "updated", this).call(this, t);

        var e = this[hp],
            n = this[Yh];

        if (t.has("cameraControls") && (this.cameraControls ? (e.enableInteraction(), this.interactionPrompt === YA && (this[Ep] = !0), n.addEventListener("focus", this[fp]), n.addEventListener("blur", this[mp])) : (n.removeEventListener("focus", this[fp]), n.removeEventListener("blur", this[mp]), e.disableInteraction(), this[Ap]())), t.has("disableZoom") && (e.disableZoom = this.disableZoom), t.has("bounds") && (this[Xh].tightBounds = "tight" === this.bounds), (t.has("interactionPrompt") || t.has("cameraControls") || t.has("src")) && (this.interactionPrompt === YA && this.cameraControls && !this[xp] ? this[Ep] = !0 : this[Ap]()), t.has("interactionPromptStyle") && this[up].classList.toggle("wiggle", this.interactionPromptStyle === XA), t.has("interactionPolicy")) {
          var _t393 = this.interactionPolicy;
          e.applyOptions({
            interactionPolicy: _t393
          });
        }

        if (t.has("touchAction")) {
          var _t394 = this.touchAction;
          e.applyOptions({
            touchAction: _t394
          });
        }

        t.has("orbitSensitivity") && (e.sensitivity = this.orbitSensitivity), t.has("interpolationDecay") && (e.setDamperDecayTime(this.interpolationDecay), this[Xh].setTargetDamperDecayTime(this.interpolationDecay)), !0 === this[Mp] && Promise.resolve().then(function () {
          e.jumpToGoal(), _this124[Xh].jumpToGoal(), _this124[Mp] = !1;
        });
      }
    }, {
      key: "updateFraming",
      value: function () {
        var _updateFraming = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31() {
          var t, e, n, i;
          return regeneratorRuntime.wrap(function _callee31$(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  t = this[Xh], e = t.framedFieldOfView;
                  _context31.next = 3;
                  return this.requestUpdate("cameraTarget");

                case 3:
                  t.updateFraming("tight" === this.bounds ? t.getTarget() : void 0);
                  t.frameModel();
                  n = t.framedFieldOfView, i = this[hp].getFieldOfView() / e;
                  this[Ip] = n * i;
                  this[Bp] = !0;
                  this.requestUpdate("maxFieldOfView");
                  this.requestUpdate("fieldOfView");
                  this.requestUpdate("minCameraOrbit");
                  this.requestUpdate("maxCameraOrbit");
                  _context31.next = 14;
                  return this.requestUpdate("cameraOrbit");

                case 14:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee31, this);
        }));

        function updateFraming() {
          return _updateFraming.apply(this, arguments);
        }

        return updateFraming;
      }()
    }, {
      key: (e = up, n = dp, i = _p, r = bp, s = wp, o = xp, l = Ep, c = hp, h = Ip, u = Cp, d = Mp, A = Sp, p = Bp, Lp),
      value: function value(t) {
        this[hp].setFieldOfView(180 * t[0] / Math.PI);
      }
    }, {
      key: Tp,
      value: function value(t) {
        if (this[Bp]) {
          var _this$getCameraOrbit = this.getCameraOrbit(),
              _e296 = _this$getCameraOrbit.theta,
              _n254 = _this$getCameraOrbit.phi;

          t[0] = _e296, t[1] = _n254, this[Bp] = !1;
        }

        this[hp].setOrbit(t[0], t[1], t[2]);
      }
    }, {
      key: Dp,
      value: function value(t) {
        this[hp].applyOptions({
          minimumAzimuthalAngle: t[0],
          minimumPolarAngle: t[1],
          minimumRadius: t[2]
        }), this.jumpCameraToGoal();
      }
    }, {
      key: Qp,
      value: function value(t) {
        this[hp].applyOptions({
          maximumAzimuthalAngle: t[0],
          maximumPolarAngle: t[1],
          maximumRadius: t[2]
        }), this[gp](t[2]), this.jumpCameraToGoal();
      }
    }, {
      key: Pp,
      value: function value(t) {
        this[hp].applyOptions({
          minimumFieldOfView: 180 * t[0] / Math.PI
        }), this.jumpCameraToGoal();
      }
    }, {
      key: Fp,
      value: function value(t) {
        this[hp].applyOptions({
          maximumFieldOfView: 180 * t[0] / Math.PI
        }), this.jumpCameraToGoal();
      }
    }, {
      key: Rp,
      value: function value(t) {
        var _t395 = _slicedToArray(t, 3),
            e = _t395[0],
            n = _t395[1],
            i = _t395[2];

        this[Xh].setTarget(e, n, i), this[eu].arRenderer.updateTarget();
      }
    }, {
      key: Zh,
      value: function value(t, e) {
        if (_get(_getPrototypeOf(y.prototype), Zh, this).call(this, t, e), this[eu].isPresenting || !this[ou]()) return;
        var n = performance.now();

        if (this[Ep]) {
          var _t396 = this.interactionPrompt === YA ? this[Vh] : this[_p];

          this.loaded && n > _t396 + this.interactionPromptThreshold && (this[Yh].setAttribute("aria-label", "Use mouse, touch or arrow keys to control the camera!"), this[Ep] = !1, this[wp] = n, this[up].classList.add("visible"));
        }

        if (isFinite(this[wp]) && this.interactionPromptStyle === XA) {
          var _t397 = this[Xh],
              _e297 = (n - this[wp]) / 5e3 % 1,
              _i241 = zA(_e297),
              _r166 = VA(_e297);

          if (this[dp].style.opacity = "".concat(_r166), _i241 !== this[bp]) {
            var _e298 = _i241 * _t397.width * .05,
                _n255 = (_i241 - this[bp]) * Math.PI / 16;

            this[dp].style.transform = "translateX(".concat(_e298, "px)"), this[hp].adjustOrbit(_n255, 0, 0), this[bp] = _i241;
          }
        }

        this[hp].update(t, e), this[Xh].updateTarget(e);
      }
    }, {
      key: Ap,
      value: function value() {
        this[Ep] = !1, this[up].classList.remove("visible"), this[wp] = 1 / 0;
      }
    }, {
      key: gp,
      value: function value(t) {
        var e = this[Xh].idealCameraDistance,
            n = 2 * Math.max(e, t);
        this[hp].updateNearFar(0, n);
      }
    }, {
      key: pp,
      value: function value() {
        var _this$Cp2 = this[Cp],
            t = _this$Cp2.theta,
            e = _this$Cp2.phi,
            _this$hp$getCameraSph = this[hp].getCameraSpherical(this[Cp]),
            n = _this$hp$getCameraSph.theta,
            i = _this$hp$getCameraSph.phi,
            r = this.getRootNode();

        if (null != r && r.activeElement === this) {
          var _r167 = (4 + Math.floor((t % cp + lp) / ap)) % 4,
              _s83 = (4 + Math.floor((n % cp + lp) / ap)) % 4,
              _a64 = Math.floor(e / op),
              _o44 = Math.floor(i / op);

          if (_s83 !== _r167 || _o44 !== _a64) {
            var _t398 = "View from stage ".concat(jA[_o44]).concat(qA[_s83]);

            this[Yh].setAttribute("aria-label", _t398);
          }
        }
      }
    }, {
      key: tu,
      value: function value(t) {
        var e = this[hp],
            n = this[Xh].framedFieldOfView;

        _get(_getPrototypeOf(y.prototype), tu, this).call(this, t);

        var i = this[Xh].framedFieldOfView,
            r = e.getFieldOfView() / n;
        this[Ip] = i * r, e.updateAspect(this[Xh].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.jumpCameraToGoal();
      }
    }, {
      key: $h,
      value: function value() {
        _get(_getPrototypeOf(y.prototype), $h, this).call(this);

        var t = this[Xh].framedFieldOfView;
        this[Ip] = t, this[Sp] ? this[Bp] = !0 : this[Sp] = !0, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal();
      }
    }]);

    return y;
  }(t);

  return g = fp, m = mp, f = vp, v = yp, HA([a({
    type: Boolean,
    attribute: "camera-controls"
  })], y.prototype, "cameraControls", void 0), HA([CA({
    intrinsics: np,
    observeEffects: !0,
    updateHandler: Tp
  }), a({
    type: String,
    attribute: "camera-orbit",
    hasChanged: function hasChanged() {
      return !0;
    }
  })], y.prototype, "cameraOrbit", void 0), HA([CA({
    intrinsics: sp,
    observeEffects: !0,
    updateHandler: Rp
  }), a({
    type: String,
    attribute: "camera-target",
    hasChanged: function hasChanged() {
      return !0;
    }
  })], y.prototype, "cameraTarget", void 0), HA([CA({
    intrinsics: $A,
    observeEffects: !0,
    updateHandler: Lp
  }), a({
    type: String,
    attribute: "field-of-view",
    hasChanged: function hasChanged() {
      return !0;
    }
  })], y.prototype, "fieldOfView", void 0), HA([CA({
    intrinsics: ip,
    updateHandler: Dp
  }), a({
    type: String,
    attribute: "min-camera-orbit",
    hasChanged: function hasChanged() {
      return !0;
    }
  })], y.prototype, "minCameraOrbit", void 0), HA([CA({
    intrinsics: rp,
    updateHandler: Qp
  }), a({
    type: String,
    attribute: "max-camera-orbit",
    hasChanged: function hasChanged() {
      return !0;
    }
  })], y.prototype, "maxCameraOrbit", void 0), HA([CA({
    intrinsics: tp,
    updateHandler: Pp
  }), a({
    type: String,
    attribute: "min-field-of-view",
    hasChanged: function hasChanged() {
      return !0;
    }
  })], y.prototype, "minFieldOfView", void 0), HA([CA({
    intrinsics: ep,
    updateHandler: Fp
  }), a({
    type: String,
    attribute: "max-field-of-view",
    hasChanged: function hasChanged() {
      return !0;
    }
  })], y.prototype, "maxFieldOfView", void 0), HA([a({
    type: Number,
    attribute: "interaction-prompt-threshold"
  })], y.prototype, "interactionPromptThreshold", void 0), HA([a({
    type: String,
    attribute: "interaction-prompt-style"
  })], y.prototype, "interactionPromptStyle", void 0), HA([a({
    type: String,
    attribute: "interaction-prompt"
  })], y.prototype, "interactionPrompt", void 0), HA([a({
    type: String,
    attribute: "interaction-policy"
  })], y.prototype, "interactionPolicy", void 0), HA([a({
    type: Number,
    attribute: "orbit-sensitivity"
  })], y.prototype, "orbitSensitivity", void 0), HA([a({
    type: String,
    attribute: "touch-action"
  })], y.prototype, "touchAction", void 0), HA([a({
    type: Boolean,
    attribute: "disable-zoom"
  })], y.prototype, "disableZoom", void 0), HA([a({
    type: Number,
    attribute: "interpolation-decay"
  })], y.prototype, "interpolationDecay", void 0), HA([a({
    type: String,
    attribute: "bounds"
  })], y.prototype, "bounds", void 0), y;
}(function (t) {
  var e, n, i, r, s, o, l, c, h, d;

  var A = /*#__PURE__*/function (_t399) {
    _inherits(A, _t399);

    var _super108 = _createSuper(A);

    function A() {
      var _this125;

      _classCallCheck(this, A);

      _this125 = _super108.apply(this, arguments), _this125.ar = !1, _this125.arScale = "auto", _this125.arPlacement = "floor", _this125.arModes = "webxr scene-viewer", _this125.iosSrc = null, _this125[e] = !1, _this125[n] = _this125.shadowRoot.querySelector(".ar-button"), _this125[i] = document.createElement("a"), _this125[r] = new Set(), _this125[s] = Md, _this125[o] = !1, _this125[l] = function (t) {
        t.preventDefault(), _this125.activateAR();
      }, _this125[c] = function (_ref19) {
        var t = _ref19.status;
        t !== Bc && _this125[eu].arRenderer.presentedScene !== _this125[Xh] || (_this125.setAttribute("ar-status", t), _this125.dispatchEvent(new CustomEvent("ar-status", {
          detail: {
            status: t
          }
        })), t === Bc ? _this125.removeAttribute("ar-tracking") : t === Tc && _this125.setAttribute("ar-tracking", Dc));
      }, _this125[h] = function (_ref20) {
        var t = _ref20.status;
        _this125.setAttribute("ar-tracking", t), _this125.dispatchEvent(new CustomEvent("ar-tracking", {
          detail: {
            status: t
          }
        }));
      }, _this125[d] = function (t) {
        "_apple_ar_quicklook_button_tapped" == t.data && _this125.dispatchEvent(new CustomEvent("quick-look-button-tapped"));
      };
      return _this125;
    }

    _createClass(A, [{
      key: "canActivateAR",
      get: function get() {
        return this[Dd] !== Md;
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(A.prototype), "connectedCallback", this).call(this), this[eu].arRenderer.addEventListener("status", this[Ud]), this.setAttribute("ar-status", Bc), this[eu].arRenderer.addEventListener("tracking", this[Gd]), this[Pd].addEventListener("message", this[kd]);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(A.prototype), "disconnectedCallback", this).call(this), this[eu].arRenderer.removeEventListener("status", this[Ud]), this[eu].arRenderer.removeEventListener("tracking", this[Gd]), this[Pd].removeEventListener("message", this[kd]);
      }
    }, {
      key: "update",
      value: function () {
        var _update2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(t) {
          return regeneratorRuntime.wrap(function _callee32$(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  _get(_getPrototypeOf(A.prototype), "update", this).call(this, t), t.has("arScale") && (this[Xh].canScale = "fixed" !== this.arScale), t.has("arPlacement") && (this[Xh].setShadowIntensity(this[Xh].shadowIntensity), this[Kh]()), (t.has("ar") || t.has("arModes") || t.has("iosSrc")) && (t.has("arModes") && (this[Qd] = wd(this.arModes)), this[Od]());

                case 1:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee32, this);
        }));

        function update(_x28) {
          return _update2.apply(this, arguments);
        }

        return update;
      }()
    }, {
      key: "activateAR",
      value: function () {
        var _activateAR = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33() {
          return regeneratorRuntime.wrap(function _callee33$(_context33) {
            while (1) {
              switch (_context33.prev = _context33.next) {
                case 0:
                  _context33.t0 = this[Dd];
                  _context33.next = _context33.t0 === _d ? 3 : _context33.t0 === Cd ? 5 : _context33.t0 === Id ? 8 : 10;
                  break;

                case 3:
                  this[Ld]();
                  return _context33.abrupt("break", 11);

                case 5:
                  _context33.next = 7;
                  return this[Bd]();

                case 7:
                  return _context33.abrupt("break", 11);

                case 8:
                  this[Td]();
                  return _context33.abrupt("break", 11);

                case 10:
                  console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities");

                case 11:
                case "end":
                  return _context33.stop();
              }
            }
          }, _callee33, this);
        }));

        function activateAR() {
          return _activateAR.apply(this, arguments);
        }

        return activateAR;
      }()
    }, {
      key: (e = Rd, n = Sd, i = Pd, r = Qd, s = Dd, o = Fd, l = Nd, c = Ud, h = Gd, d = kd, Od),
      value: function () {
        var _value3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34() {
          var _t400, _i242, _t401, _e299, _t402;

          return regeneratorRuntime.wrap(function _callee34$(_context34) {
            while (1) {
              switch (_context34.prev = _context34.next) {
                case 0:
                  if (!(this[Dd] = Md, this.ar)) {
                    _context34.next = 24;
                    break;
                  }

                  _t400 = [];
                  this[Qd].forEach(function (e) {
                    _t400.push(e);
                  });
                  _i242 = 0, _t401 = _t400;

                case 4:
                  if (!(_i242 < _t401.length)) {
                    _context34.next = 23;
                    break;
                  }

                  _e299 = _t401[_i242];
                  _context34.t0 = "webxr" === _e299 && u && !Ed;

                  if (!_context34.t0) {
                    _context34.next = 11;
                    break;
                  }

                  _context34.next = 10;
                  return this[eu].arRenderer.supportsPresentation();

                case 10:
                  _context34.t0 = _context34.sent;

                case 11:
                  if (!_context34.t0) {
                    _context34.next = 14;
                    break;
                  }

                  this[Dd] = Cd;
                  return _context34.abrupt("break", 23);

                case 14:
                  if (!("scene-viewer" === _e299 && f && !xd)) {
                    _context34.next = 17;
                    break;
                  }

                  this[Dd] = Id;
                  return _context34.abrupt("break", 23);

                case 17:
                  if (!("quick-look" === _e299 && p)) {
                    _context34.next = 20;
                    break;
                  }

                  this[Dd] = _d;
                  return _context34.abrupt("break", 23);

                case 20:
                  _i242++;
                  _context34.next = 4;
                  break;

                case 23:
                  !this.canActivateAR && null != this.iosSrc && p && (this[Dd] = _d);

                case 24:
                  if (this.canActivateAR) this[Sd].classList.add("enabled"), this[Sd].addEventListener("click", this[Nd]);else if (this[Sd].classList.contains("enabled")) {
                    this[Sd].removeEventListener("click", this[Nd]), this[Sd].classList.remove("enabled");
                    _t402 = Rc;
                    this.setAttribute("ar-status", _t402), this.dispatchEvent(new CustomEvent("ar-status", {
                      detail: {
                        status: _t402
                      }
                    }));
                  }

                case 25:
                case "end":
                  return _context34.stop();
              }
            }
          }, _callee34, this);
        }));

        function value() {
          return _value3.apply(this, arguments);
        }

        return value;
      }()
    }, {
      key: Bd,
      value: function () {
        var _value4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35() {
          var _t403;

          return regeneratorRuntime.wrap(function _callee35$(_context35) {
            while (1) {
              switch (_context35.prev = _context35.next) {
                case 0:
                  console.log("Attempting to present in AR with WebXR...");
                  _context35.next = 3;
                  return this[Hd]();

                case 3:
                  _context35.prev = 3;
                  this[Sd].removeEventListener("click", this[Nd]);
                  _t403 = this[eu].arRenderer;
                  _t403.placeOnWall = "wall" === this.arPlacement;
                  _context35.next = 9;
                  return _t403.present(this[Xh]);

                case 9:
                  _context35.next = 22;
                  break;

                case 11:
                  _context35.prev = 11;
                  _context35.t0 = _context35["catch"](3);
                  console.warn("Error while trying to present in AR with WebXR");
                  console.error(_context35.t0);
                  _context35.next = 17;
                  return this[eu].arRenderer.stopPresenting();

                case 17:
                  Ed = !0;
                  console.warn("Falling back to next ar-mode");
                  _context35.next = 21;
                  return this[Od]();

                case 21:
                  this.activateAR();

                case 22:
                  _context35.prev = 22;
                  this[Od]();
                  return _context35.finish(22);

                case 25:
                case "end":
                  return _context35.stop();
              }
            }
          }, _callee35, this, [[3, 11, 22, 25]]);
        }));

        function value() {
          return _value4.apply(this, arguments);
        }

        return value;
      }()
    }, {
      key: Hd,
      value: function () {
        var _value5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
          return regeneratorRuntime.wrap(function _callee36$(_context36) {
            while (1) {
              switch (_context36.prev = _context36.next) {
                case 0:
                  _context36.t0 = this.loaded;

                  if (_context36.t0) {
                    _context36.next = 7;
                    break;
                  }

                  this[Fd] = !0;
                  this[Wh]();
                  _context36.next = 6;
                  return function (t, e) {
                    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                    return new Promise(function (i) {
                      t.addEventListener(e, function r(s) {
                        n && !n(s) || (i(s), t.removeEventListener(e, r));
                      });
                    });
                  }(
                  /* @license
                   * Copyright 2020 Google LLC. All Rights Reserved.
                   * Licensed under the Apache License, Version 2.0 (the 'License');
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an 'AS IS' BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */
                  this, "load");

                case 6:
                  this[Fd] = !1;

                case 7:
                case "end":
                  return _context36.stop();
              }
            }
          }, _callee36, this);
        }));

        function value() {
          return _value5.apply(this, arguments);
        }

        return value;
      }()
    }, {
      key: su,
      value: function value() {
        return _get(_getPrototypeOf(A.prototype), su, this).call(this) || this[Fd];
      }
    }, {
      key: Td,
      value: function value() {
        var _this126 = this;

        var t = self.location.toString(),
            e = new URL(t),
            n = new URL(this.src, t),
            i = new URLSearchParams(n.search);

        if (e.hash = "#model-viewer-no-ar-fallback", i.set("mode", "ar_preferred"), i.has("disable_occlusion") || i.set("disable_occlusion", "true"), "fixed" === this.arScale && i.set("resizable", "false"), "wall" === this.arPlacement && i.set("enable_vertical_placement", "true"), i.has("sound")) {
          var _e300 = new URL(i.get("sound"), t);

          i.set("sound", _e300.toString());
        }

        if (i.has("link")) {
          var _e301 = new URL(i.get("link"), t);

          i.set("link", _e301.toString());
        }

        var r = "intent://arvr.google.com/scene-viewer/1.0?".concat(i.toString() + "&file=" + encodeURIComponent(n.toString()), "#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=").concat(encodeURIComponent(e.toString()), ";end;");
        self.addEventListener("hashchange", function () {
          "#model-viewer-no-ar-fallback" === self.location.hash && (xd = !0, self.history.back(), console.warn("Error while trying to present in AR with Scene Viewer"), console.warn("Falling back to next ar-mode"), _this126[Od]());
        }, {
          once: !0
        }), this[Pd].setAttribute("href", r), console.log("Attempting to present in AR with Scene Viewer..."), this[Pd].click();
      }
    }, {
      key: Ld,
      value: function () {
        var _value6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37() {
          var t, e, n, i, r;
          return regeneratorRuntime.wrap(function _callee37$(_context37) {
            while (1) {
              switch (_context37.prev = _context37.next) {
                case 0:
                  t = !this.iosSrc;
                  this[Sd].classList.remove("enabled");

                  if (!t) {
                    _context37.next = 8;
                    break;
                  }

                  _context37.next = 5;
                  return this.prepareUSDZ();

                case 5:
                  _context37.t0 = _context37.sent;
                  _context37.next = 9;
                  break;

                case 8:
                  _context37.t0 = this.iosSrc;

                case 9:
                  e = _context37.t0;
                  n = new URL(e, self.location.toString());
                  "fixed" === this.arScale && (n.hash && (n.hash += "&"), n.hash += "allowsContentScaling=0");
                  i = this[Pd];
                  i.setAttribute("rel", "ar");
                  r = document.createElement("img");
                  i.appendChild(r), i.setAttribute("href", n.toString()), t && i.setAttribute("download", "model.usdz"), console.log("Attempting to present in AR with Quick Look..."), i.click(), i.removeChild(r), t && URL.revokeObjectURL(e), this[Sd].classList.add("enabled");

                case 16:
                case "end":
                  return _context37.stop();
              }
            }
          }, _callee37, this);
        }));

        function value() {
          return _value6.apply(this, arguments);
        }

        return value;
      }()
    }, {
      key: "prepareUSDZ",
      value: function () {
        var _prepareUSDZ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38() {
          var t, e, n, i, r, s, a, o;
          return regeneratorRuntime.wrap(function _callee38$(_context38) {
            while (1) {
              switch (_context38.prev = _context38.next) {
                case 0:
                  t = this[nu].beginActivity();
                  _context38.next = 3;
                  return this[Hd]();

                case 3:
                  e = this[Xh], n = e.shadow;
                  i = !1;
                  null != n && (i = n.visible, n.visible = !1), t(.2);
                  r = new dd();
                  _context38.next = 9;
                  return r.parse(e.modelContainer);

                case 9:
                  s = _context38.sent;
                  a = new Blob([s], {
                    type: "model/vnd.usdz+zip"
                  });
                  o = URL.createObjectURL(a);
                  return _context38.abrupt("return", (t(1), null != n && (n.visible = i), o));

                case 13:
                case "end":
                  return _context38.stop();
              }
            }
          }, _callee38, this);
        }));

        function prepareUSDZ() {
          return _prepareUSDZ.apply(this, arguments);
        }

        return prepareUSDZ;
      }()
    }]);

    return A;
  }(t);

  return yd([a({
    type: Boolean,
    attribute: "ar"
  })], A.prototype, "ar", void 0), yd([a({
    type: String,
    attribute: "ar-scale"
  })], A.prototype, "arScale", void 0), yd([a({
    type: String,
    attribute: "ar-placement"
  })], A.prototype, "arPlacement", void 0), yd([a({
    type: String,
    attribute: "ar-modes"
  })], A.prototype, "arModes", void 0), yd([a({
    type: String,
    attribute: "ios-src"
  })], A.prototype, "iosSrc", void 0), A;
}(function (t) {
  var e, n, i, r, s, o, l, c, h, u, d, A, p;

  var g = /*#__PURE__*/function (_t404) {
    _inherits(g, _t404);

    var _super109 = _createSuper(g);

    function g() {
      var _this127;

      _classCallCheck(this, g);

      for (var _len2 = arguments.length, t = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        t[_key2] = arguments[_key2];
      }

      _this127 = _super109.call.apply(_super109, [this].concat(t)), _this127.poster = null, _this127.reveal = Yp, _this127.loading = Xp, _this127[e] = !1, _this127[n] = !1, _this127[i] = 0, _this127[r] = null, _this127[s] = _this127.shadowRoot.querySelector(".slot.poster"), _this127[o] = _this127.shadowRoot.querySelector("#default-poster"), _this127[l] = _this127.shadowRoot.querySelector("#default-progress-bar > .bar"), _this127[c] = _this127.shadowRoot.querySelector("#default-progress-bar > .mask"), _this127[h] = _this127[ig].getAttribute("aria-label"), _this127[u] = function (t, e) {
        var n = null;

        var i = function i() {
          null == n && (t.apply(void 0, arguments), n = self.setTimeout(function () {
            return n = null;
          }, e));
        };

        return i.flush = function () {
          null != n && (self.clearTimeout(n), n = null);
        }, i;
      }(function (t) {
        var e = _this127[tg].parentNode;
        requestAnimationFrame(function () {
          _this127[eg].style.opacity = "" + .2 * (1 - t), _this127[tg].style.transform = "scaleX(".concat(t, ")"), 0 === t && (e.removeChild(_this127[tg]), e.appendChild(_this127[tg])), 1 === t ? _this127[tg].classList.add("hide") : _this127[tg].classList.remove("hide");
        });
      }, 100), _this127[d] = function () {
        _this127.reveal !== Jp && _this127.dismissPoster();
      }, _this127[A] = function (t) {
        if (_this127.reveal !== Jp) switch (t.keyCode) {
          case 32:
          case 13:
            _this127.dismissPoster();

        }
      }, _this127[p] = function (t) {
        var e = t.detail.totalProgress;
        _this127[lg] = Math.max(e, _this127[lg]), 1 === e && (_this127[og].flush(), !_this127[au]() || null == _this127[rg] && _this127.reveal !== Yp || _this127[sg]()), _this127[og](e), _this127.dispatchEvent(new CustomEvent("progress", {
          detail: {
            totalProgress: e
          }
        }));
      };

      var a = self.ModelViewerElement || {},
          _g3 = a.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.3.6/";

      Rl.setDRACODecoderLocation(_g3);
      var m = a.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
      Rl.setKTX2TranscoderLocation(m);
      return _this127;
    }

    _createClass(g, [{
      key: "dismissPoster",
      value: function dismissPoster() {
        this[au]() ? this[sg]() : (this[rg] = Zp, this[Wh]());
      }
    }, {
      key: "showPoster",
      value: function showPoster() {
        var t = this[ng],
            e = this[ig];
        e.removeAttribute("tabindex"), e.removeAttribute("aria-hidden"), t.classList.add("show");
        var n = this.modelIsVisible;
        this[ag] = !1, this[Hh](n), this[cg] = !1;
      }
    }, {
      key: "getDimensions",
      value: function getDimensions() {
        return lu(this[Xh].size);
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(g.prototype), "connectedCallback", this).call(this), this[ng].addEventListener("click", this[ug]), this[ng].addEventListener("keydown", this[dg]), this[nu].addEventListener("progress", this[Ag]), $p.registerInstance(this);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(g.prototype), "disconnectedCallback", this).call(this), this[ng].removeEventListener("click", this[ug]), this[ng].removeEventListener("keydown", this[dg]), this[nu].removeEventListener("progress", this[Ag]), $p.unregisterInstance(this);
      }
    }, {
      key: "updated",
      value: function () {
        var _updated = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(t) {
          return regeneratorRuntime.wrap(function _callee39$(_context39) {
            while (1) {
              switch (_context39.prev = _context39.next) {
                case 0:
                  _get(_getPrototypeOf(g.prototype), "updated", this).call(this, t), t.has("poster") && null != this.poster && (this[ig].style.backgroundImage = "url(".concat(this.poster, ")")), t.has("alt") && this[ig].setAttribute("aria-label", "".concat(this[zh], ". ").concat(this[hg])), (t.has("reveal") || t.has("loading")) && this[Wh]();

                case 1:
                case "end":
                  return _context39.stop();
              }
            }
          }, _callee39, this);
        }));

        function updated(_x29) {
          return _updated.apply(this, arguments);
        }

        return updated;
      }()
    }, {
      key: (e = ag, n = cg, i = lg, r = rg, s = ng, o = ig, l = tg, c = eg, h = hg, u = og, d = ug, A = dg, p = Ag, su),
      value: function value() {
        return !!this.src && (null != this[rg] || this.loading === Kp || this.reveal === Yp && this[Oh]);
      }
    }, {
      key: au,
      value: function value() {
        var t = this.src;
        return !!t && _get(_getPrototypeOf(g.prototype), au, this).call(this) && 1 === this[lg];
      }
    }, {
      key: sg,
      value: function value() {
        var _this128 = this;

        this[rg] = null;
        var t = this[ng],
            e = this[ig];

        if (t.classList.contains("show")) {
          t.classList.remove("show");
          var _n256 = this.modelIsVisible;
          this[ag] = !0, this[Hh](_n256), t.addEventListener("transitionend", function () {
            requestAnimationFrame(function () {
              _this128[cg] = !0;

              var t = _this128.getRootNode();

              t && t.activeElement === _this128 && _this128[Yh].focus(), e.setAttribute("aria-hidden", "true"), e.tabIndex = -1, _this128.dispatchEvent(new CustomEvent("poster-dismissed"));
            });
          }, {
            once: !0
          });
        }
      }
    }, {
      key: ru,
      value: function value() {
        return _get(_getPrototypeOf(g.prototype), ru, this).call(this) && this[ag];
      }
    }, {
      key: ou,
      value: function value() {
        return _get(_getPrototypeOf(g.prototype), ou, this).call(this) && this[cg];
      }
    }, {
      key: Wh,
      value: function () {
        var _value7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40() {
          return regeneratorRuntime.wrap(function _callee40$(_context40) {
            while (1) {
              switch (_context40.prev = _context40.next) {
                case 0:
                  this[lg] = 0;
                  null != this[Xh].currentGLTF && null != this.src && this[su]() || this.showPoster();
                  _context40.next = 4;
                  return _get(_getPrototypeOf(g.prototype), Wh, this).call(this);

                case 4:
                case "end":
                  return _context40.stop();
              }
            }
          }, _callee40, this);
        }));

        function value() {
          return _value7.apply(this, arguments);
        }

        return value;
      }()
    }], [{
      key: "dracoDecoderLocation",
      get: function get() {
        return Rl.getDRACODecoderLocation();
      },
      set: function set(t) {
        Rl.setDRACODecoderLocation(t);
      }
    }, {
      key: "ktx2TranscoderLocation",
      get: function get() {
        return Rl.getKTX2TranscoderLocation();
      },
      set: function set(t) {
        Rl.setKTX2TranscoderLocation(t);
      }
    }, {
      key: "mapURLs",
      value: function mapURLs(t) {
        dh.singleton.loader[Bl].manager.setURLModifier(t);
      }
    }]);

    return g;
  }(t);

  return jp([a({
    type: String
  })], g.prototype, "poster", void 0), jp([a({
    type: String
  })], g.prototype, "reveal", void 0), jp([a({
    type: String
  })], g.prototype, "loading", void 0), g;
}(function (t) {
  var e;

  var n = /*#__PURE__*/function (_t405) {
    _inherits(n, _t405);

    var _super110 = _createSuper(n);

    function n() {
      var _this129;

      _classCallCheck(this, n);

      _this129 = _super110.apply(this, arguments), _this129.autoplay = !1, _this129.animationName = void 0, _this129.animationCrossfadeDuration = 300, _this129[e] = !0;
      return _this129;
    }

    _createClass(n, [{
      key: "availableAnimations",
      get: function get() {
        return this.loaded ? this[Xh].animationNames : [];
      }
    }, {
      key: "duration",
      get: function get() {
        return this[Xh].duration;
      }
    }, {
      key: "paused",
      get: function get() {
        return this[du];
      }
    }, {
      key: "currentTime",
      get: function get() {
        return this[Xh].animationTime;
      },
      set: function set(t) {
        this[Xh].animationTime = t, this[eu].threeRenderer.shadowMap.needsUpdate = !0, this[Kh]();
      }
    }, {
      key: "pause",
      value: function pause() {
        this[du] || (this[du] = !0, this[eu].threeRenderer.shadowMap.autoUpdate = !1, this.dispatchEvent(new CustomEvent("pause")));
      }
    }, {
      key: "play",
      value: function play() {
        this[du] && this.availableAnimations.length > 0 && (this[du] = !1, this[eu].threeRenderer.shadowMap.autoUpdate = !0, this[Xh].hasActiveAnimation || this[uu](), this.dispatchEvent(new CustomEvent("play")));
      }
    }, {
      key: (e = du, $h),
      value: function value() {
        _get(_getPrototypeOf(n.prototype), $h, this).call(this), this[du] = !0, this.autoplay && (this[uu](), this.play());
      }
    }, {
      key: Zh,
      value: function value(t, e) {
        _get(_getPrototypeOf(n.prototype), Zh, this).call(this, t, e), this[du] || !this[ou]() && !this[eu].isPresenting || (this[Xh].updateAnimation(e / 1e3), this[Kh]());
      }
    }, {
      key: "updated",
      value: function updated(t) {
        _get(_getPrototypeOf(n.prototype), "updated", this).call(this, t), t.has("autoplay") && this.autoplay && this.play(), t.has("animationName") && this[uu]();
      }
    }, {
      key: Wh,
      value: function () {
        var _value8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41() {
          return regeneratorRuntime.wrap(function _callee41$(_context41) {
            while (1) {
              switch (_context41.prev = _context41.next) {
                case 0:
                  return _context41.abrupt("return", (this[Xh].stopAnimation(), _get(_getPrototypeOf(n.prototype), Wh, this).call(this)));

                case 1:
                case "end":
                  return _context41.stop();
              }
            }
          }, _callee41, this);
        }));

        function value() {
          return _value8.apply(this, arguments);
        }

        return value;
      }()
    }, {
      key: uu,
      value: function value() {
        this[Xh].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3), this[du] && (this[Xh].updateAnimation(0), this[Kh]());
      }
    }]);

    return n;
  }(t);

  return hu([a({
    type: Boolean
  })], n.prototype, "autoplay", void 0), hu([a({
    type: String,
    attribute: "animation-name"
  })], n.prototype, "animationName", void 0), hu([a({
    type: Number,
    attribute: "animation-crossfade-duration"
  })], n.prototype, "animationCrossfadeDuration", void 0), n;
}(function (t) {
  var e;
  var n = Symbol("endPolyfillCoordination");
  return e = n, /*#__PURE__*/function (_t406) {
    _inherits(_class9, _t406);

    var _super111 = _createSuper(_class9);

    function _class9() {
      var _this130;

      _classCallCheck(this, _class9);

      _this130 = _super111.apply(this, arguments), _this130[e] = null;
      return _this130;
    }

    _createClass(_class9, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class9.prototype), "connectedCallback", this) && _get(_getPrototypeOf(_class9.prototype), "connectedCallback", this).call(this), null == this[n] && (this[n] = function (t) {
          if (null == t.shadowRoot || t.hasAttribute("data-js-focus-visible")) return function () {};

          if (!self.applyFocusVisiblePolyfill) {
            var _e302 = function _e302() {
              self.applyFocusVisiblePolyfill(t.shadowRoot);
            };

            return self.addEventListener("focus-visible-polyfill-ready", _e302, {
              once: !0
            }), function () {
              self.removeEventListener("focus-visible-polyfill-ready", _e302);
            };
          }

          return self.applyFocusVisiblePolyfill(t.shadowRoot), function () {};
        }(this));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class9.prototype), "disconnectedCallback", this) && _get(_getPrototypeOf(_class9.prototype), "disconnectedCallback", this).call(this), null != this[n] && (this[n](), this[n] = null);
      }
    }]);

    return _class9;
  }(t);
}(cu)))))))));

exports.ModelViewerElement = Om;
customElements.define("model-viewer", Om);
},{"buffer":"node_modules/buffer/index.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "57135" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","scripts/model-viewer.min.js"], null)
//# sourceMappingURL=/model-viewer.min.f820d277.js.map